/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/whiteboard/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Ftaksh%2FDesktop%2Fideaflow%2Fclient%2Fsrc%2Fapp%2Fwhiteboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Ftaksh%2FDesktop%2Fideaflow%2Fclient%2Fsrc%2Fapp%2Fwhiteboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/whiteboard/page.tsx */ \"(app-pages-browser)/./src/app/whiteboard/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGaG9tZSUyRnRha3NoJTJGRGVza3RvcCUyRmlkZWFmbG93JTJGY2xpZW50JTJGc3JjJTJGYXBwJTJGd2hpdGVib2FyZCUyRnBhZ2UudHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsb0xBQW9HIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/Zjg1MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9ob21lL3Rha3NoL0Rlc2t0b3AvaWRlYWZsb3cvY2xpZW50L3NyYy9hcHAvd2hpdGVib2FyZC9wYWdlLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Ftaksh%2FDesktop%2Fideaflow%2Fclient%2Fsrc%2Fapp%2Fwhiteboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzc3MWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/path-data-parser/lib/absolutize.js":
/*!*********************************************************!*\
  !*** ./node_modules/path-data-parser/lib/absolutize.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutize: function() { return /* binding */ absolutize; }\n/* harmony export */ });\n// Translate relative commands to absolute commands\nfunction absolutize(segments) {\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    const out = [];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'm':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'M', data: [cx, cy] });\n                subx = cx;\n                suby = cy;\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'l':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                break;\n            case 'c': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'C', data: newdata });\n                cx = newdata[4];\n                cy = newdata[5];\n                break;\n            }\n            case 'Q':\n                out.push({ key: 'Q', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 'q': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'Q', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'A':\n                out.push({ key: 'A', data: [...data] });\n                cx = data[5];\n                cy = data[6];\n                break;\n            case 'a':\n                cx += data[5];\n                cy += data[6];\n                out.push({ key: 'A', data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });\n                break;\n            case 'H':\n                out.push({ key: 'H', data: [...data] });\n                cx = data[0];\n                break;\n            case 'h':\n                cx += data[0];\n                out.push({ key: 'H', data: [cx] });\n                break;\n            case 'V':\n                out.push({ key: 'V', data: [...data] });\n                cy = data[0];\n                break;\n            case 'v':\n                cy += data[0];\n                out.push({ key: 'V', data: [cy] });\n                break;\n            case 'S':\n                out.push({ key: 'S', data: [...data] });\n                cx = data[2];\n                cy = data[3];\n                break;\n            case 's': {\n                const newdata = data.map((d, i) => (i % 2) ? (d + cy) : (d + cx));\n                out.push({ key: 'S', data: newdata });\n                cx = newdata[2];\n                cy = newdata[3];\n                break;\n            }\n            case 'T':\n                out.push({ key: 'T', data: [...data] });\n                cx = data[0];\n                cy = data[1];\n                break;\n            case 't':\n                cx += data[0];\n                cy += data[1];\n                out.push({ key: 'T', data: [cx, cy] });\n                break;\n            case 'Z':\n            case 'z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9hYnNvbHV0aXplLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVFQUF1RTtBQUNsRztBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGF0aC1kYXRhLXBhcnNlci9saWIvYWJzb2x1dGl6ZS5qcz8xNDg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRyYW5zbGF0ZSByZWxhdGl2ZSBjb21tYW5kcyB0byBhYnNvbHV0ZSBjb21tYW5kc1xuZXhwb3J0IGZ1bmN0aW9uIGFic29sdXRpemUoc2VnbWVudHMpIHtcbiAgICBsZXQgY3ggPSAwLCBjeSA9IDA7XG4gICAgbGV0IHN1YnggPSAwLCBzdWJ5ID0gMDtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkYXRhIH0gb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTScsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBbY3gsIGN5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgW3N1YngsIHN1YnldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIGN4ICs9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgY3kgKz0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ00nLCBkYXRhOiBbY3gsIGN5XSB9KTtcbiAgICAgICAgICAgICAgICBzdWJ4ID0gY3g7XG4gICAgICAgICAgICAgICAgc3VieSA9IGN5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdMJywgZGF0YTogWy4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIFtjeCwgY3ldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgIGN4ICs9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgY3kgKz0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0wnLCBkYXRhOiBbY3gsIGN5XSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbNF07XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdkYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+IChpICUgMikgPyAoZCArIGN5KSA6IChkICsgY3gpKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0MnLCBkYXRhOiBuZXdkYXRhIH0pO1xuICAgICAgICAgICAgICAgIGN4ID0gbmV3ZGF0YVs0XTtcbiAgICAgICAgICAgICAgICBjeSA9IG5ld2RhdGFbNV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1EnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBkYXRhWzJdO1xuICAgICAgICAgICAgICAgIGN5ID0gZGF0YVszXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3EnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3ZGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiAoaSAlIDIpID8gKGQgKyBjeSkgOiAoZCArIGN4KSk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdRJywgZGF0YTogbmV3ZGF0YSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IG5ld2RhdGFbMl07XG4gICAgICAgICAgICAgICAgY3kgPSBuZXdkYXRhWzNdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdBJywgZGF0YTogWy4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIGN4ID0gZGF0YVs1XTtcbiAgICAgICAgICAgICAgICBjeSA9IGRhdGFbNl07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgICBjeCArPSBkYXRhWzVdO1xuICAgICAgICAgICAgICAgIGN5ICs9IGRhdGFbNl07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdBJywgZGF0YTogW2RhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10sIGRhdGFbNF0sIGN4LCBjeV0gfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0gnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgY3ggKz0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0gnLCBkYXRhOiBbY3hdIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdWJywgZGF0YTogWy4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIGN5ID0gZGF0YVswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgIGN5ICs9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdWJywgZGF0YTogW2N5XSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnUycsIGRhdGE6IFsuLi5kYXRhXSB9KTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbMl07XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzNdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdkYXRhID0gZGF0YS5tYXAoKGQsIGkpID0+IChpICUgMikgPyAoZCArIGN5KSA6IChkICsgY3gpKTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1MnLCBkYXRhOiBuZXdkYXRhIH0pO1xuICAgICAgICAgICAgICAgIGN4ID0gbmV3ZGF0YVsyXTtcbiAgICAgICAgICAgICAgICBjeSA9IG5ld2RhdGFbM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1QnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIGN5ID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgIGN4ICs9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgY3kgKz0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ1QnLCBkYXRhOiBbY3gsIGN5XSB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdaJywgZGF0YTogW10gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBzdWJ4O1xuICAgICAgICAgICAgICAgIGN5ID0gc3VieTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/path-data-parser/lib/absolutize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/path-data-parser/lib/index.js":
/*!****************************************************!*\
  !*** ./node_modules/path-data-parser/lib/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutize: function() { return /* reexport safe */ _absolutize_js__WEBPACK_IMPORTED_MODULE_1__.absolutize; },\n/* harmony export */   normalize: function() { return /* reexport safe */ _normalize_js__WEBPACK_IMPORTED_MODULE_2__.normalize; },\n/* harmony export */   parsePath: function() { return /* reexport safe */ _parser_js__WEBPACK_IMPORTED_MODULE_0__.parsePath; },\n/* harmony export */   serialize: function() { return /* reexport safe */ _parser_js__WEBPACK_IMPORTED_MODULE_0__.serialize; }\n/* harmony export */ });\n/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parser.js */ \"(app-pages-browser)/./node_modules/path-data-parser/lib/parser.js\");\n/* harmony import */ var _absolutize_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./absolutize.js */ \"(app-pages-browser)/./node_modules/path-data-parser/lib/absolutize.js\");\n/* harmony import */ var _normalize_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./normalize.js */ \"(app-pages-browser)/./node_modules/path-data-parser/lib/normalize.js\");\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1EO0FBQ047QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGF0aC1kYXRhLXBhcnNlci9saWIvaW5kZXguanM/YzI2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBwYXJzZVBhdGgsIHNlcmlhbGl6ZSB9IGZyb20gJy4vcGFyc2VyLmpzJztcbmV4cG9ydCB7IGFic29sdXRpemUgfSBmcm9tICcuL2Fic29sdXRpemUuanMnO1xuZXhwb3J0IHsgbm9ybWFsaXplIH0gZnJvbSAnLi9ub3JtYWxpemUuanMnO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/path-data-parser/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/path-data-parser/lib/normalize.js":
/*!********************************************************!*\
  !*** ./node_modules/path-data-parser/lib/normalize.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   normalize: function() { return /* binding */ normalize; }\n/* harmony export */ });\n// Normalize path to include only M, L, C, and Z commands\nfunction normalize(segments) {\n    const out = [];\n    let lastType = '';\n    let cx = 0, cy = 0;\n    let subx = 0, suby = 0;\n    let lcx = 0, lcy = 0;\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M':\n                out.push({ key: 'M', data: [...data] });\n                [cx, cy] = data;\n                [subx, suby] = data;\n                break;\n            case 'C':\n                out.push({ key: 'C', data: [...data] });\n                cx = data[4];\n                cy = data[5];\n                lcx = data[2];\n                lcy = data[3];\n                break;\n            case 'L':\n                out.push({ key: 'L', data: [...data] });\n                [cx, cy] = data;\n                break;\n            case 'H':\n                cx = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'V':\n                cy = data[0];\n                out.push({ key: 'L', data: [cx, cy] });\n                break;\n            case 'S': {\n                let cx1 = 0, cy1 = 0;\n                if (lastType === 'C' || lastType === 'S') {\n                    cx1 = cx + (cx - lcx);\n                    cy1 = cy + (cy - lcy);\n                }\n                else {\n                    cx1 = cx;\n                    cy1 = cy;\n                }\n                out.push({ key: 'C', data: [cx1, cy1, ...data] });\n                lcx = data[0];\n                lcy = data[1];\n                cx = data[2];\n                cy = data[3];\n                break;\n            }\n            case 'T': {\n                const [x, y] = data;\n                let x1 = 0, y1 = 0;\n                if (lastType === 'Q' || lastType === 'T') {\n                    x1 = cx + (cx - lcx);\n                    y1 = cy + (cy - lcy);\n                }\n                else {\n                    x1 = cx;\n                    y1 = cy;\n                }\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'Q': {\n                const [x1, y1, x, y] = data;\n                const cx1 = cx + 2 * (x1 - cx) / 3;\n                const cy1 = cy + 2 * (y1 - cy) / 3;\n                const cx2 = x + 2 * (x1 - x) / 3;\n                const cy2 = y + 2 * (y1 - y) / 3;\n                out.push({ key: 'C', data: [cx1, cy1, cx2, cy2, x, y] });\n                lcx = x1;\n                lcy = y1;\n                cx = x;\n                cy = y;\n                break;\n            }\n            case 'A': {\n                const r1 = Math.abs(data[0]);\n                const r2 = Math.abs(data[1]);\n                const angle = data[2];\n                const largeArcFlag = data[3];\n                const sweepFlag = data[4];\n                const x = data[5];\n                const y = data[6];\n                if (r1 === 0 || r2 === 0) {\n                    out.push({ key: 'C', data: [cx, cy, x, y, x, y] });\n                    cx = x;\n                    cy = y;\n                }\n                else {\n                    if (cx !== x || cy !== y) {\n                        const curves = arcToCubicCurves(cx, cy, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n                        curves.forEach(function (curve) {\n                            out.push({ key: 'C', data: curve });\n                        });\n                        cx = x;\n                        cy = y;\n                    }\n                }\n                break;\n            }\n            case 'Z':\n                out.push({ key: 'Z', data: [] });\n                cx = subx;\n                cy = suby;\n                break;\n        }\n        lastType = key;\n    }\n    return out;\n}\nfunction degToRad(degrees) {\n    return (Math.PI * degrees) / 180;\n}\nfunction rotate(x, y, angleRad) {\n    const X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    const Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return [X, Y];\n}\nfunction arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, recursive) {\n    const angleRad = degToRad(angle);\n    let params = [];\n    let f1 = 0, f2 = 0, cx = 0, cy = 0;\n    if (recursive) {\n        [f1, f2, cx, cy] = recursive;\n    }\n    else {\n        [x1, y1] = rotate(x1, y1, -angleRad);\n        [x2, y2] = rotate(x2, y2, -angleRad);\n        const x = (x1 - x2) / 2;\n        const y = (y1 - y2) / 2;\n        let h = (x * x) / (r1 * r1) + (y * y) / (r2 * r2);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            r1 = h * r1;\n            r2 = h * r2;\n        }\n        const sign = (largeArcFlag === sweepFlag) ? -1 : 1;\n        const r1Pow = r1 * r1;\n        const r2Pow = r2 * r2;\n        const left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n        const right = r1Pow * y * y + r2Pow * x * x;\n        const k = sign * Math.sqrt(Math.abs(left / right));\n        cx = k * r1 * y / r2 + (x1 + x2) / 2;\n        cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n        f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\n        f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\n        if (x1 < cx) {\n            f1 = Math.PI - f1;\n        }\n        if (x2 < cx) {\n            f2 = Math.PI - f2;\n        }\n        if (f1 < 0) {\n            f1 = Math.PI * 2 + f1;\n        }\n        if (f2 < 0) {\n            f2 = Math.PI * 2 + f2;\n        }\n        if (sweepFlag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweepFlag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    }\n    let df = f2 - f1;\n    if (Math.abs(df) > (Math.PI * 120 / 180)) {\n        const f2old = f2;\n        const x2old = x2;\n        const y2old = y2;\n        if (sweepFlag && f2 > f1) {\n            f2 = f1 + (Math.PI * 120 / 180) * (1);\n        }\n        else {\n            f2 = f1 + (Math.PI * 120 / 180) * (-1);\n        }\n        x2 = cx + r1 * Math.cos(f2);\n        y2 = cy + r2 * Math.sin(f2);\n        params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    const c1 = Math.cos(f1);\n    const s1 = Math.sin(f1);\n    const c2 = Math.cos(f2);\n    const s2 = Math.sin(f2);\n    const t = Math.tan(df / 4);\n    const hx = 4 / 3 * r1 * t;\n    const hy = 4 / 3 * r2 * t;\n    const m1 = [x1, y1];\n    const m2 = [x1 + hx * s1, y1 - hy * c1];\n    const m3 = [x2 + hx * s2, y2 - hy * c2];\n    const m4 = [x2, y2];\n    m2[0] = 2 * m1[0] - m2[0];\n    m2[1] = 2 * m1[1] - m2[1];\n    if (recursive) {\n        return [m2, m3, m4].concat(params);\n    }\n    else {\n        params = [m2, m3, m4].concat(params);\n        const curves = [];\n        for (let i = 0; i < params.length; i += 3) {\n            const r1 = rotate(params[i][0], params[i][1], angleRad);\n            const r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);\n            const r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);\n            curves.push([r1[0], r1[1], r2[0], r2[1], r3[0], r3[1]]);\n        }\n        return curves;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9ub3JtYWxpemUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDRDQUE0QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNENBQTRDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQ0FBc0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcGF0aC1kYXRhLXBhcnNlci9saWIvbm9ybWFsaXplLmpzP2Q1NjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTm9ybWFsaXplIHBhdGggdG8gaW5jbHVkZSBvbmx5IE0sIEwsIEMsIGFuZCBaIGNvbW1hbmRzXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHNlZ21lbnRzKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgbGV0IGxhc3RUeXBlID0gJyc7XG4gICAgbGV0IGN4ID0gMCwgY3kgPSAwO1xuICAgIGxldCBzdWJ4ID0gMCwgc3VieSA9IDA7XG4gICAgbGV0IGxjeCA9IDAsIGxjeSA9IDA7XG4gICAgZm9yIChjb25zdCB7IGtleSwgZGF0YSB9IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ00nLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgW2N4LCBjeV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIFtzdWJ4LCBzdWJ5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0MnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBkYXRhWzRdO1xuICAgICAgICAgICAgICAgIGN5ID0gZGF0YVs1XTtcbiAgICAgICAgICAgICAgICBsY3ggPSBkYXRhWzJdO1xuICAgICAgICAgICAgICAgIGxjeSA9IGRhdGFbM107XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0wnLCBkYXRhOiBbLi4uZGF0YV0gfSk7XG4gICAgICAgICAgICAgICAgW2N4LCBjeV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICAgICAgY3ggPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTCcsIGRhdGE6IFtjeCwgY3ldIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzBdO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnTCcsIGRhdGE6IFtjeCwgY3ldIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUyc6IHtcbiAgICAgICAgICAgICAgICBsZXQgY3gxID0gMCwgY3kxID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFR5cGUgPT09ICdDJyB8fCBsYXN0VHlwZSA9PT0gJ1MnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN4MSA9IGN4ICsgKGN4IC0gbGN4KTtcbiAgICAgICAgICAgICAgICAgICAgY3kxID0gY3kgKyAoY3kgLSBsY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3gxID0gY3g7XG4gICAgICAgICAgICAgICAgICAgIGN5MSA9IGN5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0MnLCBkYXRhOiBbY3gxLCBjeTEsIC4uLmRhdGFdIH0pO1xuICAgICAgICAgICAgICAgIGxjeCA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgbGN5ID0gZGF0YVsxXTtcbiAgICAgICAgICAgICAgICBjeCA9IGRhdGFbMl07XG4gICAgICAgICAgICAgICAgY3kgPSBkYXRhWzNdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeCwgeV0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIGxldCB4MSA9IDAsIHkxID0gMDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFR5cGUgPT09ICdRJyB8fCBsYXN0VHlwZSA9PT0gJ1QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gY3ggKyAoY3ggLSBsY3gpO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGN5ICsgKGN5IC0gbGN5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHgxID0gY3g7XG4gICAgICAgICAgICAgICAgICAgIHkxID0gY3k7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN4MSA9IGN4ICsgMiAqICh4MSAtIGN4KSAvIDM7XG4gICAgICAgICAgICAgICAgY29uc3QgY3kxID0gY3kgKyAyICogKHkxIC0gY3kpIC8gMztcbiAgICAgICAgICAgICAgICBjb25zdCBjeDIgPSB4ICsgMiAqICh4MSAtIHgpIC8gMztcbiAgICAgICAgICAgICAgICBjb25zdCBjeTIgPSB5ICsgMiAqICh5MSAtIHkpIC8gMztcbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0MnLCBkYXRhOiBbY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5XSB9KTtcbiAgICAgICAgICAgICAgICBsY3ggPSB4MTtcbiAgICAgICAgICAgICAgICBsY3kgPSB5MTtcbiAgICAgICAgICAgICAgICBjeCA9IHg7XG4gICAgICAgICAgICAgICAgY3kgPSB5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxLCB4LCB5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgY3gxID0gY3ggKyAyICogKHgxIC0gY3gpIC8gMztcbiAgICAgICAgICAgICAgICBjb25zdCBjeTEgPSBjeSArIDIgKiAoeTEgLSBjeSkgLyAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN4MiA9IHggKyAyICogKHgxIC0geCkgLyAzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN5MiA9IHkgKyAyICogKHkxIC0geSkgLyAzO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHsga2V5OiAnQycsIGRhdGE6IFtjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHldIH0pO1xuICAgICAgICAgICAgICAgIGxjeCA9IHgxO1xuICAgICAgICAgICAgICAgIGxjeSA9IHkxO1xuICAgICAgICAgICAgICAgIGN4ID0geDtcbiAgICAgICAgICAgICAgICBjeSA9IHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIxID0gTWF0aC5hYnMoZGF0YVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcjIgPSBNYXRoLmFicyhkYXRhWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbmdsZSA9IGRhdGFbMl07XG4gICAgICAgICAgICAgICAgY29uc3QgbGFyZ2VBcmNGbGFnID0gZGF0YVszXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzd2VlcEZsYWcgPSBkYXRhWzRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBkYXRhWzVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBkYXRhWzZdO1xuICAgICAgICAgICAgICAgIGlmIChyMSA9PT0gMCB8fCByMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0MnLCBkYXRhOiBbY3gsIGN5LCB4LCB5LCB4LCB5XSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICBjeSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3ggIT09IHggfHwgY3kgIT09IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnZlcyA9IGFyY1RvQ3ViaWNDdXJ2ZXMoY3gsIGN5LCB4LCB5LCByMSwgcjIsIGFuZ2xlLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJ2ZXMuZm9yRWFjaChmdW5jdGlvbiAoY3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGtleTogJ0MnLCBkYXRhOiBjdXJ2ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goeyBrZXk6ICdaJywgZGF0YTogW10gfSk7XG4gICAgICAgICAgICAgICAgY3ggPSBzdWJ4O1xuICAgICAgICAgICAgICAgIGN5ID0gc3VieTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsYXN0VHlwZSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGRlZ1RvUmFkKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gKE1hdGguUEkgKiBkZWdyZWVzKSAvIDE4MDtcbn1cbmZ1bmN0aW9uIHJvdGF0ZSh4LCB5LCBhbmdsZVJhZCkge1xuICAgIGNvbnN0IFggPSB4ICogTWF0aC5jb3MoYW5nbGVSYWQpIC0geSAqIE1hdGguc2luKGFuZ2xlUmFkKTtcbiAgICBjb25zdCBZID0geCAqIE1hdGguc2luKGFuZ2xlUmFkKSArIHkgKiBNYXRoLmNvcyhhbmdsZVJhZCk7XG4gICAgcmV0dXJuIFtYLCBZXTtcbn1cbmZ1bmN0aW9uIGFyY1RvQ3ViaWNDdXJ2ZXMoeDEsIHkxLCB4MiwgeTIsIHIxLCByMiwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCByZWN1cnNpdmUpIHtcbiAgICBjb25zdCBhbmdsZVJhZCA9IGRlZ1RvUmFkKGFuZ2xlKTtcbiAgICBsZXQgcGFyYW1zID0gW107XG4gICAgbGV0IGYxID0gMCwgZjIgPSAwLCBjeCA9IDAsIGN5ID0gMDtcbiAgICBpZiAocmVjdXJzaXZlKSB7XG4gICAgICAgIFtmMSwgZjIsIGN4LCBjeV0gPSByZWN1cnNpdmU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBbeDEsIHkxXSA9IHJvdGF0ZSh4MSwgeTEsIC1hbmdsZVJhZCk7XG4gICAgICAgIFt4MiwgeTJdID0gcm90YXRlKHgyLCB5MiwgLWFuZ2xlUmFkKTtcbiAgICAgICAgY29uc3QgeCA9ICh4MSAtIHgyKSAvIDI7XG4gICAgICAgIGNvbnN0IHkgPSAoeTEgLSB5MikgLyAyO1xuICAgICAgICBsZXQgaCA9ICh4ICogeCkgLyAocjEgKiByMSkgKyAoeSAqIHkpIC8gKHIyICogcjIpO1xuICAgICAgICBpZiAoaCA+IDEpIHtcbiAgICAgICAgICAgIGggPSBNYXRoLnNxcnQoaCk7XG4gICAgICAgICAgICByMSA9IGggKiByMTtcbiAgICAgICAgICAgIHIyID0gaCAqIHIyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ24gPSAobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcpID8gLTEgOiAxO1xuICAgICAgICBjb25zdCByMVBvdyA9IHIxICogcjE7XG4gICAgICAgIGNvbnN0IHIyUG93ID0gcjIgKiByMjtcbiAgICAgICAgY29uc3QgbGVmdCA9IHIxUG93ICogcjJQb3cgLSByMVBvdyAqIHkgKiB5IC0gcjJQb3cgKiB4ICogeDtcbiAgICAgICAgY29uc3QgcmlnaHQgPSByMVBvdyAqIHkgKiB5ICsgcjJQb3cgKiB4ICogeDtcbiAgICAgICAgY29uc3QgayA9IHNpZ24gKiBNYXRoLnNxcnQoTWF0aC5hYnMobGVmdCAvIHJpZ2h0KSk7XG4gICAgICAgIGN4ID0gayAqIHIxICogeSAvIHIyICsgKHgxICsgeDIpIC8gMjtcbiAgICAgICAgY3kgPSBrICogLXIyICogeCAvIHIxICsgKHkxICsgeTIpIC8gMjtcbiAgICAgICAgZjEgPSBNYXRoLmFzaW4ocGFyc2VGbG9hdCgoKHkxIC0gY3kpIC8gcjIpLnRvRml4ZWQoOSkpKTtcbiAgICAgICAgZjIgPSBNYXRoLmFzaW4ocGFyc2VGbG9hdCgoKHkyIC0gY3kpIC8gcjIpLnRvRml4ZWQoOSkpKTtcbiAgICAgICAgaWYgKHgxIDwgY3gpIHtcbiAgICAgICAgICAgIGYxID0gTWF0aC5QSSAtIGYxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4MiA8IGN4KSB7XG4gICAgICAgICAgICBmMiA9IE1hdGguUEkgLSBmMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZjEgPCAwKSB7XG4gICAgICAgICAgICBmMSA9IE1hdGguUEkgKiAyICsgZjE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGYyIDwgMCkge1xuICAgICAgICAgICAgZjIgPSBNYXRoLlBJICogMiArIGYyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzd2VlcEZsYWcgJiYgZjEgPiBmMikge1xuICAgICAgICAgICAgZjEgPSBmMSAtIE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3dlZXBGbGFnICYmIGYyID4gZjEpIHtcbiAgICAgICAgICAgIGYyID0gZjIgLSBNYXRoLlBJICogMjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGYgPSBmMiAtIGYxO1xuICAgIGlmIChNYXRoLmFicyhkZikgPiAoTWF0aC5QSSAqIDEyMCAvIDE4MCkpIHtcbiAgICAgICAgY29uc3QgZjJvbGQgPSBmMjtcbiAgICAgICAgY29uc3QgeDJvbGQgPSB4MjtcbiAgICAgICAgY29uc3QgeTJvbGQgPSB5MjtcbiAgICAgICAgaWYgKHN3ZWVwRmxhZyAmJiBmMiA+IGYxKSB7XG4gICAgICAgICAgICBmMiA9IGYxICsgKE1hdGguUEkgKiAxMjAgLyAxODApICogKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZjIgPSBmMSArIChNYXRoLlBJICogMTIwIC8gMTgwKSAqICgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgeDIgPSBjeCArIHIxICogTWF0aC5jb3MoZjIpO1xuICAgICAgICB5MiA9IGN5ICsgcjIgKiBNYXRoLnNpbihmMik7XG4gICAgICAgIHBhcmFtcyA9IGFyY1RvQ3ViaWNDdXJ2ZXMoeDIsIHkyLCB4Mm9sZCwgeTJvbGQsIHIxLCByMiwgYW5nbGUsIDAsIHN3ZWVwRmxhZywgW2YyLCBmMm9sZCwgY3gsIGN5XSk7XG4gICAgfVxuICAgIGRmID0gZjIgLSBmMTtcbiAgICBjb25zdCBjMSA9IE1hdGguY29zKGYxKTtcbiAgICBjb25zdCBzMSA9IE1hdGguc2luKGYxKTtcbiAgICBjb25zdCBjMiA9IE1hdGguY29zKGYyKTtcbiAgICBjb25zdCBzMiA9IE1hdGguc2luKGYyKTtcbiAgICBjb25zdCB0ID0gTWF0aC50YW4oZGYgLyA0KTtcbiAgICBjb25zdCBoeCA9IDQgLyAzICogcjEgKiB0O1xuICAgIGNvbnN0IGh5ID0gNCAvIDMgKiByMiAqIHQ7XG4gICAgY29uc3QgbTEgPSBbeDEsIHkxXTtcbiAgICBjb25zdCBtMiA9IFt4MSArIGh4ICogczEsIHkxIC0gaHkgKiBjMV07XG4gICAgY29uc3QgbTMgPSBbeDIgKyBoeCAqIHMyLCB5MiAtIGh5ICogYzJdO1xuICAgIGNvbnN0IG00ID0gW3gyLCB5Ml07XG4gICAgbTJbMF0gPSAyICogbTFbMF0gLSBtMlswXTtcbiAgICBtMlsxXSA9IDIgKiBtMVsxXSAtIG0yWzFdO1xuICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgICAgcmV0dXJuIFttMiwgbTMsIG00XS5jb25jYXQocGFyYW1zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IFttMiwgbTMsIG00XS5jb25jYXQocGFyYW1zKTtcbiAgICAgICAgY29uc3QgY3VydmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBjb25zdCByMSA9IHJvdGF0ZShwYXJhbXNbaV1bMF0sIHBhcmFtc1tpXVsxXSwgYW5nbGVSYWQpO1xuICAgICAgICAgICAgY29uc3QgcjIgPSByb3RhdGUocGFyYW1zW2kgKyAxXVswXSwgcGFyYW1zW2kgKyAxXVsxXSwgYW5nbGVSYWQpO1xuICAgICAgICAgICAgY29uc3QgcjMgPSByb3RhdGUocGFyYW1zW2kgKyAyXVswXSwgcGFyYW1zW2kgKyAyXVsxXSwgYW5nbGVSYWQpO1xuICAgICAgICAgICAgY3VydmVzLnB1c2goW3IxWzBdLCByMVsxXSwgcjJbMF0sIHIyWzFdLCByM1swXSwgcjNbMV1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VydmVzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/path-data-parser/lib/normalize.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/path-data-parser/lib/parser.js":
/*!*****************************************************!*\
  !*** ./node_modules/path-data-parser/lib/parser.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parsePath: function() { return /* binding */ parsePath; },\n/* harmony export */   serialize: function() { return /* binding */ serialize; }\n/* harmony export */ });\nconst COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\nconst PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };\nfunction tokenize(d) {\n    const tokens = new Array();\n    while (d !== '') {\n        if (d.match(/^([ \\t\\r\\n,]+)/)) {\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n            tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };\n            d = d.substr(RegExp.$1.length);\n        }\n        else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n            tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };\n            d = d.substr(RegExp.$1.length);\n        }\n        else {\n            return [];\n        }\n    }\n    tokens[tokens.length] = { type: EOD, text: '' };\n    return tokens;\n}\nfunction isType(token, type) {\n    return token.type === type;\n}\nfunction parsePath(d) {\n    const segments = [];\n    const tokens = tokenize(d);\n    let mode = 'BOD';\n    let index = 0;\n    let token = tokens[index];\n    while (!isType(token, EOD)) {\n        let paramsCount = 0;\n        const params = [];\n        if (mode === 'BOD') {\n            if (token.text === 'M' || token.text === 'm') {\n                index++;\n                paramsCount = PARAMS[token.text];\n                mode = token.text;\n            }\n            else {\n                return parsePath('M0,0' + d);\n            }\n        }\n        else if (isType(token, NUMBER)) {\n            paramsCount = PARAMS[mode];\n        }\n        else {\n            index++;\n            paramsCount = PARAMS[token.text];\n            mode = token.text;\n        }\n        if ((index + paramsCount) < tokens.length) {\n            for (let i = index; i < index + paramsCount; i++) {\n                const numbeToken = tokens[i];\n                if (isType(numbeToken, NUMBER)) {\n                    params[params.length] = +numbeToken.text;\n                }\n                else {\n                    throw new Error('Param not a number: ' + mode + ',' + numbeToken.text);\n                }\n            }\n            if (typeof PARAMS[mode] === 'number') {\n                const segment = { key: mode, data: params };\n                segments.push(segment);\n                index += paramsCount;\n                token = tokens[index];\n                if (mode === 'M')\n                    mode = 'L';\n                if (mode === 'm')\n                    mode = 'l';\n            }\n            else {\n                throw new Error('Bad segment: ' + mode);\n            }\n        }\n        else {\n            throw new Error('Path data ended short');\n        }\n    }\n    return segments;\n}\nfunction serialize(segments) {\n    const tokens = [];\n    for (const { key, data } of segments) {\n        tokens.push(key);\n        switch (key) {\n            case 'C':\n            case 'c':\n                tokens.push(data[0], `${data[1]},`, data[2], `${data[3]},`, data[4], data[5]);\n                break;\n            case 'S':\n            case 's':\n            case 'Q':\n            case 'q':\n                tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n                break;\n            default:\n                tokens.push(...data);\n                break;\n        }\n    }\n    return tokens.join(' ');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9wYXJzZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QixzQkFBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx5QkFBeUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRLGdCQUFnQixRQUFRO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wYXRoLWRhdGEtcGFyc2VyL2xpYi9wYXJzZXIuanM/OTg3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBDT01NQU5EID0gMDtcbmNvbnN0IE5VTUJFUiA9IDE7XG5jb25zdCBFT0QgPSAyO1xuY29uc3QgUEFSQU1TID0geyBBOiA3LCBhOiA3LCBDOiA2LCBjOiA2LCBIOiAxLCBoOiAxLCBMOiAyLCBsOiAyLCBNOiAyLCBtOiAyLCBROiA0LCBxOiA0LCBTOiA0LCBzOiA0LCBUOiAyLCB0OiAyLCBWOiAxLCB2OiAxLCBaOiAwLCB6OiAwIH07XG5mdW5jdGlvbiB0b2tlbml6ZShkKSB7XG4gICAgY29uc3QgdG9rZW5zID0gbmV3IEFycmF5KCk7XG4gICAgd2hpbGUgKGQgIT09ICcnKSB7XG4gICAgICAgIGlmIChkLm1hdGNoKC9eKFsgXFx0XFxyXFxuLF0rKS8pKSB7XG4gICAgICAgICAgICBkID0gZC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZC5tYXRjaCgvXihbYUFjQ2hIbExtTXFRc1N0VHZWelpdKS8pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5zLmxlbmd0aF0gPSB7IHR5cGU6IENPTU1BTkQsIHRleHQ6IFJlZ0V4cC4kMSB9O1xuICAgICAgICAgICAgZCA9IGQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGQubWF0Y2goL14oKFstK10/WzAtOV0rKFxcLlswLTldKik/fFstK10/XFwuWzAtOV0rKShbZUVdWy0rXT9bMC05XSspPykvKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0geyB0eXBlOiBOVU1CRVIsIHRleHQ6IGAke3BhcnNlRmxvYXQoUmVnRXhwLiQxKX1gIH07XG4gICAgICAgICAgICBkID0gZC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9rZW5zW3Rva2Vucy5sZW5ndGhdID0geyB0eXBlOiBFT0QsIHRleHQ6ICcnIH07XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIGlzVHlwZSh0b2tlbiwgdHlwZSkge1xuICAgIHJldHVybiB0b2tlbi50eXBlID09PSB0eXBlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGF0aChkKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBbXTtcbiAgICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShkKTtcbiAgICBsZXQgbW9kZSA9ICdCT0QnO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IHRva2VuID0gdG9rZW5zW2luZGV4XTtcbiAgICB3aGlsZSAoIWlzVHlwZSh0b2tlbiwgRU9EKSkge1xuICAgICAgICBsZXQgcGFyYW1zQ291bnQgPSAwO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBbXTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdCT0QnKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udGV4dCA9PT0gJ00nIHx8IHRva2VuLnRleHQgPT09ICdtJykge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgcGFyYW1zQ291bnQgPSBQQVJBTVNbdG9rZW4udGV4dF07XG4gICAgICAgICAgICAgICAgbW9kZSA9IHRva2VuLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VQYXRoKCdNMCwwJyArIGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVHlwZSh0b2tlbiwgTlVNQkVSKSkge1xuICAgICAgICAgICAgcGFyYW1zQ291bnQgPSBQQVJBTVNbbW9kZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgcGFyYW1zQ291bnQgPSBQQVJBTVNbdG9rZW4udGV4dF07XG4gICAgICAgICAgICBtb2RlID0gdG9rZW4udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGluZGV4ICsgcGFyYW1zQ291bnQpIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgaW5kZXggKyBwYXJhbXNDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtYmVUb2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUeXBlKG51bWJlVG9rZW4sIE5VTUJFUikpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3BhcmFtcy5sZW5ndGhdID0gK251bWJlVG9rZW4udGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyYW0gbm90IGEgbnVtYmVyOiAnICsgbW9kZSArICcsJyArIG51bWJlVG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBQQVJBTVNbbW9kZV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHsga2V5OiBtb2RlLCBkYXRhOiBwYXJhbXMgfTtcbiAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IHBhcmFtc0NvdW50O1xuICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gJ00nKVxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gJ0wnO1xuICAgICAgICAgICAgICAgIGlmIChtb2RlID09PSAnbScpXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSAnbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBzZWdtZW50OiAnICsgbW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhdGggZGF0YSBlbmRlZCBzaG9ydCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdtZW50cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemUoc2VnbWVudHMpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkYXRhIH0gb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goa2V5KTtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goZGF0YVswXSwgYCR7ZGF0YVsxXX0sYCwgZGF0YVsyXSwgYCR7ZGF0YVszXX0sYCwgZGF0YVs0XSwgZGF0YVs1XSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdTJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChkYXRhWzBdLCBgJHtkYXRhWzFdfSxgLCBkYXRhWzJdLCBkYXRhWzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucy5qb2luKCcgJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/path-data-parser/lib/parser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/points-on-curve/lib/curve-to-bezier.js":
/*!*************************************************************!*\
  !*** ./node_modules/points-on-curve/lib/curve-to-bezier.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curveToBezier: function() { return /* binding */ curveToBezier; }\n/* harmony export */ });\nfunction clone(p) {\n    return [...p];\n}\nfunction curveToBezier(pointsIn, curveTightness = 0) {\n    const len = pointsIn.length;\n    if (len < 3) {\n        throw new Error('A curve must have at least three points.');\n    }\n    const out = [];\n    if (len === 3) {\n        out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));\n    }\n    else {\n        const points = [];\n        points.push(pointsIn[0], pointsIn[0]);\n        for (let i = 1; i < pointsIn.length; i++) {\n            points.push(pointsIn[i]);\n            if (i === (pointsIn.length - 1)) {\n                points.push(pointsIn[i]);\n            }\n        }\n        const b = [];\n        const s = 1 - curveTightness;\n        out.push(clone(points[0]));\n        for (let i = 1; (i + 2) < points.length; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            out.push(b[1], b[2], b[3]);\n        }\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb2ludHMtb24tY3VydmUvbGliL2N1cnZlLXRvLWJlemllci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLWN1cnZlL2xpYi9jdXJ2ZS10by1iZXppZXIuanM/ZDgwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbG9uZShwKSB7XG4gICAgcmV0dXJuIFsuLi5wXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdXJ2ZVRvQmV6aWVyKHBvaW50c0luLCBjdXJ2ZVRpZ2h0bmVzcyA9IDApIHtcbiAgICBjb25zdCBsZW4gPSBwb2ludHNJbi5sZW5ndGg7XG4gICAgaWYgKGxlbiA8IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGN1cnZlIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSBwb2ludHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGlmIChsZW4gPT09IDMpIHtcbiAgICAgICAgb3V0LnB1c2goY2xvbmUocG9pbnRzSW5bMF0pLCBjbG9uZShwb2ludHNJblsxXSksIGNsb25lKHBvaW50c0luWzJdKSwgY2xvbmUocG9pbnRzSW5bMl0pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBwb2ludHMucHVzaChwb2ludHNJblswXSwgcG9pbnRzSW5bMF0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50c0luLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNJbltpXSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gKHBvaW50c0luLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnRzSW5baV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGIgPSBbXTtcbiAgICAgICAgY29uc3QgcyA9IDEgLSBjdXJ2ZVRpZ2h0bmVzcztcbiAgICAgICAgb3V0LnB1c2goY2xvbmUocG9pbnRzWzBdKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyAoaSArIDIpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRWZXJ0QXJyYXkgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBiWzBdID0gW2NhY2hlZFZlcnRBcnJheVswXSwgY2FjaGVkVmVydEFycmF5WzFdXTtcbiAgICAgICAgICAgIGJbMV0gPSBbY2FjaGVkVmVydEFycmF5WzBdICsgKHMgKiBwb2ludHNbaSArIDFdWzBdIC0gcyAqIHBvaW50c1tpIC0gMV1bMF0pIC8gNiwgY2FjaGVkVmVydEFycmF5WzFdICsgKHMgKiBwb2ludHNbaSArIDFdWzFdIC0gcyAqIHBvaW50c1tpIC0gMV1bMV0pIC8gNl07XG4gICAgICAgICAgICBiWzJdID0gW3BvaW50c1tpICsgMV1bMF0gKyAocyAqIHBvaW50c1tpXVswXSAtIHMgKiBwb2ludHNbaSArIDJdWzBdKSAvIDYsIHBvaW50c1tpICsgMV1bMV0gKyAocyAqIHBvaW50c1tpXVsxXSAtIHMgKiBwb2ludHNbaSArIDJdWzFdKSAvIDZdO1xuICAgICAgICAgICAgYlszXSA9IFtwb2ludHNbaSArIDFdWzBdLCBwb2ludHNbaSArIDFdWzFdXTtcbiAgICAgICAgICAgIG91dC5wdXNoKGJbMV0sIGJbMl0sIGJbM10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/points-on-curve/lib/curve-to-bezier.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/points-on-curve/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/points-on-curve/lib/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointsOnBezierCurves: function() { return /* binding */ pointsOnBezierCurves; },\n/* harmony export */   simplify: function() { return /* binding */ simplify; }\n/* harmony export */ });\n// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nfunction simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// RamerDouglasPeucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nfunction pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb2ludHMtb24tY3VydmUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLWN1cnZlL2xpYi9pbmRleC5qcz9kYTM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGRpc3RhbmNlKHAxLCBwMikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoZGlzdGFuY2VTcShwMSwgcDIpKTtcbn1cbi8vIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHMgc3F1YXJlZFxuZnVuY3Rpb24gZGlzdGFuY2VTcShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgKyBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKTtcbn1cbi8vIFNpc3RhbmNlIHNxdWFyZWQgZnJvbSBhIHBvaW50IHAgdG8gdGhlIGxpbmUgc2VnbWVudCB2d1xuZnVuY3Rpb24gZGlzdGFuY2VUb1NlZ21lbnRTcShwLCB2LCB3KSB7XG4gICAgY29uc3QgbDIgPSBkaXN0YW5jZVNxKHYsIHcpO1xuICAgIGlmIChsMiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2VTcShwLCB2KTtcbiAgICB9XG4gICAgbGV0IHQgPSAoKHBbMF0gLSB2WzBdKSAqICh3WzBdIC0gdlswXSkgKyAocFsxXSAtIHZbMV0pICogKHdbMV0gLSB2WzFdKSkgLyBsMjtcbiAgICB0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpO1xuICAgIHJldHVybiBkaXN0YW5jZVNxKHAsIGxlcnAodiwgdywgdCkpO1xufVxuZnVuY3Rpb24gbGVycChhLCBiLCB0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYVswXSArIChiWzBdIC0gYVswXSkgKiB0LFxuICAgICAgICBhWzFdICsgKGJbMV0gLSBhWzFdKSAqIHQsXG4gICAgXTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3NlYW50MjMud29yZHByZXNzLmNvbS8yMDEwLzExLzEyL29mZnNldC1iZXppZXItY3VydmVzL1xuZnVuY3Rpb24gZmxhdG5lc3MocG9pbnRzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBwMSA9IHBvaW50c1tvZmZzZXQgKyAwXTtcbiAgICBjb25zdCBwMiA9IHBvaW50c1tvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBwMyA9IHBvaW50c1tvZmZzZXQgKyAyXTtcbiAgICBjb25zdCBwNCA9IHBvaW50c1tvZmZzZXQgKyAzXTtcbiAgICBsZXQgdXggPSAzICogcDJbMF0gLSAyICogcDFbMF0gLSBwNFswXTtcbiAgICB1eCAqPSB1eDtcbiAgICBsZXQgdXkgPSAzICogcDJbMV0gLSAyICogcDFbMV0gLSBwNFsxXTtcbiAgICB1eSAqPSB1eTtcbiAgICBsZXQgdnggPSAzICogcDNbMF0gLSAyICogcDRbMF0gLSBwMVswXTtcbiAgICB2eCAqPSB2eDtcbiAgICBsZXQgdnkgPSAzICogcDNbMV0gLSAyICogcDRbMV0gLSBwMVsxXTtcbiAgICB2eSAqPSB2eTtcbiAgICBpZiAodXggPCB2eCkge1xuICAgICAgICB1eCA9IHZ4O1xuICAgIH1cbiAgICBpZiAodXkgPCB2eSkge1xuICAgICAgICB1eSA9IHZ5O1xuICAgIH1cbiAgICByZXR1cm4gdXggKyB1eTtcbn1cbmZ1bmN0aW9uIGdldFBvaW50c09uQmV6aWVyQ3VydmVXaXRoU3BsaXR0aW5nKHBvaW50cywgb2Zmc2V0LCB0b2xlcmFuY2UsIG5ld1BvaW50cykge1xuICAgIGNvbnN0IG91dFBvaW50cyA9IG5ld1BvaW50cyB8fCBbXTtcbiAgICBpZiAoZmxhdG5lc3MocG9pbnRzLCBvZmZzZXQpIDwgdG9sZXJhbmNlKSB7XG4gICAgICAgIGNvbnN0IHAwID0gcG9pbnRzW29mZnNldCArIDBdO1xuICAgICAgICBpZiAob3V0UG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlKG91dFBvaW50c1tvdXRQb2ludHMubGVuZ3RoIC0gMV0sIHAwKTtcbiAgICAgICAgICAgIGlmIChkID4gMSkge1xuICAgICAgICAgICAgICAgIG91dFBvaW50cy5wdXNoKHAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dFBvaW50cy5wdXNoKHAwKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRQb2ludHMucHVzaChwb2ludHNbb2Zmc2V0ICsgM10pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc3ViZGl2aWRlXG4gICAgICAgIGNvbnN0IHQgPSAuNTtcbiAgICAgICAgY29uc3QgcDEgPSBwb2ludHNbb2Zmc2V0ICsgMF07XG4gICAgICAgIGNvbnN0IHAyID0gcG9pbnRzW29mZnNldCArIDFdO1xuICAgICAgICBjb25zdCBwMyA9IHBvaW50c1tvZmZzZXQgKyAyXTtcbiAgICAgICAgY29uc3QgcDQgPSBwb2ludHNbb2Zmc2V0ICsgM107XG4gICAgICAgIGNvbnN0IHExID0gbGVycChwMSwgcDIsIHQpO1xuICAgICAgICBjb25zdCBxMiA9IGxlcnAocDIsIHAzLCB0KTtcbiAgICAgICAgY29uc3QgcTMgPSBsZXJwKHAzLCBwNCwgdCk7XG4gICAgICAgIGNvbnN0IHIxID0gbGVycChxMSwgcTIsIHQpO1xuICAgICAgICBjb25zdCByMiA9IGxlcnAocTIsIHEzLCB0KTtcbiAgICAgICAgY29uc3QgcmVkID0gbGVycChyMSwgcjIsIHQpO1xuICAgICAgICBnZXRQb2ludHNPbkJlemllckN1cnZlV2l0aFNwbGl0dGluZyhbcDEsIHExLCByMSwgcmVkXSwgMCwgdG9sZXJhbmNlLCBvdXRQb2ludHMpO1xuICAgICAgICBnZXRQb2ludHNPbkJlemllckN1cnZlV2l0aFNwbGl0dGluZyhbcmVkLCByMiwgcTMsIHA0XSwgMCwgdG9sZXJhbmNlLCBvdXRQb2ludHMpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0UG9pbnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5KHBvaW50cywgZGlzdGFuY2UpIHtcbiAgICByZXR1cm4gc2ltcGxpZnlQb2ludHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBkaXN0YW5jZSk7XG59XG4vLyBSYW1lcuKAk0RvdWdsYXPigJNQZXVja2VyIGFsZ29yaXRobVxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUmFtZXIlRTIlODAlOTNEb3VnbGFzJUUyJTgwJTkzUGV1Y2tlcl9hbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgc3RhcnQsIGVuZCwgZXBzaWxvbiwgbmV3UG9pbnRzKSB7XG4gICAgY29uc3Qgb3V0UG9pbnRzID0gbmV3UG9pbnRzIHx8IFtdO1xuICAgIC8vIGZpbmQgdGhlIG1vc3QgZGlzdGFuY2UgcG9pbnQgZnJvbSB0aGUgZW5kcG9pbnRzXG4gICAgY29uc3QgcyA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgZSA9IHBvaW50c1tlbmQgLSAxXTtcbiAgICBsZXQgbWF4RGlzdFNxID0gMDtcbiAgICBsZXQgbWF4TmR4ID0gMTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQgKyAxOyBpIDwgZW5kIC0gMTsgKytpKSB7XG4gICAgICAgIGNvbnN0IGRpc3RTcSA9IGRpc3RhbmNlVG9TZWdtZW50U3EocG9pbnRzW2ldLCBzLCBlKTtcbiAgICAgICAgaWYgKGRpc3RTcSA+IG1heERpc3RTcSkge1xuICAgICAgICAgICAgbWF4RGlzdFNxID0gZGlzdFNxO1xuICAgICAgICAgICAgbWF4TmR4ID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB0aGF0IHBvaW50IGlzIHRvbyBmYXIsIHNwbGl0XG4gICAgaWYgKE1hdGguc3FydChtYXhEaXN0U3EpID4gZXBzaWxvbikge1xuICAgICAgICBzaW1wbGlmeVBvaW50cyhwb2ludHMsIHN0YXJ0LCBtYXhOZHggKyAxLCBlcHNpbG9uLCBvdXRQb2ludHMpO1xuICAgICAgICBzaW1wbGlmeVBvaW50cyhwb2ludHMsIG1heE5keCwgZW5kLCBlcHNpbG9uLCBvdXRQb2ludHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFvdXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRQb2ludHMucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICBvdXRQb2ludHMucHVzaChlKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dFBvaW50cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNPbkJlemllckN1cnZlcyhwb2ludHMsIHRvbGVyYW5jZSA9IDAuMTUsIGRpc3RhbmNlKSB7XG4gICAgY29uc3QgbmV3UG9pbnRzID0gW107XG4gICAgY29uc3QgbnVtU2VnbWVudHMgPSAocG9pbnRzLmxlbmd0aCAtIDEpIC8gMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDM7XG4gICAgICAgIGdldFBvaW50c09uQmV6aWVyQ3VydmVXaXRoU3BsaXR0aW5nKHBvaW50cywgb2Zmc2V0LCB0b2xlcmFuY2UsIG5ld1BvaW50cyk7XG4gICAgfVxuICAgIGlmIChkaXN0YW5jZSAmJiBkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsaWZ5UG9pbnRzKG5ld1BvaW50cywgMCwgbmV3UG9pbnRzLmxlbmd0aCwgZGlzdGFuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/points-on-curve/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/points-on-path/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/points-on-path/lib/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointsOnPath: function() { return /* binding */ pointsOnPath; }\n/* harmony export */ });\n/* harmony import */ var points_on_curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! points-on-curve */ \"(app-pages-browser)/./node_modules/points-on-curve/lib/index.js\");\n/* harmony import */ var path_data_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path-data-parser */ \"(app-pages-browser)/./node_modules/path-data-parser/lib/index.js\");\n\n\nfunction pointsOnPath(path, tolerance, distance) {\n    const segments = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_1__.parsePath)(path);\n    const normalized = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_1__.normalize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_1__.absolutize)(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_0__.pointsOnBezierCurves)(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = (0,points_on_curve__WEBPACK_IMPORTED_MODULE_0__.simplify)(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wb2ludHMtb24tcGF0aC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWlFO0FBQ0c7QUFDN0Q7QUFDUCxxQkFBcUIsMkRBQVM7QUFDOUIsdUJBQXVCLDJEQUFTLENBQUMsNERBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFFQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlEQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLXBhdGgvbGliL2luZGV4LmpzPzI5MjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9pbnRzT25CZXppZXJDdXJ2ZXMsIHNpbXBsaWZ5IH0gZnJvbSAncG9pbnRzLW9uLWN1cnZlJztcbmltcG9ydCB7IHBhcnNlUGF0aCwgYWJzb2x1dGl6ZSwgbm9ybWFsaXplIH0gZnJvbSAncGF0aC1kYXRhLXBhcnNlcic7XG5leHBvcnQgZnVuY3Rpb24gcG9pbnRzT25QYXRoKHBhdGgsIHRvbGVyYW5jZSwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBjb25zdCBub3JtYWxpemVkID0gbm9ybWFsaXplKGFic29sdXRpemUoc2VnbWVudHMpKTtcbiAgICBjb25zdCBzZXRzID0gW107XG4gICAgbGV0IGN1cnJlbnRQb2ludHMgPSBbXTtcbiAgICBsZXQgc3RhcnQgPSBbMCwgMF07XG4gICAgbGV0IHBlbmRpbmdDdXJ2ZSA9IFtdO1xuICAgIGNvbnN0IGFwcGVuZFBlbmRpbmdDdXJ2ZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBlbmRpbmdDdXJ2ZS5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKC4uLnBvaW50c09uQmV6aWVyQ3VydmVzKHBlbmRpbmdDdXJ2ZSwgdG9sZXJhbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ0N1cnZlID0gW107XG4gICAgfTtcbiAgICBjb25zdCBhcHBlbmRQZW5kaW5nUG9pbnRzID0gKCkgPT4ge1xuICAgICAgICBhcHBlbmRQZW5kaW5nQ3VydmUoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZXRzLnB1c2goY3VycmVudFBvaW50cyk7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgeyBrZXksIGRhdGEgfSBvZiBub3JtYWxpemVkKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICBhcHBlbmRQZW5kaW5nUG9pbnRzKCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBbZGF0YVswXSwgZGF0YVsxXV07XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIGFwcGVuZFBlbmRpbmdDdXJ2ZSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChbZGF0YVswXSwgZGF0YVsxXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nQ3VydmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQb2ludCA9IGN1cnJlbnRQb2ludHMubGVuZ3RoID8gY3VycmVudFBvaW50c1tjdXJyZW50UG9pbnRzLmxlbmd0aCAtIDFdIDogc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdDdXJ2ZS5wdXNoKFtsYXN0UG9pbnRbMF0sIGxhc3RQb2ludFsxXV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwZW5kaW5nQ3VydmUucHVzaChbZGF0YVswXSwgZGF0YVsxXV0pO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdDdXJ2ZS5wdXNoKFtkYXRhWzJdLCBkYXRhWzNdXSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0N1cnZlLnB1c2goW2RhdGFbNF0sIGRhdGFbNV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIGFwcGVuZFBlbmRpbmdDdXJ2ZSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMucHVzaChbc3RhcnRbMF0sIHN0YXJ0WzFdXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kUGVuZGluZ1BvaW50cygpO1xuICAgIGlmICghZGlzdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIHNldHM7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2V0IG9mIHNldHMpIHtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZFNldCA9IHNpbXBsaWZ5KHNldCwgZGlzdGFuY2UpO1xuICAgICAgICBpZiAoc2ltcGxpZmllZFNldC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHNpbXBsaWZpZWRTZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/points-on-path/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/canvas.js":
/*!********************************************!*\
  !*** ./node_modules/roughjs/bin/canvas.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughCanvas: function() { return /* binding */ RoughCanvas; }\n/* harmony export */ });\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generator */ \"(app-pages-browser)/./node_modules/roughjs/bin/generator.js\");\n\nclass RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new _generator__WEBPACK_IMPORTED_MODULE_0__.RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing, precision);\n                    ctx.restore();\n                    break;\n                case 'fillPath': {\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon' || drawable.shape === 'path') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, precision, fillRule);\n                    ctx.restore();\n                    break;\n                }\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, fixedDecimals, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9jYW52YXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkM7QUFDdEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0RBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2NhbnZhcy5qcz8yNDZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJvdWdoR2VuZXJhdG9yIH0gZnJvbSAnLi9nZW5lcmF0b3InO1xuZXhwb3J0IGNsYXNzIFJvdWdoQ2FudmFzIHtcbiAgICBjb25zdHJ1Y3RvcihjYW52YXMsIGNvbmZpZykge1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmdlbiA9IG5ldyBSb3VnaEdlbmVyYXRvcihjb25maWcpO1xuICAgIH1cbiAgICBkcmF3KGRyYXdhYmxlKSB7XG4gICAgICAgIGNvbnN0IHNldHMgPSBkcmF3YWJsZS5zZXRzIHx8IFtdO1xuICAgICAgICBjb25zdCBvID0gZHJhd2FibGUub3B0aW9ucyB8fCB0aGlzLmdldERlZmF1bHRPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBkcmF3YWJsZS5vcHRpb25zLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzO1xuICAgICAgICBmb3IgKGNvbnN0IGRyYXdpbmcgb2Ygc2V0cykge1xuICAgICAgICAgICAgc3dpdGNoIChkcmF3aW5nLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gby5zdHJva2UgPT09ICdub25lJyA/ICd0cmFuc3BhcmVudCcgOiBvLnN0cm9rZTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG8uc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnN0cm9rZUxpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goby5zdHJva2VMaW5lRGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3Ryb2tlTGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG8uc3Ryb2tlTGluZURhc2hPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHJhd1RvQ29udGV4dChjdHgsIGRyYXdpbmcsIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxQYXRoJzoge1xuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gby5maWxsIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxsUnVsZSA9IChkcmF3YWJsZS5zaGFwZSA9PT0gJ2N1cnZlJyB8fCBkcmF3YWJsZS5zaGFwZSA9PT0gJ3BvbHlnb24nIHx8IGRyYXdhYmxlLnNoYXBlID09PSAncGF0aCcpID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3VG9Db250ZXh0KGN0eCwgZHJhd2luZywgcHJlY2lzaW9uLCBmaWxsUnVsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsU2tldGNoJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxsU2tldGNoKGN0eCwgZHJhd2luZywgbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpbGxTa2V0Y2goY3R4LCBkcmF3aW5nLCBvKSB7XG4gICAgICAgIGxldCBmd2VpZ2h0ID0gby5maWxsV2VpZ2h0O1xuICAgICAgICBpZiAoZndlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGZ3ZWlnaHQgPSBvLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAoby5maWxsTGluZURhc2gpIHtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChvLmZpbGxMaW5lRGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uZmlsbExpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvLmZpbGxMaW5lRGFzaE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvLmZpbGwgfHwgJyc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBmd2VpZ2h0O1xuICAgICAgICB0aGlzLl9kcmF3VG9Db250ZXh0KGN0eCwgZHJhd2luZywgby5maXhlZERlY2ltYWxQbGFjZURpZ2l0cyk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIF9kcmF3VG9Db250ZXh0KGN0eCwgZHJhd2luZywgZml4ZWREZWNpbWFscywgcnVsZSA9ICdub256ZXJvJykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkcmF3aW5nLm9wcykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIGZpeGVkRGVjaW1hbHMgPT09ICdudW1iZXInKSAmJiBmaXhlZERlY2ltYWxzID49IDApID8gKGl0ZW0uZGF0YS5tYXAoKGQpID0+ICtkLnRvRml4ZWQoZml4ZWREZWNpbWFscykpKSA6IGl0ZW0uZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgICAgICBjdHgubW92ZVRvKGRhdGFbMF0sIGRhdGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdiY3VydmVUbyc6XG4gICAgICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGRhdGFbMF0sIGRhdGFbMV0sIGRhdGFbMl0sIGRhdGFbM10sIGRhdGFbNF0sIGRhdGFbNV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsaW5lVG8nOlxuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKGRhdGFbMF0sIGRhdGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZHJhd2luZy50eXBlID09PSAnZmlsbFBhdGgnKSB7XG4gICAgICAgICAgICBjdHguZmlsbChydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW47XG4gICAgfVxuICAgIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW4uZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuICAgIGxpbmUoeDEsIHkxLCB4MiwgeTIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmxpbmUoeDEsIHkxLCB4MiwgeTIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICByZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ucmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBlbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGNpcmNsZSh4LCB5LCBkaWFtZXRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgbGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmxpbmVhclBhdGgocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgcG9seWdvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLnBvbHlnb24ocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgYXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBjbG9zZWQgPSBmYWxzZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uYXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBjbG9zZWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBjdXJ2ZShwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmN1cnZlKHBvaW50cywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIHBhdGgoZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkcmF3aW5nID0gdGhpcy5nZW4ucGF0aChkLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGRyYXdpbmcpO1xuICAgICAgICByZXR1cm4gZHJhd2luZztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/canvas.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/core.js":
/*!******************************************!*\
  !*** ./node_modules/roughjs/bin/core.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGNS: function() { return /* binding */ SVGNS; }\n/* harmony export */ });\nconst SVGNS = 'http://www.w3.org/2000/svg';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9jb3JlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY29yZS5qcz82ODhmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBTVkdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/core.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/dashed-filler.js":
/*!***********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/dashed-filler.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DashedFiller: function() { return /* binding */ DashedFiller; }\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(app-pages-browser)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2Rhc2hlZC1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBQ2lCO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUVBQW1CO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kYXNoZWQtZmlsbGVyLmpzPzMzMzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmV4cG9ydCBjbGFzcyBEYXNoZWRGaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlbHBlcikge1xuICAgICAgICB0aGlzLmhlbHBlciA9IGhlbHBlcjtcbiAgICB9XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdmaWxsU2tldGNoJywgb3BzOiB0aGlzLmRhc2hlZExpbmUobGluZXMsIG8pIH07XG4gICAgfVxuICAgIGRhc2hlZExpbmUobGluZXMsIG8pIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gby5kYXNoT2Zmc2V0IDwgMCA/IChvLmhhY2h1cmVHYXAgPCAwID8gKG8uc3Ryb2tlV2lkdGggKiA0KSA6IG8uaGFjaHVyZUdhcCkgOiBvLmRhc2hPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGdhcCA9IG8uZGFzaEdhcCA8IDAgPyAoby5oYWNodXJlR2FwIDwgMCA/IChvLnN0cm9rZVdpZHRoICogNCkgOiBvLmhhY2h1cmVHYXApIDogby5kYXNoR2FwO1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5mbG9vcihsZW5ndGggLyAob2Zmc2V0ICsgZ2FwKSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IChsZW5ndGggKyBnYXAgLSAoY291bnQgKiAob2Zmc2V0ICsgZ2FwKSkpIC8gMjtcbiAgICAgICAgICAgIGxldCBwMSA9IGxpbmVbMF07XG4gICAgICAgICAgICBsZXQgcDIgPSBsaW5lWzFdO1xuICAgICAgICAgICAgaWYgKHAxWzBdID4gcDJbMF0pIHtcbiAgICAgICAgICAgICAgICBwMSA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgcDIgPSBsaW5lWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxwaGEgPSBNYXRoLmF0YW4oKHAyWzFdIC0gcDFbMV0pIC8gKHAyWzBdIC0gcDFbMF0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxzdGFydCA9IGkgKiAob2Zmc2V0ICsgZ2FwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5kID0gbHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gW3AxWzBdICsgKGxzdGFydCAqIE1hdGguY29zKGFscGhhKSkgKyAoc3RhcnRPZmZzZXQgKiBNYXRoLmNvcyhhbHBoYSkpLCBwMVsxXSArIGxzdGFydCAqIE1hdGguc2luKGFscGhhKSArIChzdGFydE9mZnNldCAqIE1hdGguc2luKGFscGhhKSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IFtwMVswXSArIChsZW5kICogTWF0aC5jb3MoYWxwaGEpKSArIChzdGFydE9mZnNldCAqIE1hdGguY29zKGFscGhhKSksIHAxWzFdICsgKGxlbmQgKiBNYXRoLnNpbihhbHBoYSkpICsgKHN0YXJ0T2Zmc2V0ICogTWF0aC5zaW4oYWxwaGEpKV07XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhzdGFydFswXSwgc3RhcnRbMV0sIGVuZFswXSwgZW5kWzFdLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3BzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/dashed-filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/dot-filler.js":
/*!********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/dot-filler.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DotFiller: function() { return /* binding */ DotFiller; }\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(app-pages-browser)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2RvdC1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBQ2lCO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxpQkFBaUI7QUFDcEQsc0JBQXNCLHVFQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvZG90LWZpbGxlci5qcz9kN2I5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpbmVMZW5ndGggfSBmcm9tICcuLi9nZW9tZXRyeSc7XG5pbXBvcnQgeyBwb2x5Z29uSGFjaHVyZUxpbmVzIH0gZnJvbSAnLi9zY2FuLWxpbmUtaGFjaHVyZSc7XG5leHBvcnQgY2xhc3MgRG90RmlsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihoZWxwZXIpIHtcbiAgICAgICAgdGhpcy5oZWxwZXIgPSBoZWxwZXI7XG4gICAgfVxuICAgIGZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgICAgICBvID0gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBoYWNodXJlQW5nbGU6IDAgfSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvdHNPbkxpbmVzKGxpbmVzLCBvKTtcbiAgICB9XG4gICAgZG90c09uTGluZXMobGluZXMsIG8pIHtcbiAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgIGxldCBnYXAgPSBvLmhhY2h1cmVHYXA7XG4gICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICBnYXAgPSBvLnN0cm9rZVdpZHRoICogNDtcbiAgICAgICAgfVxuICAgICAgICBnYXAgPSBNYXRoLm1heChnYXAsIDAuMSk7XG4gICAgICAgIGxldCBmd2VpZ2h0ID0gby5maWxsV2VpZ2h0O1xuICAgICAgICBpZiAoZndlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGZ3ZWlnaHQgPSBvLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBybyA9IGdhcCAvIDQ7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGRsID0gbGVuZ3RoIC8gZ2FwO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLmNlaWwoZGwpIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGxlbmd0aCAtIChjb3VudCAqIGdhcCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gKChsaW5lWzBdWzBdICsgbGluZVsxXVswXSkgLyAyKSAtIChnYXAgLyA0KTtcbiAgICAgICAgICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbihsaW5lWzBdWzFdLCBsaW5lWzFdWzFdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBtaW5ZICsgb2Zmc2V0ICsgKGkgKiBnYXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN4ID0gKHggLSBybykgKyBNYXRoLnJhbmRvbSgpICogMiAqIHJvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN5ID0gKHkgLSBybykgKyBNYXRoLnJhbmRvbSgpICogMiAqIHJvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gdGhpcy5oZWxwZXIuZWxsaXBzZShjeCwgY3ksIGZ3ZWlnaHQsIGZ3ZWlnaHQsIG8pO1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKC4uLmVsLm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxTa2V0Y2gnLCBvcHMgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/dot-filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/filler.js":
/*!****************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/filler.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFiller: function() { return /* binding */ getFiller; }\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n/* harmony import */ var _zigzag_filler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zigzag-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/zigzag-filler.js\");\n/* harmony import */ var _hatch_filler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hatch-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/hatch-filler.js\");\n/* harmony import */ var _dot_filler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dot-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/dot-filler.js\");\n/* harmony import */ var _dashed_filler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dashed-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/dashed-filler.js\");\n/* harmony import */ var _zigzag_line_filler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zigzag-line-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js\");\n\n\n\n\n\n\nconst fillers = {};\nfunction getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _zigzag_filler__WEBPACK_IMPORTED_MODULE_1__.ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _hatch_filler__WEBPACK_IMPORTED_MODULE_2__.HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _dot_filler__WEBPACK_IMPORTED_MODULE_3__.DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _dashed_filler__WEBPACK_IMPORTED_MODULE_4__.DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _zigzag_line_filler__WEBPACK_IMPORTED_MODULE_5__.ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2ZpbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlEO0FBQ0Y7QUFDRjtBQUNKO0FBQ007QUFDUztBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3REFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxzREFBVztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrREFBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3REFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpRUFBZ0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDBEQUFhO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9maWxsZXIuanM/OGQ0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYWNodXJlRmlsbGVyIH0gZnJvbSAnLi9oYWNodXJlLWZpbGxlcic7XG5pbXBvcnQgeyBaaWdaYWdGaWxsZXIgfSBmcm9tICcuL3ppZ3phZy1maWxsZXInO1xuaW1wb3J0IHsgSGF0Y2hGaWxsZXIgfSBmcm9tICcuL2hhdGNoLWZpbGxlcic7XG5pbXBvcnQgeyBEb3RGaWxsZXIgfSBmcm9tICcuL2RvdC1maWxsZXInO1xuaW1wb3J0IHsgRGFzaGVkRmlsbGVyIH0gZnJvbSAnLi9kYXNoZWQtZmlsbGVyJztcbmltcG9ydCB7IFppZ1phZ0xpbmVGaWxsZXIgfSBmcm9tICcuL3ppZ3phZy1saW5lLWZpbGxlcic7XG5jb25zdCBmaWxsZXJzID0ge307XG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsbGVyKG8sIGhlbHBlcikge1xuICAgIGxldCBmaWxsZXJOYW1lID0gby5maWxsU3R5bGUgfHwgJ2hhY2h1cmUnO1xuICAgIGlmICghZmlsbGVyc1tmaWxsZXJOYW1lXSkge1xuICAgICAgICBzd2l0Y2ggKGZpbGxlck5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3ppZ3phZyc6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgWmlnWmFnRmlsbGVyKGhlbHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY3Jvc3MtaGF0Y2gnOlxuICAgICAgICAgICAgICAgIGlmICghZmlsbGVyc1tmaWxsZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsZXJzW2ZpbGxlck5hbWVdID0gbmV3IEhhdGNoRmlsbGVyKGhlbHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG90cyc6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgRG90RmlsbGVyKGhlbHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGFzaGVkJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBEYXNoZWRGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd6aWd6YWctbGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgWmlnWmFnTGluZUZpbGxlcihoZWxwZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hhY2h1cmUnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBmaWxsZXJOYW1lID0gJ2hhY2h1cmUnO1xuICAgICAgICAgICAgICAgIGlmICghZmlsbGVyc1tmaWxsZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsZXJzW2ZpbGxlck5hbWVdID0gbmV3IEhhY2h1cmVGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbGxlcnNbZmlsbGVyTmFtZV07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/hachure-filler.js":
/*!************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/hachure-filler.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HachureFiller: function() { return /* binding */ HachureFiller; }\n/* harmony export */ });\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scan-line-hachure */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\nclass HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_0__.polygonHachureLines)(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2hhY2h1cmUtZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBEO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdUVBQW1CO0FBQ3pDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9oYWNodXJlLWZpbGxlci5qcz85YjQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmV4cG9ydCBjbGFzcyBIYWNodXJlRmlsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihoZWxwZXIpIHtcbiAgICAgICAgdGhpcy5oZWxwZXIgPSBoZWxwZXI7XG4gICAgfVxuICAgIGZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKTtcbiAgICB9XG4gICAgX2ZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHBvbHlnb25IYWNodXJlTGluZXMocG9seWdvbkxpc3QsIG8pO1xuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLnJlbmRlckxpbmVzKGxpbmVzLCBvKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxTa2V0Y2gnLCBvcHMgfTtcbiAgICB9XG4gICAgcmVuZGVyTGluZXMobGluZXMsIG8pIHtcbiAgICAgICAgY29uc3Qgb3BzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgICAgb3BzLnB1c2goLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhsaW5lWzBdWzBdLCBsaW5lWzBdWzFdLCBsaW5lWzFdWzBdLCBsaW5lWzFdWzFdLCBvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wcztcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/hachure-filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/hatch-filler.js":
/*!**********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/hatch-filler.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HatchFiller: function() { return /* binding */ HatchFiller; }\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n\nclass HatchFiller extends _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2hhdGNoLWZpbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDtBQUMxQywwQkFBMEIsMERBQWE7QUFDOUM7QUFDQTtBQUNBLG1DQUFtQyxPQUFPLG1DQUFtQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2hhdGNoLWZpbGxlci5qcz9mNGZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhY2h1cmVGaWxsZXIgfSBmcm9tICcuL2hhY2h1cmUtZmlsbGVyJztcbmV4cG9ydCBjbGFzcyBIYXRjaEZpbGxlciBleHRlbmRzIEhhY2h1cmVGaWxsZXIge1xuICAgIGZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgICAgICBjb25zdCBzZXQgPSB0aGlzLl9maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pO1xuICAgICAgICBjb25zdCBvMiA9IE9iamVjdC5hc3NpZ24oe30sIG8sIHsgaGFjaHVyZUFuZ2xlOiBvLmhhY2h1cmVBbmdsZSArIDkwIH0pO1xuICAgICAgICBjb25zdCBzZXQyID0gdGhpcy5fZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvMik7XG4gICAgICAgIHNldC5vcHMgPSBzZXQub3BzLmNvbmNhdChzZXQyLm9wcyk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/hatch-filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js":
/*!***************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/scan-line-hachure.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polygonHachureLines: function() { return /* binding */ polygonHachureLines; }\n/* harmony export */ });\n/* harmony import */ var hachure_fill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hachure-fill */ \"(app-pages-browser)/./node_modules/hachure-fill/bin/hachure.js\");\n\nfunction polygonHachureLines(polygonList, o) {\n    var _a;\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.round(Math.max(gap, 0.1));\n    let skipOffset = 1;\n    if (o.roughness >= 1) {\n        if ((((_a = o.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {\n            skipOffset = gap;\n        }\n    }\n    return (0,hachure_fill__WEBPACK_IMPORTED_MODULE_0__.hachureLines)(polygonList, gap, angle, skipOffset || 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL3NjYW4tbGluZS1oYWNodXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQ3JDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBEQUFZO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL3NjYW4tbGluZS1oYWNodXJlLmpzPzM2MjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFjaHVyZUxpbmVzIH0gZnJvbSAnaGFjaHVyZS1maWxsJztcbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFuZ2xlID0gby5oYWNodXJlQW5nbGUgKyA5MDtcbiAgICBsZXQgZ2FwID0gby5oYWNodXJlR2FwO1xuICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgIGdhcCA9IG8uc3Ryb2tlV2lkdGggKiA0O1xuICAgIH1cbiAgICBnYXAgPSBNYXRoLnJvdW5kKE1hdGgubWF4KGdhcCwgMC4xKSk7XG4gICAgbGV0IHNraXBPZmZzZXQgPSAxO1xuICAgIGlmIChvLnJvdWdobmVzcyA+PSAxKSB7XG4gICAgICAgIGlmICgoKChfYSA9IG8ucmFuZG9taXplcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHQoKSkgfHwgTWF0aC5yYW5kb20oKSkgPiAwLjcpIHtcbiAgICAgICAgICAgIHNraXBPZmZzZXQgPSBnYXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgZ2FwLCBhbmdsZSwgc2tpcE9mZnNldCB8fCAxKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/zigzag-filler.js":
/*!***********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/zigzag-filler.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZigZagFiller: function() { return /* binding */ ZigZagFiller; }\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"(app-pages-browser)/./node_modules/roughjs/bin/geometry.js\");\n\n\n\nclass ZigZagFiller extends _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if ((0,_geometry__WEBPACK_IMPORTED_MODULE_2__.lineLength)([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL3ppZ3phZy1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpRDtBQUNTO0FBQ2pCO0FBQ2xDLDJCQUEyQiwwREFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTyxpQkFBaUI7QUFDM0Qsc0JBQXNCLHVFQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvemlnemFnLWZpbGxlci5qcz9kZTBhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhY2h1cmVGaWxsZXIgfSBmcm9tICcuL2hhY2h1cmUtZmlsbGVyJztcbmltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmltcG9ydCB7IGxpbmVMZW5ndGggfSBmcm9tICcuLi9nZW9tZXRyeSc7XG5leHBvcnQgY2xhc3MgWmlnWmFnRmlsbGVyIGV4dGVuZHMgSGFjaHVyZUZpbGxlciB7XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIGxldCBnYXAgPSBvLmhhY2h1cmVHYXA7XG4gICAgICAgIGlmIChnYXAgPCAwKSB7XG4gICAgICAgICAgICBnYXAgPSBvLnN0cm9rZVdpZHRoICogNDtcbiAgICAgICAgfVxuICAgICAgICBnYXAgPSBNYXRoLm1heChnYXAsIDAuMSk7XG4gICAgICAgIGNvbnN0IG8yID0gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBoYWNodXJlR2FwOiBnYXAgfSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbzIpO1xuICAgICAgICBjb25zdCB6aWdaYWdBbmdsZSA9IChNYXRoLlBJIC8gMTgwKSAqIG8uaGFjaHVyZUFuZ2xlO1xuICAgICAgICBjb25zdCB6aWd6YWdMaW5lcyA9IFtdO1xuICAgICAgICBjb25zdCBkZ3ggPSBnYXAgKiAwLjUgKiBNYXRoLmNvcyh6aWdaYWdBbmdsZSk7XG4gICAgICAgIGNvbnN0IGRneSA9IGdhcCAqIDAuNSAqIE1hdGguc2luKHppZ1phZ0FuZ2xlKTtcbiAgICAgICAgZm9yIChjb25zdCBbcDEsIHAyXSBvZiBsaW5lcykge1xuICAgICAgICAgICAgaWYgKGxpbmVMZW5ndGgoW3AxLCBwMl0pKSB7XG4gICAgICAgICAgICAgICAgemlnemFnTGluZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIFtwMVswXSAtIGRneCwgcDFbMV0gKyBkZ3ldLFxuICAgICAgICAgICAgICAgICAgICBbLi4ucDJdLFxuICAgICAgICAgICAgICAgIF0sIFtcbiAgICAgICAgICAgICAgICAgICAgW3AxWzBdICsgZGd4LCBwMVsxXSAtIGRneV0sXG4gICAgICAgICAgICAgICAgICAgIFsuLi5wMl0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5yZW5kZXJMaW5lcyh6aWd6YWdMaW5lcywgbyk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdmaWxsU2tldGNoJywgb3BzIH07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/zigzag-filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js":
/*!****************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/zigzag-line-filler.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZigZagLineFiller: function() { return /* binding */ ZigZagLineFiller; }\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(app-pages-browser)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL3ppZ3phZy1saW5lLWZpbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUM7QUFDaUI7QUFDbkQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTyxzQkFBc0I7QUFDekQsc0JBQXNCLHVFQUFtQjtBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIscURBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL3ppZ3phZy1saW5lLWZpbGxlci5qcz85YTE4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpbmVMZW5ndGggfSBmcm9tICcuLi9nZW9tZXRyeSc7XG5pbXBvcnQgeyBwb2x5Z29uSGFjaHVyZUxpbmVzIH0gZnJvbSAnLi9zY2FuLWxpbmUtaGFjaHVyZSc7XG5leHBvcnQgY2xhc3MgWmlnWmFnTGluZUZpbGxlciB7XG4gICAgY29uc3RydWN0b3IoaGVscGVyKSB7XG4gICAgICAgIHRoaXMuaGVscGVyID0gaGVscGVyO1xuICAgIH1cbiAgICBmaWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pIHtcbiAgICAgICAgY29uc3QgZ2FwID0gby5oYWNodXJlR2FwIDwgMCA/IChvLnN0cm9rZVdpZHRoICogNCkgOiBvLmhhY2h1cmVHYXA7XG4gICAgICAgIGNvbnN0IHpvID0gby56aWd6YWdPZmZzZXQgPCAwID8gZ2FwIDogby56aWd6YWdPZmZzZXQ7XG4gICAgICAgIG8gPSBPYmplY3QuYXNzaWduKHt9LCBvLCB7IGhhY2h1cmVHYXA6IGdhcCArIHpvIH0pO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHBvbHlnb25IYWNodXJlTGluZXMocG9seWdvbkxpc3QsIG8pO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnZmlsbFNrZXRjaCcsIG9wczogdGhpcy56aWd6YWdMaW5lcyhsaW5lcywgem8sIG8pIH07XG4gICAgfVxuICAgIHppZ3phZ0xpbmVzKGxpbmVzLCB6bywgbykge1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5yb3VuZChsZW5ndGggLyAoMiAqIHpvKSk7XG4gICAgICAgICAgICBsZXQgcDEgPSBsaW5lWzBdO1xuICAgICAgICAgICAgbGV0IHAyID0gbGluZVsxXTtcbiAgICAgICAgICAgIGlmIChwMVswXSA+IHAyWzBdKSB7XG4gICAgICAgICAgICAgICAgcDEgPSBsaW5lWzFdO1xuICAgICAgICAgICAgICAgIHAyID0gbGluZVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFscGhhID0gTWF0aC5hdGFuKChwMlsxXSAtIHAxWzFdKSAvIChwMlswXSAtIHAxWzBdKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsc3RhcnQgPSBpICogMiAqIHpvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmQgPSAoaSArIDEpICogMiAqIHpvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGR6ID0gTWF0aC5zcXJ0KDIgKiBNYXRoLnBvdyh6bywgMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gW3AxWzBdICsgKGxzdGFydCAqIE1hdGguY29zKGFscGhhKSksIHAxWzFdICsgbHN0YXJ0ICogTWF0aC5zaW4oYWxwaGEpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBbcDFbMF0gKyAobGVuZCAqIE1hdGguY29zKGFscGhhKSksIHAxWzFdICsgKGxlbmQgKiBNYXRoLnNpbihhbHBoYSkpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWRkbGUgPSBbc3RhcnRbMF0gKyBkeiAqIE1hdGguY29zKGFscGhhICsgTWF0aC5QSSAvIDQpLCBzdGFydFsxXSArIGR6ICogTWF0aC5zaW4oYWxwaGEgKyBNYXRoLlBJIC8gNCldO1xuICAgICAgICAgICAgICAgIG9wcy5wdXNoKC4uLnRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMoc3RhcnRbMF0sIHN0YXJ0WzFdLCBtaWRkbGVbMF0sIG1pZGRsZVsxXSwgbyksIC4uLnRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMobWlkZGxlWzBdLCBtaWRkbGVbMV0sIGVuZFswXSwgZW5kWzFdLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3BzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/generator.js":
/*!***********************************************!*\
  !*** ./node_modules/roughjs/bin/generator.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughGenerator: function() { return /* binding */ RoughGenerator; }\n/* harmony export */ });\n/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer.js */ \"(app-pages-browser)/./node_modules/roughjs/bin/renderer.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"(app-pages-browser)/./node_modules/roughjs/bin/math.js\");\n/* harmony import */ var points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! points-on-curve/lib/curve-to-bezier.js */ \"(app-pages-browser)/./node_modules/points-on-curve/lib/curve-to-bezier.js\");\n/* harmony import */ var points_on_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! points-on-curve */ \"(app-pages-browser)/./node_modules/points-on-curve/lib/index.js\");\n/* harmony import */ var points_on_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! points-on-path */ \"(app-pages-browser)/./node_modules/points-on-path/lib/index.js\");\n\n\n\n\n\nconst NOS = 'none';\nclass RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.randomSeed)();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [(0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.line)(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.rectangle)(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)([points], o));\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.generateEllipseParams)(width, height, o);\n        const ellipseResponse = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.ellipseWithParams)(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.ellipseWithParams)(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [(0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.arc)(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.arc)(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillArc)(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.curve)(points, o);\n        if (o.fill && o.fill !== NOS) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.curve)(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const polyPoints = [];\n                const inputPoints = points;\n                if (inputPoints.length) {\n                    const p1 = inputPoints[0];\n                    const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n                    for (const points of pointsList) {\n                        if (points.length < 3) {\n                            polyPoints.push(...points);\n                        }\n                        else if (points.length === 3) {\n                            polyPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_3__.pointsOnBezierCurves)((0,points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__.curveToBezier)([\n                                points[0],\n                                points[0],\n                                points[1],\n                                points[2],\n                            ]), 10, (1 + o.roughness) / 2));\n                        }\n                        else {\n                            polyPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_3__.pointsOnBezierCurves)((0,points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__.curveToBezier)(points), 10, (1 + o.roughness) / 2));\n                        }\n                    }\n                }\n                if (polyPoints.length) {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([polyPoints], o));\n                }\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)([points], o));\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = (0,points_on_path__WEBPACK_IMPORTED_MODULE_4__.pointsOnPath)(d, 1, distance);\n        const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.svgPath)(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.svgPath)(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)(sets, o));\n                }\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9nZW5lcmF0b3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtMO0FBQzNJO0FBQ2dDO0FBQ2hCO0FBQ1Q7QUFDOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFVO0FBQ3pCO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0RBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhEQUFnQjtBQUMzQztBQUNBO0FBQ0EsMkJBQTJCLGlFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtRUFBcUI7QUFDbkQsZ0NBQWdDLCtEQUFpQjtBQUNqRDtBQUNBO0FBQ0EsOEJBQThCLCtEQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpRUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx3REFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpREFBRztBQUMzQjtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0EsOEJBQThCLGlEQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1EQUFLO0FBQzdCO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQUssdUNBQXVDLFFBQVEsaUdBQWlHO0FBQ3ZMO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUVBQW9CLENBQUMscUZBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUVBQW9CLENBQUMscUZBQWE7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUVBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVU7QUFDbEM7QUFDQTtBQUNBLDJCQUEyQiw4REFBZ0I7QUFDM0M7QUFDQTtBQUNBLDJCQUEyQixpRUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFZO0FBQ2pDLHNCQUFzQixxREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscURBQU8sa0NBQWtDLFFBQVEsaUdBQWlHO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsK0JBQStCLDhEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0RBQVU7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxTQUFTO0FBQ3BEO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxFQUFFLFFBQVEsSUFBSSxTQUFTLEVBQUUsUUFBUSxJQUFJLFNBQVMsRUFBRSxTQUFTO0FBQ2xHO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxFQUFFLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9nZW5lcmF0b3IuanM/OWU1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaW5lLCBzb2xpZEZpbGxQb2x5Z29uLCBwYXR0ZXJuRmlsbFBvbHlnb25zLCByZWN0YW5nbGUsIGVsbGlwc2VXaXRoUGFyYW1zLCBnZW5lcmF0ZUVsbGlwc2VQYXJhbXMsIGxpbmVhclBhdGgsIGFyYywgcGF0dGVybkZpbGxBcmMsIGN1cnZlLCBzdmdQYXRoIH0gZnJvbSAnLi9yZW5kZXJlci5qcyc7XG5pbXBvcnQgeyByYW5kb21TZWVkIH0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7IGN1cnZlVG9CZXppZXIgfSBmcm9tICdwb2ludHMtb24tY3VydmUvbGliL2N1cnZlLXRvLWJlemllci5qcyc7XG5pbXBvcnQgeyBwb2ludHNPbkJlemllckN1cnZlcyB9IGZyb20gJ3BvaW50cy1vbi1jdXJ2ZSc7XG5pbXBvcnQgeyBwb2ludHNPblBhdGggfSBmcm9tICdwb2ludHMtb24tcGF0aCc7XG5jb25zdCBOT1MgPSAnbm9uZSc7XG5leHBvcnQgY2xhc3MgUm91Z2hHZW5lcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgbWF4UmFuZG9tbmVzc09mZnNldDogMixcbiAgICAgICAgICAgIHJvdWdobmVzczogMSxcbiAgICAgICAgICAgIGJvd2luZzogMSxcbiAgICAgICAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgICAgICBjdXJ2ZVRpZ2h0bmVzczogMCxcbiAgICAgICAgICAgIGN1cnZlRml0dGluZzogMC45NSxcbiAgICAgICAgICAgIGN1cnZlU3RlcENvdW50OiA5LFxuICAgICAgICAgICAgZmlsbFN0eWxlOiAnaGFjaHVyZScsXG4gICAgICAgICAgICBmaWxsV2VpZ2h0OiAtMSxcbiAgICAgICAgICAgIGhhY2h1cmVBbmdsZTogLTQxLFxuICAgICAgICAgICAgaGFjaHVyZUdhcDogLTEsXG4gICAgICAgICAgICBkYXNoT2Zmc2V0OiAtMSxcbiAgICAgICAgICAgIGRhc2hHYXA6IC0xLFxuICAgICAgICAgICAgemlnemFnT2Zmc2V0OiAtMSxcbiAgICAgICAgICAgIHNlZWQ6IDAsXG4gICAgICAgICAgICBkaXNhYmxlTXVsdGlTdHJva2U6IGZhbHNlLFxuICAgICAgICAgICAgZGlzYWJsZU11bHRpU3Ryb2tlRmlsbDogZmFsc2UsXG4gICAgICAgICAgICBwcmVzZXJ2ZVZlcnRpY2VzOiBmYWxzZSxcbiAgICAgICAgICAgIGZpbGxTaGFwZVJvdWdobmVzc0dhaW46IDAuOCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5vcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gdGhpcy5fbyh0aGlzLmNvbmZpZy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgbmV3U2VlZCgpIHtcbiAgICAgICAgcmV0dXJuIHJhbmRvbVNlZWQoKTtcbiAgICB9XG4gICAgX28ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpIDogdGhpcy5kZWZhdWx0T3B0aW9ucztcbiAgICB9XG4gICAgX2Qoc2hhcGUsIHNldHMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHsgc2hhcGUsIHNldHM6IHNldHMgfHwgW10sIG9wdGlvbnM6IG9wdGlvbnMgfHwgdGhpcy5kZWZhdWx0T3B0aW9ucyB9O1xuICAgIH1cbiAgICBsaW5lKHgxLCB5MSwgeDIsIHkyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZCgnbGluZScsIFtsaW5lKHgxLCB5MSwgeDIsIHkyLCBvKV0sIG8pO1xuICAgIH1cbiAgICByZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fbyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvKTtcbiAgICAgICAgaWYgKG8uZmlsbCkge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gW1t4LCB5XSwgW3ggKyB3aWR0aCwgeV0sIFt4ICsgd2lkdGgsIHkgKyBoZWlnaHRdLCBbeCwgeSArIGhlaWdodF1dO1xuICAgICAgICAgICAgaWYgKG8uZmlsbFN0eWxlID09PSAnc29saWQnKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzb2xpZEZpbGxQb2x5Z29uKFtwb2ludHNdLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdHRlcm5GaWxsUG9seWdvbnMoW3BvaW50c10sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5zdHJva2UgIT09IE5PUykge1xuICAgICAgICAgICAgcGF0aHMucHVzaChvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgncmVjdGFuZ2xlJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBlbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGNvbnN0IGVsbGlwc2VQYXJhbXMgPSBnZW5lcmF0ZUVsbGlwc2VQYXJhbXMod2lkdGgsIGhlaWdodCwgbyk7XG4gICAgICAgIGNvbnN0IGVsbGlwc2VSZXNwb25zZSA9IGVsbGlwc2VXaXRoUGFyYW1zKHgsIHksIG8sIGVsbGlwc2VQYXJhbXMpO1xuICAgICAgICBpZiAoby5maWxsKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZSA9IGVsbGlwc2VXaXRoUGFyYW1zKHgsIHksIG8sIGVsbGlwc2VQYXJhbXMpLm9wc2V0O1xuICAgICAgICAgICAgICAgIHNoYXBlLnR5cGUgPSAnZmlsbFBhdGgnO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXR0ZXJuRmlsbFBvbHlnb25zKFtlbGxpcHNlUmVzcG9uc2UuZXN0aW1hdGVkUG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvLnN0cm9rZSAhPT0gTk9TKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKGVsbGlwc2VSZXNwb25zZS5vcHNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ2VsbGlwc2UnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIGNpcmNsZSh4LCB5LCBkaWFtZXRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXQgPSB0aGlzLmVsbGlwc2UoeCwgeSwgZGlhbWV0ZXIsIGRpYW1ldGVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0LnNoYXBlID0gJ2NpcmNsZSc7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGxpbmVhclBhdGgocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZCgnbGluZWFyUGF0aCcsIFtsaW5lYXJQYXRoKHBvaW50cywgZmFsc2UsIG8pXSwgbyk7XG4gICAgfVxuICAgIGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgY2xvc2VkID0gZmFsc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCwgdHJ1ZSwgbyk7XG4gICAgICAgIGlmIChjbG9zZWQgJiYgby5maWxsKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG8pO1xuICAgICAgICAgICAgICAgIGZpbGxPcHRpb25zLmRpc2FibGVNdWx0aVN0cm9rZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIHRydWUsIGZhbHNlLCBmaWxsT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgc2hhcGUudHlwZSA9ICdmaWxsUGF0aCc7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdHRlcm5GaWxsQXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uc3Ryb2tlICE9PSBOT1MpIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gob3V0bGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ2FyYycsIHBhdGhzLCBvKTtcbiAgICB9XG4gICAgY3VydmUocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gY3VydmUocG9pbnRzLCBvKTtcbiAgICAgICAgaWYgKG8uZmlsbCAmJiBvLmZpbGwgIT09IE5PUykge1xuICAgICAgICAgICAgaWYgKG8uZmlsbFN0eWxlID09PSAnc29saWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsbFNoYXBlID0gY3VydmUocG9pbnRzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG8pLCB7IGRpc2FibGVNdWx0aVN0cm9rZTogdHJ1ZSwgcm91Z2huZXNzOiBvLnJvdWdobmVzcyA/IChvLnJvdWdobmVzcyArIG8uZmlsbFNoYXBlUm91Z2huZXNzR2FpbikgOiAwIH0pKTtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGxQYXRoJyxcbiAgICAgICAgICAgICAgICAgICAgb3BzOiB0aGlzLl9tZXJnZWRTaGFwZShmaWxsU2hhcGUub3BzKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvbHlQb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gaW5wdXRQb2ludHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50c0xpc3QgPSAodHlwZW9mIHAxWzBdID09PSAnbnVtYmVyJykgPyBbaW5wdXRQb2ludHNdIDogaW5wdXRQb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnRzIG9mIHBvaW50c0xpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlQb2ludHMucHVzaCguLi5wb2ludHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlQb2ludHMucHVzaCguLi5wb2ludHNPbkJlemllckN1cnZlcyhjdXJ2ZVRvQmV6aWVyKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pLCAxMCwgKDEgKyBvLnJvdWdobmVzcykgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2x5UG9pbnRzLnB1c2goLi4ucG9pbnRzT25CZXppZXJDdXJ2ZXMoY3VydmVUb0Jlemllcihwb2ludHMpLCAxMCwgKDEgKyBvLnJvdWdobmVzcykgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvbHlQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhbcG9seVBvaW50c10sIG8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uc3Ryb2tlICE9PSBOT1MpIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2gob3V0bGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ2N1cnZlJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBwb2x5Z29uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fbyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IGxpbmVhclBhdGgocG9pbnRzLCB0cnVlLCBvKTtcbiAgICAgICAgaWYgKG8uZmlsbCkge1xuICAgICAgICAgICAgaWYgKG8uZmlsbFN0eWxlID09PSAnc29saWQnKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzb2xpZEZpbGxQb2x5Z29uKFtwb2ludHNdLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdHRlcm5GaWxsUG9seWdvbnMoW3BvaW50c10sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5zdHJva2UgIT09IE5PUykge1xuICAgICAgICAgICAgcGF0aHMucHVzaChvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgncG9seWdvbicsIHBhdGhzLCBvKTtcbiAgICB9XG4gICAgcGF0aChkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kKCdwYXRoJywgcGF0aHMsIG8pO1xuICAgICAgICB9XG4gICAgICAgIGQgPSAoZCB8fCAnJykucmVwbGFjZSgvXFxuL2csICcgJykucmVwbGFjZSgvKC1cXHMpL2csICctJykucmVwbGFjZSgnLyhcXHNcXHMpL2cnLCAnICcpO1xuICAgICAgICBjb25zdCBoYXNGaWxsID0gby5maWxsICYmIG8uZmlsbCAhPT0gJ3RyYW5zcGFyZW50JyAmJiBvLmZpbGwgIT09IE5PUztcbiAgICAgICAgY29uc3QgaGFzU3Ryb2tlID0gby5zdHJva2UgIT09IE5PUztcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZCA9ICEhKG8uc2ltcGxpZmljYXRpb24gJiYgKG8uc2ltcGxpZmljYXRpb24gPCAxKSk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gc2ltcGxpZmllZCA/ICg0IC0gNCAqIChvLnNpbXBsaWZpY2F0aW9uIHx8IDEpKSA6ICgoMSArIG8ucm91Z2huZXNzKSAvIDIpO1xuICAgICAgICBjb25zdCBzZXRzID0gcG9pbnRzT25QYXRoKGQsIDEsIGRpc3RhbmNlKTtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBzdmdQYXRoKGQsIG8pO1xuICAgICAgICBpZiAoaGFzRmlsbCkge1xuICAgICAgICAgICAgaWYgKG8uZmlsbFN0eWxlID09PSAnc29saWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxTaGFwZSA9IHN2Z1BhdGgoZCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvKSwgeyBkaXNhYmxlTXVsdGlTdHJva2U6IHRydWUsIHJvdWdobmVzczogby5yb3VnaG5lc3MgPyAoby5yb3VnaG5lc3MgKyBvLmZpbGxTaGFwZVJvdWdobmVzc0dhaW4pIDogMCB9KSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGxQYXRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogdGhpcy5fbWVyZ2VkU2hhcGUoZmlsbFNoYXBlLm9wcyksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChzb2xpZEZpbGxQb2x5Z29uKHNldHMsIG8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdHRlcm5GaWxsUG9seWdvbnMoc2V0cywgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNTdHJva2UpIHtcbiAgICAgICAgICAgIGlmIChzaW1wbGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgc2V0cy5mb3JFYWNoKChzZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChsaW5lYXJQYXRoKHNldCwgZmFsc2UsIG8pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdwYXRoJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBvcHNUb1BhdGgoZHJhd2luZywgZml4ZWREZWNpbWFscykge1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZHJhd2luZy5vcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoKHR5cGVvZiBmaXhlZERlY2ltYWxzID09PSAnbnVtYmVyJykgJiYgZml4ZWREZWNpbWFscyA+PSAwKSA/IChpdGVtLmRhdGEubWFwKChkKSA9PiArZC50b0ZpeGVkKGZpeGVkRGVjaW1hbHMpKSkgOiBpdGVtLmRhdGE7XG4gICAgICAgICAgICBzd2l0Y2ggKGl0ZW0ub3ApIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb3ZlJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBgTSR7ZGF0YVswXX0gJHtkYXRhWzFdfSBgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdiY3VydmVUbyc6XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gYEMke2RhdGFbMF19ICR7ZGF0YVsxXX0sICR7ZGF0YVsyXX0gJHtkYXRhWzNdfSwgJHtkYXRhWzRdfSAke2RhdGFbNV19IGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmVUbyc6XG4gICAgICAgICAgICAgICAgICAgIHBhdGggKz0gYEwke2RhdGFbMF19ICR7ZGF0YVsxXX0gYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGgudHJpbSgpO1xuICAgIH1cbiAgICB0b1BhdGhzKGRyYXdhYmxlKSB7XG4gICAgICAgIGNvbnN0IHNldHMgPSBkcmF3YWJsZS5zZXRzIHx8IFtdO1xuICAgICAgICBjb25zdCBvID0gZHJhd2FibGUub3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGRyYXdpbmcgb2Ygc2V0cykge1xuICAgICAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChkcmF3aW5nLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ6IHRoaXMub3BzVG9QYXRoKGRyYXdpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBvLnN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBvLnN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogTk9TLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsUGF0aCc6XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkOiB0aGlzLm9wc1RvUGF0aChkcmF3aW5nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogTk9TLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBvLmZpbGwgfHwgTk9TLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsU2tldGNoJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMuZmlsbFNrZXRjaChkcmF3aW5nLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGhzO1xuICAgIH1cbiAgICBmaWxsU2tldGNoKGRyYXdpbmcsIG8pIHtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkOiB0aGlzLm9wc1RvUGF0aChkcmF3aW5nKSxcbiAgICAgICAgICAgIHN0cm9rZTogby5maWxsIHx8IE5PUyxcbiAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBmd2VpZ2h0LFxuICAgICAgICAgICAgZmlsbDogTk9TLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfbWVyZ2VkU2hhcGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmZpbHRlcigoZCwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkLm9wID09PSAnbW92ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/generator.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/geometry.js":
/*!**********************************************!*\
  !*** ./node_modules/roughjs/bin/geometry.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lineLength: function() { return /* binding */ lineLength; }\n/* harmony export */ });\nfunction lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9nZW9tZXRyeS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZ2VvbWV0cnkuanM/MGI2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XG4gICAgY29uc3QgcDEgPSBsaW5lWzBdO1xuICAgIGNvbnN0IHAyID0gbGluZVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHAxWzBdIC0gcDJbMF0sIDIpICsgTWF0aC5wb3cocDFbMV0gLSBwMlsxXSwgMikpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/geometry.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/math.js":
/*!******************************************!*\
  !*** ./node_modules/roughjs/bin/math.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Random: function() { return /* binding */ Random; },\n/* harmony export */   randomSeed: function() { return /* binding */ randomSeed; }\n/* harmony export */ });\nfunction randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nclass Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9tYXRoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL21hdGguanM/NDY1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gcmFuZG9tU2VlZCgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMiAqKiAzMSk7XG59XG5leHBvcnQgY2xhc3MgUmFuZG9tIHtcbiAgICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAoKDIgKiogMzEgLSAxKSAmICh0aGlzLnNlZWQgPSBNYXRoLmltdWwoNDgyNzEsIHRoaXMuc2VlZCkpKSAvIDIgKiogMzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/math.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/renderer.js":
/*!**********************************************!*\
  !*** ./node_modules/roughjs/bin/renderer.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arc: function() { return /* binding */ arc; },\n/* harmony export */   curve: function() { return /* binding */ curve; },\n/* harmony export */   doubleLineFillOps: function() { return /* binding */ doubleLineFillOps; },\n/* harmony export */   ellipse: function() { return /* binding */ ellipse; },\n/* harmony export */   ellipseWithParams: function() { return /* binding */ ellipseWithParams; },\n/* harmony export */   generateEllipseParams: function() { return /* binding */ generateEllipseParams; },\n/* harmony export */   line: function() { return /* binding */ line; },\n/* harmony export */   linearPath: function() { return /* binding */ linearPath; },\n/* harmony export */   patternFillArc: function() { return /* binding */ patternFillArc; },\n/* harmony export */   patternFillPolygons: function() { return /* binding */ patternFillPolygons; },\n/* harmony export */   polygon: function() { return /* binding */ polygon; },\n/* harmony export */   randOffset: function() { return /* binding */ randOffset; },\n/* harmony export */   randOffsetWithRange: function() { return /* binding */ randOffsetWithRange; },\n/* harmony export */   rectangle: function() { return /* binding */ rectangle; },\n/* harmony export */   solidFillPolygon: function() { return /* binding */ solidFillPolygon; },\n/* harmony export */   svgPath: function() { return /* binding */ svgPath; }\n/* harmony export */ });\n/* harmony import */ var _fillers_filler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fillers/filler.js */ \"(app-pages-browser)/./node_modules/roughjs/bin/fillers/filler.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"(app-pages-browser)/./node_modules/roughjs/bin/math.js\");\n/* harmony import */ var path_data_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-data-parser */ \"(app-pages-browser)/./node_modules/path-data-parser/lib/index.js\");\n\n\n\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nfunction line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nfunction linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nfunction polygon(points, o) {\n    return linearPath(points, true, o);\n}\nfunction rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nfunction curve(inputPoints, o) {\n    if (inputPoints.length) {\n        const p1 = inputPoints[0];\n        const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n        const o1 = _curveWithOffset(pointsList[0], 1 * (1 + o.roughness * 0.2), o);\n        const o2 = o.disableMultiStroke ? [] : _curveWithOffset(pointsList[0], 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        for (let i = 1; i < pointsList.length; i++) {\n            const points = pointsList[i];\n            if (points.length) {\n                const underlay = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n                const overlay = o.disableMultiStroke ? [] : _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n                for (const item of underlay) {\n                    if (item.op !== 'move') {\n                        o1.push(item);\n                    }\n                }\n                for (const item of overlay) {\n                    if (item.op !== 'move') {\n                        o2.push(item);\n                    }\n                }\n            }\n        }\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    return { type: 'path', ops: [] };\n}\nfunction ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nfunction generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nfunction ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nfunction arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nfunction svgPath(path, o) {\n    const segments = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.normalize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.absolutize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.parsePath)(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nfunction solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nfunction patternFillPolygons(polygonList, o) {\n    return (0,_fillers_filler_js__WEBPACK_IMPORTED_MODULE_0__.getFiller)(o, helper).fillPolygons(polygonList, o);\n}\nfunction patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nfunction randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nfunction randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nfunction doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new _math_js__WEBPACK_IMPORTED_MODULE_1__.Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    if (!points.length) {\n        return [];\n    }\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._line(points[0][0], points[0][1], points[1][0], points[1][1], o, true, true));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9yZW5kZXJlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ2I7QUFDaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEJBQThCLElBQUksMEVBQTBFO0FBQ25JO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTztBQUNQLHFCQUFxQiwyREFBUyxDQUFDLDREQUFVLENBQUMsMkRBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdHQUFnRztBQUMzSCxnQ0FBZ0MsU0FBUztBQUN6QywrQkFBK0Isa0dBQWtHO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxXQUFXLDZEQUFTO0FBQ3BCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNENBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZ0Q7QUFDbkUsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4RUFBOEU7QUFDckc7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRGQUE0RjtBQUNuSDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWdEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBLHVCQUF1Qiw4SUFBOEk7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vcmVuZGVyZXIuanM/ZDI1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRGaWxsZXIgfSBmcm9tICcuL2ZpbGxlcnMvZmlsbGVyLmpzJztcbmltcG9ydCB7IFJhbmRvbSB9IGZyb20gJy4vbWF0aC5qcyc7XG5pbXBvcnQgeyBwYXJzZVBhdGgsIG5vcm1hbGl6ZSwgYWJzb2x1dGl6ZSB9IGZyb20gJ3BhdGgtZGF0YS1wYXJzZXInO1xuY29uc3QgaGVscGVyID0ge1xuICAgIHJhbmRPZmZzZXQsXG4gICAgcmFuZE9mZnNldFdpdGhSYW5nZSxcbiAgICBlbGxpcHNlLFxuICAgIGRvdWJsZUxpbmVPcHM6IGRvdWJsZUxpbmVGaWxsT3BzLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBsaW5lKHgxLCB5MSwgeDIsIHkyLCBvKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogJ3BhdGgnLCBvcHM6IF9kb3VibGVMaW5lKHgxLCB5MSwgeDIsIHkyLCBvKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVhclBhdGgocG9pbnRzLCBjbG9zZSwgbykge1xuICAgIGNvbnN0IGxlbiA9IChwb2ludHMgfHwgW10pLmxlbmd0aDtcbiAgICBpZiAobGVuID4gMikge1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAobGVuIC0gMSk7IGkrKykge1xuICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUocG9pbnRzW2ldWzBdLCBwb2ludHNbaV1bMV0sIHBvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV0sIG8pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvc2UpIHtcbiAgICAgICAgICAgIG9wcy5wdXNoKC4uLl9kb3VibGVMaW5lKHBvaW50c1tsZW4gLSAxXVswXSwgcG9pbnRzW2xlbiAtIDFdWzFdLCBwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSwgbykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICByZXR1cm4gbGluZShwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzBdLCBwb2ludHNbMV1bMV0sIG8pO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAncGF0aCcsIG9wczogW10gfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2x5Z29uKHBvaW50cywgbykge1xuICAgIHJldHVybiBsaW5lYXJQYXRoKHBvaW50cywgdHJ1ZSwgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG8pIHtcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3ggKyB3aWR0aCwgeV0sXG4gICAgICAgIFt4ICsgd2lkdGgsIHkgKyBoZWlnaHRdLFxuICAgICAgICBbeCwgeSArIGhlaWdodF0sXG4gICAgXTtcbiAgICByZXR1cm4gcG9seWdvbihwb2ludHMsIG8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1cnZlKGlucHV0UG9pbnRzLCBvKSB7XG4gICAgaWYgKGlucHV0UG9pbnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwMSA9IGlucHV0UG9pbnRzWzBdO1xuICAgICAgICBjb25zdCBwb2ludHNMaXN0ID0gKHR5cGVvZiBwMVswXSA9PT0gJ251bWJlcicpID8gW2lucHV0UG9pbnRzXSA6IGlucHV0UG9pbnRzO1xuICAgICAgICBjb25zdCBvMSA9IF9jdXJ2ZVdpdGhPZmZzZXQocG9pbnRzTGlzdFswXSwgMSAqICgxICsgby5yb3VnaG5lc3MgKiAwLjIpLCBvKTtcbiAgICAgICAgY29uc3QgbzIgPSBvLmRpc2FibGVNdWx0aVN0cm9rZSA/IFtdIDogX2N1cnZlV2l0aE9mZnNldChwb2ludHNMaXN0WzBdLCAxLjUgKiAoMSArIG8ucm91Z2huZXNzICogMC4yMiksIGNsb25lT3B0aW9uc0FsdGVyU2VlZChvKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gcG9pbnRzTGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5kZXJsYXkgPSBfY3VydmVXaXRoT2Zmc2V0KHBvaW50cywgMSAqICgxICsgby5yb3VnaG5lc3MgKiAwLjIpLCBvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gby5kaXNhYmxlTXVsdGlTdHJva2UgPyBbXSA6IF9jdXJ2ZVdpdGhPZmZzZXQocG9pbnRzLCAxLjUgKiAoMSArIG8ucm91Z2huZXNzICogMC4yMiksIGNsb25lT3B0aW9uc0FsdGVyU2VlZChvKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHVuZGVybGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLm9wICE9PSAnbW92ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8xLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3AgIT09ICdtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbzIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAncGF0aCcsIG9wczogbzEuY29uY2F0KG8yKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAncGF0aCcsIG9wczogW10gfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG8pIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZW5lcmF0ZUVsbGlwc2VQYXJhbXMod2lkdGgsIGhlaWdodCwgbyk7XG4gICAgcmV0dXJuIGVsbGlwc2VXaXRoUGFyYW1zKHgsIHksIG8sIHBhcmFtcykub3BzZXQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVFbGxpcHNlUGFyYW1zKHdpZHRoLCBoZWlnaHQsIG8pIHtcbiAgICBjb25zdCBwc3EgPSBNYXRoLnNxcnQoTWF0aC5QSSAqIDIgKiBNYXRoLnNxcnQoKE1hdGgucG93KHdpZHRoIC8gMiwgMikgKyBNYXRoLnBvdyhoZWlnaHQgLyAyLCAyKSkgLyAyKSk7XG4gICAgY29uc3Qgc3RlcENvdW50ID0gTWF0aC5jZWlsKE1hdGgubWF4KG8uY3VydmVTdGVwQ291bnQsIChvLmN1cnZlU3RlcENvdW50IC8gTWF0aC5zcXJ0KDIwMCkpICogcHNxKSk7XG4gICAgY29uc3QgaW5jcmVtZW50ID0gKE1hdGguUEkgKiAyKSAvIHN0ZXBDb3VudDtcbiAgICBsZXQgcnggPSBNYXRoLmFicyh3aWR0aCAvIDIpO1xuICAgIGxldCByeSA9IE1hdGguYWJzKGhlaWdodCAvIDIpO1xuICAgIGNvbnN0IGN1cnZlRml0UmFuZG9tbmVzcyA9IDEgLSBvLmN1cnZlRml0dGluZztcbiAgICByeCArPSBfb2Zmc2V0T3B0KHJ4ICogY3VydmVGaXRSYW5kb21uZXNzLCBvKTtcbiAgICByeSArPSBfb2Zmc2V0T3B0KHJ5ICogY3VydmVGaXRSYW5kb21uZXNzLCBvKTtcbiAgICByZXR1cm4geyBpbmNyZW1lbnQsIHJ4LCByeSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2VXaXRoUGFyYW1zKHgsIHksIG8sIGVsbGlwc2VQYXJhbXMpIHtcbiAgICBjb25zdCBbYXAxLCBjcDFdID0gX2NvbXB1dGVFbGxpcHNlUG9pbnRzKGVsbGlwc2VQYXJhbXMuaW5jcmVtZW50LCB4LCB5LCBlbGxpcHNlUGFyYW1zLnJ4LCBlbGxpcHNlUGFyYW1zLnJ5LCAxLCBlbGxpcHNlUGFyYW1zLmluY3JlbWVudCAqIF9vZmZzZXQoMC4xLCBfb2Zmc2V0KDAuNCwgMSwgbyksIG8pLCBvKTtcbiAgICBsZXQgbzEgPSBfY3VydmUoYXAxLCBudWxsLCBvKTtcbiAgICBpZiAoKCFvLmRpc2FibGVNdWx0aVN0cm9rZSkgJiYgKG8ucm91Z2huZXNzICE9PSAwKSkge1xuICAgICAgICBjb25zdCBbYXAyXSA9IF9jb21wdXRlRWxsaXBzZVBvaW50cyhlbGxpcHNlUGFyYW1zLmluY3JlbWVudCwgeCwgeSwgZWxsaXBzZVBhcmFtcy5yeCwgZWxsaXBzZVBhcmFtcy5yeSwgMS41LCAwLCBvKTtcbiAgICAgICAgY29uc3QgbzIgPSBfY3VydmUoYXAyLCBudWxsLCBvKTtcbiAgICAgICAgbzEgPSBvMS5jb25jYXQobzIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlc3RpbWF0ZWRQb2ludHM6IGNwMSxcbiAgICAgICAgb3BzZXQ6IHsgdHlwZTogJ3BhdGgnLCBvcHM6IG8xIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCwgcm91Z2hDbG9zdXJlLCBvKSB7XG4gICAgY29uc3QgY3ggPSB4O1xuICAgIGNvbnN0IGN5ID0geTtcbiAgICBsZXQgcnggPSBNYXRoLmFicyh3aWR0aCAvIDIpO1xuICAgIGxldCByeSA9IE1hdGguYWJzKGhlaWdodCAvIDIpO1xuICAgIHJ4ICs9IF9vZmZzZXRPcHQocnggKiAwLjAxLCBvKTtcbiAgICByeSArPSBfb2Zmc2V0T3B0KHJ5ICogMC4wMSwgbyk7XG4gICAgbGV0IHN0cnQgPSBzdGFydDtcbiAgICBsZXQgc3RwID0gc3RvcDtcbiAgICB3aGlsZSAoc3RydCA8IDApIHtcbiAgICAgICAgc3RydCArPSBNYXRoLlBJICogMjtcbiAgICAgICAgc3RwICs9IE1hdGguUEkgKiAyO1xuICAgIH1cbiAgICBpZiAoKHN0cCAtIHN0cnQpID4gKE1hdGguUEkgKiAyKSkge1xuICAgICAgICBzdHJ0ID0gMDtcbiAgICAgICAgc3RwID0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGNvbnN0IGVsbGlwc2VJbmMgPSAoTWF0aC5QSSAqIDIpIC8gby5jdXJ2ZVN0ZXBDb3VudDtcbiAgICBjb25zdCBhcmNJbmMgPSBNYXRoLm1pbihlbGxpcHNlSW5jIC8gMiwgKHN0cCAtIHN0cnQpIC8gMik7XG4gICAgY29uc3Qgb3BzID0gX2FyYyhhcmNJbmMsIGN4LCBjeSwgcngsIHJ5LCBzdHJ0LCBzdHAsIDEsIG8pO1xuICAgIGlmICghby5kaXNhYmxlTXVsdGlTdHJva2UpIHtcbiAgICAgICAgY29uc3QgbzIgPSBfYXJjKGFyY0luYywgY3gsIGN5LCByeCwgcnksIHN0cnQsIHN0cCwgMS41LCBvKTtcbiAgICAgICAgb3BzLnB1c2goLi4ubzIpO1xuICAgIH1cbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgIGlmIChyb3VnaENsb3N1cmUpIHtcbiAgICAgICAgICAgIG9wcy5wdXNoKC4uLl9kb3VibGVMaW5lKGN4LCBjeSwgY3ggKyByeCAqIE1hdGguY29zKHN0cnQpLCBjeSArIHJ5ICogTWF0aC5zaW4oc3RydCksIG8pLCAuLi5fZG91YmxlTGluZShjeCwgY3ksIGN4ICsgcnggKiBNYXRoLmNvcyhzdHApLCBjeSArIHJ5ICogTWF0aC5zaW4oc3RwKSwgbykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3BzLnB1c2goeyBvcDogJ2xpbmVUbycsIGRhdGE6IFtjeCwgY3ldIH0sIHsgb3A6ICdsaW5lVG8nLCBkYXRhOiBbY3ggKyByeCAqIE1hdGguY29zKHN0cnQpLCBjeSArIHJ5ICogTWF0aC5zaW4oc3RydCldIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3ZnUGF0aChwYXRoLCBvKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBub3JtYWxpemUoYWJzb2x1dGl6ZShwYXJzZVBhdGgocGF0aCkpKTtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSBbMCwgMF07XG4gICAgbGV0IGN1cnJlbnQgPSBbMCwgMF07XG4gICAgZm9yIChjb25zdCB7IGtleSwgZGF0YSB9IG9mIHNlZ21lbnRzKSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdNJzoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBbZGF0YVswXSwgZGF0YVsxXV07XG4gICAgICAgICAgICAgICAgZmlyc3QgPSBbZGF0YVswXSwgZGF0YVsxXV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICBvcHMucHVzaCguLi5fZG91YmxlTGluZShjdXJyZW50WzBdLCBjdXJyZW50WzFdLCBkYXRhWzBdLCBkYXRhWzFdLCBvKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFtkYXRhWzBdLCBkYXRhWzFdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyLCB4LCB5XSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4uX2JlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBjdXJyZW50LCBvKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFt4LCB5XTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIG9wcy5wdXNoKC4uLl9kb3VibGVMaW5lKGN1cnJlbnRbMF0sIGN1cnJlbnRbMV0sIGZpcnN0WzBdLCBmaXJzdFsxXSwgbykpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBbZmlyc3RbMF0sIGZpcnN0WzFdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAncGF0aCcsIG9wcyB9O1xufVxuLy8gRmlsbHNcbmV4cG9ydCBmdW5jdGlvbiBzb2xpZEZpbGxQb2x5Z29uKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgZm9yIChjb25zdCBwb2ludHMgb2YgcG9seWdvbkxpc3QpIHtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG8ubWF4UmFuZG9tbmVzc09mZnNldCB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goeyBvcDogJ21vdmUnLCBkYXRhOiBbcG9pbnRzWzBdWzBdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLCBwb2ludHNbMF1bMV0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyldIH0pO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgb3BzLnB1c2goeyBvcDogJ2xpbmVUbycsIGRhdGE6IFtwb2ludHNbaV1bMF0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksIHBvaW50c1tpXVsxXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKV0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdmaWxsUGF0aCcsIG9wcyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm5GaWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pIHtcbiAgICByZXR1cm4gZ2V0RmlsbGVyKG8sIGhlbHBlcikuZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXR0ZXJuRmlsbEFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgbykge1xuICAgIGNvbnN0IGN4ID0geDtcbiAgICBjb25zdCBjeSA9IHk7XG4gICAgbGV0IHJ4ID0gTWF0aC5hYnMod2lkdGggLyAyKTtcbiAgICBsZXQgcnkgPSBNYXRoLmFicyhoZWlnaHQgLyAyKTtcbiAgICByeCArPSBfb2Zmc2V0T3B0KHJ4ICogMC4wMSwgbyk7XG4gICAgcnkgKz0gX29mZnNldE9wdChyeSAqIDAuMDEsIG8pO1xuICAgIGxldCBzdHJ0ID0gc3RhcnQ7XG4gICAgbGV0IHN0cCA9IHN0b3A7XG4gICAgd2hpbGUgKHN0cnQgPCAwKSB7XG4gICAgICAgIHN0cnQgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIHN0cCArPSBNYXRoLlBJICogMjtcbiAgICB9XG4gICAgaWYgKChzdHAgLSBzdHJ0KSA+IChNYXRoLlBJICogMikpIHtcbiAgICAgICAgc3RydCA9IDA7XG4gICAgICAgIHN0cCA9IE1hdGguUEkgKiAyO1xuICAgIH1cbiAgICBjb25zdCBpbmNyZW1lbnQgPSAoc3RwIC0gc3RydCkgLyBvLmN1cnZlU3RlcENvdW50O1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGZvciAobGV0IGFuZ2xlID0gc3RydDsgYW5nbGUgPD0gc3RwOyBhbmdsZSA9IGFuZ2xlICsgaW5jcmVtZW50KSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFtjeCArIHJ4ICogTWF0aC5jb3MoYW5nbGUpLCBjeSArIHJ5ICogTWF0aC5zaW4oYW5nbGUpXSk7XG4gICAgfVxuICAgIHBvaW50cy5wdXNoKFtjeCArIHJ4ICogTWF0aC5jb3Moc3RwKSwgY3kgKyByeSAqIE1hdGguc2luKHN0cCldKTtcbiAgICBwb2ludHMucHVzaChbY3gsIGN5XSk7XG4gICAgcmV0dXJuIHBhdHRlcm5GaWxsUG9seWdvbnMoW3BvaW50c10sIG8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRPZmZzZXQoeCwgbykge1xuICAgIHJldHVybiBfb2Zmc2V0T3B0KHgsIG8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRPZmZzZXRXaXRoUmFuZ2UobWluLCBtYXgsIG8pIHtcbiAgICByZXR1cm4gX29mZnNldChtaW4sIG1heCwgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG91YmxlTGluZUZpbGxPcHMoeDEsIHkxLCB4MiwgeTIsIG8pIHtcbiAgICByZXR1cm4gX2RvdWJsZUxpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIHRydWUpO1xufVxuLy8gUHJpdmF0ZSBoZWxwZXJzXG5mdW5jdGlvbiBjbG9uZU9wdGlvbnNBbHRlclNlZWQob3BzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3BzKTtcbiAgICByZXN1bHQucmFuZG9taXplciA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3BzLnNlZWQpIHtcbiAgICAgICAgcmVzdWx0LnNlZWQgPSBvcHMuc2VlZCArIDE7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByYW5kb20ob3BzKSB7XG4gICAgaWYgKCFvcHMucmFuZG9taXplcikge1xuICAgICAgICBvcHMucmFuZG9taXplciA9IG5ldyBSYW5kb20ob3BzLnNlZWQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBvcHMucmFuZG9taXplci5uZXh0KCk7XG59XG5mdW5jdGlvbiBfb2Zmc2V0KG1pbiwgbWF4LCBvcHMsIHJvdWdobmVzc0dhaW4gPSAxKSB7XG4gICAgcmV0dXJuIG9wcy5yb3VnaG5lc3MgKiByb3VnaG5lc3NHYWluICogKChyYW5kb20ob3BzKSAqIChtYXggLSBtaW4pKSArIG1pbik7XG59XG5mdW5jdGlvbiBfb2Zmc2V0T3B0KHgsIG9wcywgcm91Z2huZXNzR2FpbiA9IDEpIHtcbiAgICByZXR1cm4gX29mZnNldCgteCwgeCwgb3BzLCByb3VnaG5lc3NHYWluKTtcbn1cbmZ1bmN0aW9uIF9kb3VibGVMaW5lKHgxLCB5MSwgeDIsIHkyLCBvLCBmaWxsaW5nID0gZmFsc2UpIHtcbiAgICBjb25zdCBzaW5nbGVTdHJva2UgPSBmaWxsaW5nID8gby5kaXNhYmxlTXVsdGlTdHJva2VGaWxsIDogby5kaXNhYmxlTXVsdGlTdHJva2U7XG4gICAgY29uc3QgbzEgPSBfbGluZSh4MSwgeTEsIHgyLCB5MiwgbywgdHJ1ZSwgZmFsc2UpO1xuICAgIGlmIChzaW5nbGVTdHJva2UpIHtcbiAgICAgICAgcmV0dXJuIG8xO1xuICAgIH1cbiAgICBjb25zdCBvMiA9IF9saW5lKHgxLCB5MSwgeDIsIHkyLCBvLCB0cnVlLCB0cnVlKTtcbiAgICByZXR1cm4gbzEuY29uY2F0KG8yKTtcbn1cbmZ1bmN0aW9uIF9saW5lKHgxLCB5MSwgeDIsIHkyLCBvLCBtb3ZlLCBvdmVybGF5KSB7XG4gICAgY29uc3QgbGVuZ3RoU3EgPSBNYXRoLnBvdygoeDEgLSB4MiksIDIpICsgTWF0aC5wb3coKHkxIC0geTIpLCAyKTtcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQobGVuZ3RoU3EpO1xuICAgIGxldCByb3VnaG5lc3NHYWluID0gMTtcbiAgICBpZiAobGVuZ3RoIDwgMjAwKSB7XG4gICAgICAgIHJvdWdobmVzc0dhaW4gPSAxO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW5ndGggPiA1MDApIHtcbiAgICAgICAgcm91Z2huZXNzR2FpbiA9IDAuNDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJvdWdobmVzc0dhaW4gPSAoLTAuMDAxNjY2OCkgKiBsZW5ndGggKyAxLjIzMzMzNDtcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IG8ubWF4UmFuZG9tbmVzc09mZnNldCB8fCAwO1xuICAgIGlmICgob2Zmc2V0ICogb2Zmc2V0ICogMTAwKSA+IGxlbmd0aFNxKSB7XG4gICAgICAgIG9mZnNldCA9IGxlbmd0aCAvIDEwO1xuICAgIH1cbiAgICBjb25zdCBoYWxmT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcbiAgICBjb25zdCBkaXZlcmdlUG9pbnQgPSAwLjIgKyByYW5kb20obykgKiAwLjI7XG4gICAgbGV0IG1pZERpc3BYID0gby5ib3dpbmcgKiBvLm1heFJhbmRvbW5lc3NPZmZzZXQgKiAoeTIgLSB5MSkgLyAyMDA7XG4gICAgbGV0IG1pZERpc3BZID0gby5ib3dpbmcgKiBvLm1heFJhbmRvbW5lc3NPZmZzZXQgKiAoeDEgLSB4MikgLyAyMDA7XG4gICAgbWlkRGlzcFggPSBfb2Zmc2V0T3B0KG1pZERpc3BYLCBvLCByb3VnaG5lc3NHYWluKTtcbiAgICBtaWREaXNwWSA9IF9vZmZzZXRPcHQobWlkRGlzcFksIG8sIHJvdWdobmVzc0dhaW4pO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJhbmRvbUhhbGYgPSAoKSA9PiBfb2Zmc2V0T3B0KGhhbGZPZmZzZXQsIG8sIHJvdWdobmVzc0dhaW4pO1xuICAgIGNvbnN0IHJhbmRvbUZ1bGwgPSAoKSA9PiBfb2Zmc2V0T3B0KG9mZnNldCwgbywgcm91Z2huZXNzR2Fpbik7XG4gICAgY29uc3QgcHJlc2VydmVWZXJ0aWNlcyA9IG8ucHJlc2VydmVWZXJ0aWNlcztcbiAgICBpZiAobW92ZSkge1xuICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiAnbW92ZScsIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgeDEgKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiByYW5kb21IYWxmKCkpLFxuICAgICAgICAgICAgICAgICAgICB5MSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUhhbGYoKSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiAnbW92ZScsIGRhdGE6IFtcbiAgICAgICAgICAgICAgICAgICAgeDEgKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiBfb2Zmc2V0T3B0KG9mZnNldCwgbywgcm91Z2huZXNzR2FpbikpLFxuICAgICAgICAgICAgICAgICAgICB5MSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IF9vZmZzZXRPcHQob2Zmc2V0LCBvLCByb3VnaG5lc3NHYWluKSksXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIG1pZERpc3BYICsgeDEgKyAoeDIgLSB4MSkgKiBkaXZlcmdlUG9pbnQgKyByYW5kb21IYWxmKCksXG4gICAgICAgICAgICAgICAgbWlkRGlzcFkgKyB5MSArICh5MiAtIHkxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUhhbGYoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWCArIHgxICsgMiAqICh4MiAtIHgxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUhhbGYoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWSArIHkxICsgMiAqICh5MiAtIHkxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUhhbGYoKSxcbiAgICAgICAgICAgICAgICB4MiArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUhhbGYoKSksXG4gICAgICAgICAgICAgICAgeTIgKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiByYW5kb21IYWxmKCkpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICBvcDogJ2JjdXJ2ZVRvJyxcbiAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICBtaWREaXNwWCArIHgxICsgKHgyIC0geDEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tRnVsbCgpLFxuICAgICAgICAgICAgICAgIG1pZERpc3BZICsgeTEgKyAoeTIgLSB5MSkgKiBkaXZlcmdlUG9pbnQgKyByYW5kb21GdWxsKCksXG4gICAgICAgICAgICAgICAgbWlkRGlzcFggKyB4MSArIDIgKiAoeDIgLSB4MSkgKiBkaXZlcmdlUG9pbnQgKyByYW5kb21GdWxsKCksXG4gICAgICAgICAgICAgICAgbWlkRGlzcFkgKyB5MSArIDIgKiAoeTIgLSB5MSkgKiBkaXZlcmdlUG9pbnQgKyByYW5kb21GdWxsKCksXG4gICAgICAgICAgICAgICAgeDIgKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiByYW5kb21GdWxsKCkpLFxuICAgICAgICAgICAgICAgIHkyICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogcmFuZG9tRnVsbCgpKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xufVxuZnVuY3Rpb24gX2N1cnZlV2l0aE9mZnNldChwb2ludHMsIG9mZnNldCwgbykge1xuICAgIGlmICghcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHBzID0gW107XG4gICAgcHMucHVzaChbXG4gICAgICAgIHBvaW50c1swXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgcG9pbnRzWzBdWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgIF0pO1xuICAgIHBzLnB1c2goW1xuICAgICAgICBwb2ludHNbMF1bMF0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksXG4gICAgICAgIHBvaW50c1swXVsxXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICBdKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcy5wdXNoKFtcbiAgICAgICAgICAgIHBvaW50c1tpXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgICAgIHBvaW50c1tpXVsxXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGlmIChpID09PSAocG9pbnRzLmxlbmd0aCAtIDEpKSB7XG4gICAgICAgICAgICBwcy5wdXNoKFtcbiAgICAgICAgICAgICAgICBwb2ludHNbaV1bMF0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksXG4gICAgICAgICAgICAgICAgcG9pbnRzW2ldWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9jdXJ2ZShwcywgbnVsbCwgbyk7XG59XG5mdW5jdGlvbiBfY3VydmUocG9pbnRzLCBjbG9zZVBvaW50LCBvKSB7XG4gICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBpZiAobGVuID4gMykge1xuICAgICAgICBjb25zdCBiID0gW107XG4gICAgICAgIGNvbnN0IHMgPSAxIC0gby5jdXJ2ZVRpZ2h0bmVzcztcbiAgICAgICAgb3BzLnB1c2goeyBvcDogJ21vdmUnLCBkYXRhOiBbcG9pbnRzWzFdWzBdLCBwb2ludHNbMV1bMV1dIH0pO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgKGkgKyAyKSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZWRWZXJ0QXJyYXkgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBiWzBdID0gW2NhY2hlZFZlcnRBcnJheVswXSwgY2FjaGVkVmVydEFycmF5WzFdXTtcbiAgICAgICAgICAgIGJbMV0gPSBbY2FjaGVkVmVydEFycmF5WzBdICsgKHMgKiBwb2ludHNbaSArIDFdWzBdIC0gcyAqIHBvaW50c1tpIC0gMV1bMF0pIC8gNiwgY2FjaGVkVmVydEFycmF5WzFdICsgKHMgKiBwb2ludHNbaSArIDFdWzFdIC0gcyAqIHBvaW50c1tpIC0gMV1bMV0pIC8gNl07XG4gICAgICAgICAgICBiWzJdID0gW3BvaW50c1tpICsgMV1bMF0gKyAocyAqIHBvaW50c1tpXVswXSAtIHMgKiBwb2ludHNbaSArIDJdWzBdKSAvIDYsIHBvaW50c1tpICsgMV1bMV0gKyAocyAqIHBvaW50c1tpXVsxXSAtIHMgKiBwb2ludHNbaSArIDJdWzFdKSAvIDZdO1xuICAgICAgICAgICAgYlszXSA9IFtwb2ludHNbaSArIDFdWzBdLCBwb2ludHNbaSArIDFdWzFdXTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHsgb3A6ICdiY3VydmVUbycsIGRhdGE6IFtiWzFdWzBdLCBiWzFdWzFdLCBiWzJdWzBdLCBiWzJdWzFdLCBiWzNdWzBdLCBiWzNdWzFdXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xvc2VQb2ludCAmJiBjbG9zZVBvaW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgY29uc3Qgcm8gPSBvLm1heFJhbmRvbW5lc3NPZmZzZXQ7XG4gICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbGluZVRvJywgZGF0YTogW2Nsb3NlUG9pbnRbMF0gKyBfb2Zmc2V0T3B0KHJvLCBvKSwgY2xvc2VQb2ludFsxXSArIF9vZmZzZXRPcHQocm8sIG8pXSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAgICAgb3BzLnB1c2goeyBvcDogJ21vdmUnLCBkYXRhOiBbcG9pbnRzWzFdWzBdLCBwb2ludHNbMV1bMV1dIH0pO1xuICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICBvcDogJ2JjdXJ2ZVRvJyxcbiAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICBwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXSxcbiAgICAgICAgICAgICAgICBwb2ludHNbMl1bMF0sIHBvaW50c1syXVsxXSxcbiAgICAgICAgICAgICAgICBwb2ludHNbMl1bMF0sIHBvaW50c1syXVsxXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgICAgb3BzLnB1c2goLi4uX2xpbmUocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0sIHBvaW50c1sxXVswXSwgcG9pbnRzWzFdWzFdLCBvLCB0cnVlLCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBfY29tcHV0ZUVsbGlwc2VQb2ludHMoaW5jcmVtZW50LCBjeCwgY3ksIHJ4LCByeSwgb2Zmc2V0LCBvdmVybGFwLCBvKSB7XG4gICAgY29uc3QgY29yZU9ubHkgPSBvLnJvdWdobmVzcyA9PT0gMDtcbiAgICBjb25zdCBjb3JlUG9pbnRzID0gW107XG4gICAgY29uc3QgYWxsUG9pbnRzID0gW107XG4gICAgaWYgKGNvcmVPbmx5KSB7XG4gICAgICAgIGluY3JlbWVudCA9IGluY3JlbWVudCAvIDQ7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKFtcbiAgICAgICAgICAgIGN4ICsgcnggKiBNYXRoLmNvcygtaW5jcmVtZW50KSxcbiAgICAgICAgICAgIGN5ICsgcnkgKiBNYXRoLnNpbigtaW5jcmVtZW50KSxcbiAgICAgICAgXSk7XG4gICAgICAgIGZvciAobGV0IGFuZ2xlID0gMDsgYW5nbGUgPD0gTWF0aC5QSSAqIDI7IGFuZ2xlID0gYW5nbGUgKyBpbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBbXG4gICAgICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKGFuZ2xlKSxcbiAgICAgICAgICAgICAgICBjeSArIHJ5ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvcmVQb2ludHMucHVzaChwKTtcbiAgICAgICAgICAgIGFsbFBvaW50cy5wdXNoKHApO1xuICAgICAgICB9XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKFtcbiAgICAgICAgICAgIGN4ICsgcnggKiBNYXRoLmNvcygwKSxcbiAgICAgICAgICAgIGN5ICsgcnkgKiBNYXRoLnNpbigwKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKFtcbiAgICAgICAgICAgIGN4ICsgcnggKiBNYXRoLmNvcyhpbmNyZW1lbnQpLFxuICAgICAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKGluY3JlbWVudCksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmFkT2Zmc2V0ID0gX29mZnNldE9wdCgwLjUsIG8pIC0gKE1hdGguUEkgLyAyKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3ggKyAwLjkgKiByeCAqIE1hdGguY29zKHJhZE9mZnNldCAtIGluY3JlbWVudCksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIDAuOSAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0IC0gaW5jcmVtZW50KSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gTWF0aC5QSSAqIDIgKyByYWRPZmZzZXQgLSAwLjAxO1xuICAgICAgICBmb3IgKGxldCBhbmdsZSA9IHJhZE9mZnNldDsgYW5nbGUgPCBlbmRBbmdsZTsgYW5nbGUgPSBhbmdsZSArIGluY3JlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IFtcbiAgICAgICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIHJ4ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgcnkgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29yZVBvaW50cy5wdXNoKHApO1xuICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3ggKyByeCAqIE1hdGguY29zKHJhZE9mZnNldCArIE1hdGguUEkgKiAyICsgb3ZlcmxhcCAqIDAuNSksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0ICsgTWF0aC5QSSAqIDIgKyBvdmVybGFwICogMC41KSxcbiAgICAgICAgXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKFtcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgMC45OCAqIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0ICsgb3ZlcmxhcCksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIDAuOTggKiByeSAqIE1hdGguc2luKHJhZE9mZnNldCArIG92ZXJsYXApLFxuICAgICAgICBdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3ggKyAwLjkgKiByeCAqIE1hdGguY29zKHJhZE9mZnNldCArIG92ZXJsYXAgKiAwLjUpLFxuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3kgKyAwLjkgKiByeSAqIE1hdGguc2luKHJhZE9mZnNldCArIG92ZXJsYXAgKiAwLjUpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcmV0dXJuIFthbGxQb2ludHMsIGNvcmVQb2ludHNdO1xufVxuZnVuY3Rpb24gX2FyYyhpbmNyZW1lbnQsIGN4LCBjeSwgcngsIHJ5LCBzdHJ0LCBzdHAsIG9mZnNldCwgbykge1xuICAgIGNvbnN0IHJhZE9mZnNldCA9IHN0cnQgKyBfb2Zmc2V0T3B0KDAuMSwgbyk7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgcG9pbnRzLnB1c2goW1xuICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIDAuOSAqIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0IC0gaW5jcmVtZW50KSxcbiAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3kgKyAwLjkgKiByeSAqIE1hdGguc2luKHJhZE9mZnNldCAtIGluY3JlbWVudCksXG4gICAgXSk7XG4gICAgZm9yIChsZXQgYW5nbGUgPSByYWRPZmZzZXQ7IGFuZ2xlIDw9IHN0cDsgYW5nbGUgPSBhbmdsZSArIGluY3JlbWVudCkge1xuICAgICAgICBwb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIHJ4ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3kgKyByeSAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIHBvaW50cy5wdXNoKFtcbiAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKHN0cCksXG4gICAgICAgIGN5ICsgcnkgKiBNYXRoLnNpbihzdHApLFxuICAgIF0pO1xuICAgIHBvaW50cy5wdXNoKFtcbiAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKHN0cCksXG4gICAgICAgIGN5ICsgcnkgKiBNYXRoLnNpbihzdHApLFxuICAgIF0pO1xuICAgIHJldHVybiBfY3VydmUocG9pbnRzLCBudWxsLCBvKTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJUbyh4MSwgeTEsIHgyLCB5MiwgeCwgeSwgY3VycmVudCwgbykge1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGNvbnN0IHJvcyA9IFtvLm1heFJhbmRvbW5lc3NPZmZzZXQgfHwgMSwgKG8ubWF4UmFuZG9tbmVzc09mZnNldCB8fCAxKSArIDAuM107XG4gICAgbGV0IGYgPSBbMCwgMF07XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IG8uZGlzYWJsZU11bHRpU3Ryb2tlID8gMSA6IDI7XG4gICAgY29uc3QgcHJlc2VydmVWZXJ0aWNlcyA9IG8ucHJlc2VydmVWZXJ0aWNlcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgb3BzLnB1c2goeyBvcDogJ21vdmUnLCBkYXRhOiBbY3VycmVudFswXSwgY3VycmVudFsxXV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtjdXJyZW50WzBdICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogX29mZnNldE9wdChyb3NbMF0sIG8pKSwgY3VycmVudFsxXSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IF9vZmZzZXRPcHQocm9zWzBdLCBvKSldIH0pO1xuICAgICAgICB9XG4gICAgICAgIGYgPSBwcmVzZXJ2ZVZlcnRpY2VzID8gW3gsIHldIDogW3ggKyBfb2Zmc2V0T3B0KHJvc1tpXSwgbyksIHkgKyBfb2Zmc2V0T3B0KHJvc1tpXSwgbyldO1xuICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICBvcDogJ2JjdXJ2ZVRvJyxcbiAgICAgICAgICAgIGRhdGE6IFtcbiAgICAgICAgICAgICAgICB4MSArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSwgeTEgKyBfb2Zmc2V0T3B0KHJvc1tpXSwgbyksXG4gICAgICAgICAgICAgICAgeDIgKyBfb2Zmc2V0T3B0KHJvc1tpXSwgbyksIHkyICsgX29mZnNldE9wdChyb3NbaV0sIG8pLFxuICAgICAgICAgICAgICAgIGZbMF0sIGZbMV0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/renderer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/rough.js":
/*!*******************************************!*\
  !*** ./node_modules/roughjs/bin/rough.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas */ \"(app-pages-browser)/./node_modules/roughjs/bin/canvas.js\");\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generator */ \"(app-pages-browser)/./node_modules/roughjs/bin/generator.js\");\n/* harmony import */ var _svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svg */ \"(app-pages-browser)/./node_modules/roughjs/bin/svg.js\");\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    canvas(canvas, config) {\n        return new _canvas__WEBPACK_IMPORTED_MODULE_0__.RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new _svg__WEBPACK_IMPORTED_MODULE_2__.RoughSVG(svg, config);\n    },\n    generator(config) {\n        return new _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator(config);\n    },\n    newSeed() {\n        return _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator.newSeed();\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9yb3VnaC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQXVDO0FBQ007QUFDWjtBQUNqQywrREFBZTtBQUNmO0FBQ0EsbUJBQW1CLGdEQUFXO0FBQzlCLEtBQUs7QUFDTDtBQUNBLG1CQUFtQiwwQ0FBUTtBQUMzQixLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsc0RBQWM7QUFDakMsS0FBSztBQUNMO0FBQ0EsZUFBZSxzREFBYztBQUM3QixLQUFLO0FBQ0wsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9yb3VnaC5qcz9hMDUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJvdWdoQ2FudmFzIH0gZnJvbSAnLi9jYW52YXMnO1xuaW1wb3J0IHsgUm91Z2hHZW5lcmF0b3IgfSBmcm9tICcuL2dlbmVyYXRvcic7XG5pbXBvcnQgeyBSb3VnaFNWRyB9IGZyb20gJy4vc3ZnJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBjYW52YXMoY2FudmFzLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VnaENhbnZhcyhjYW52YXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBzdmcoc3ZnLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VnaFNWRyhzdmcsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBnZW5lcmF0b3IoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm91Z2hHZW5lcmF0b3IoY29uZmlnKTtcbiAgICB9LFxuICAgIG5ld1NlZWQoKSB7XG4gICAgICAgIHJldHVybiBSb3VnaEdlbmVyYXRvci5uZXdTZWVkKCk7XG4gICAgfSxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/rough.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/roughjs/bin/svg.js":
/*!*****************************************!*\
  !*** ./node_modules/roughjs/bin/svg.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughSVG: function() { return /* binding */ RoughSVG; }\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(app-pages-browser)/./node_modules/roughjs/bin/core.js\");\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generator */ \"(app-pages-browser)/./node_modules/roughjs/bin/generator.js\");\n\n\nclass RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'g');\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', o.stroke);\n                    path.setAttribute('stroke-width', o.strokeWidth + '');\n                    path.setAttribute('fill', 'none');\n                    if (o.strokeLineDash) {\n                        path.setAttribute('stroke-dasharray', o.strokeLineDash.join(' ').trim());\n                    }\n                    if (o.strokeLineDashOffset) {\n                        path.setAttribute('stroke-dashoffset', `${o.strokeLineDashOffset}`);\n                    }\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', 'none');\n                    path.setAttribute('stroke-width', '0');\n                    path.setAttribute('fill', o.fill || '');\n                    if (drawable.shape === 'curve' || drawable.shape === 'polygon') {\n                        path.setAttribute('fill-rule', 'evenodd');\n                    }\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing, o.fixedDecimalPlaceDigits));\n        path.setAttribute('stroke', o.fill || '');\n        path.setAttribute('stroke-width', fweight + '');\n        path.setAttribute('fill', 'none');\n        if (o.fillLineDash) {\n            path.setAttribute('stroke-dasharray', o.fillLineDash.join(' ').trim());\n        }\n        if (o.fillLineDashOffset) {\n            path.setAttribute('stroke-dashoffset', `${o.fillLineDashOffset}`);\n        }\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing, fixedDecimalPlaceDigits) {\n        return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9zdmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStCO0FBQ2M7QUFDdEM7QUFDUDtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0NBQUs7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3Q0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHVCQUF1QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3Q0FBSztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3Q0FBSztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vc3ZnLmpzPzA5ZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU1ZHTlMgfSBmcm9tICcuL2NvcmUnO1xuaW1wb3J0IHsgUm91Z2hHZW5lcmF0b3IgfSBmcm9tICcuL2dlbmVyYXRvcic7XG5leHBvcnQgY2xhc3MgUm91Z2hTVkcge1xuICAgIGNvbnN0cnVjdG9yKHN2ZywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgICB0aGlzLmdlbiA9IG5ldyBSb3VnaEdlbmVyYXRvcihjb25maWcpO1xuICAgIH1cbiAgICBkcmF3KGRyYXdhYmxlKSB7XG4gICAgICAgIGNvbnN0IHNldHMgPSBkcmF3YWJsZS5zZXRzIHx8IFtdO1xuICAgICAgICBjb25zdCBvID0gZHJhd2FibGUub3B0aW9ucyB8fCB0aGlzLmdldERlZmF1bHRPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGRvYyA9IHRoaXMuc3ZnLm93bmVyRG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xuICAgICAgICBjb25zdCBnID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdOUywgJ2cnKTtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gZHJhd2FibGUub3B0aW9ucy5maXhlZERlY2ltYWxQbGFjZURpZ2l0cztcbiAgICAgICAgZm9yIChjb25zdCBkcmF3aW5nIG9mIHNldHMpIHtcbiAgICAgICAgICAgIGxldCBwYXRoID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZHJhd2luZy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncGF0aCc6IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGRvYy5jcmVhdGVFbGVtZW50TlMoU1ZHTlMsICdwYXRoJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgdGhpcy5vcHNUb1BhdGgoZHJhd2luZywgcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvLnN0cm9rZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBvLnN0cm9rZVdpZHRoICsgJycpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnN0cm9rZUxpbmVEYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIG8uc3Ryb2tlTGluZURhc2guam9pbignICcpLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3Ryb2tlTGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIGAke28uc3Ryb2tlTGluZURhc2hPZmZzZXR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxQYXRoJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdOUywgJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLm9wc1RvUGF0aChkcmF3aW5nLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdub25lJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIG8uZmlsbCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmF3YWJsZS5zaGFwZSA9PT0gJ2N1cnZlJyB8fCBkcmF3YWJsZS5zaGFwZSA9PT0gJ3BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbFNrZXRjaCc6IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHRoaXMuZmlsbFNrZXRjaChkb2MsIGRyYXdpbmcsIG8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICAgIGZpbGxTa2V0Y2goZG9jLCBkcmF3aW5nLCBvKSB7XG4gICAgICAgIGxldCBmd2VpZ2h0ID0gby5maWxsV2VpZ2h0O1xuICAgICAgICBpZiAoZndlaWdodCA8IDApIHtcbiAgICAgICAgICAgIGZ3ZWlnaHQgPSBvLnN0cm9rZVdpZHRoIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdOUywgJ3BhdGgnKTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLm9wc1RvUGF0aChkcmF3aW5nLCBvLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzKSk7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBvLmZpbGwgfHwgJycpO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgZndlaWdodCArICcnKTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnbm9uZScpO1xuICAgICAgICBpZiAoby5maWxsTGluZURhc2gpIHtcbiAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgby5maWxsTGluZURhc2guam9pbignICcpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uZmlsbExpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hvZmZzZXQnLCBgJHtvLmZpbGxMaW5lRGFzaE9mZnNldH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgZ2V0IGdlbmVyYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuO1xuICAgIH1cbiAgICBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuLmRlZmF1bHRPcHRpb25zO1xuICAgIH1cbiAgICBvcHNUb1BhdGgoZHJhd2luZywgZml4ZWREZWNpbWFsUGxhY2VEaWdpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuLm9wc1RvUGF0aChkcmF3aW5nLCBmaXhlZERlY2ltYWxQbGFjZURpZ2l0cyk7XG4gICAgfVxuICAgIGxpbmUoeDEsIHkxLCB4MiwgeTIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmxpbmUoeDEsIHkxLCB4MiwgeTIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICByZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ucmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBlbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIGNpcmNsZSh4LCB5LCBkaWFtZXRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgbGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmxpbmVhclBhdGgocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgcG9seWdvbihwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLnBvbHlnb24ocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgYXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBjbG9zZWQgPSBmYWxzZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uYXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBjbG9zZWQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBjdXJ2ZShwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZ2VuLmN1cnZlKHBvaW50cywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIHBhdGgoZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkcmF3aW5nID0gdGhpcy5nZW4ucGF0aChkLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkcmF3aW5nKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/roughjs/bin/svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/global.css":
/*!****************************!*\
  !*** ./src/app/global.css ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"3d9c2cc9bcd8\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFsLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9nbG9iYWwuY3NzP2ZlN2YiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIzZDljMmNjOWJjZDhcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/global.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/Shapes/Circle.ts":
/*!******************************!*\
  !*** ./src/Shapes/Circle.ts ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var roughjs_bin_rough__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! roughjs/bin/rough */ \"(app-pages-browser)/./node_modules/roughjs/bin/rough.js\");\n\nclass Circle {\n    constructor(svgElement){\n        this.makeShape = (x, y, h, w)=>{\n            let roughNode = this.rc.circle(x, y, h);\n            roughNode.onclick = ()=>{\n                alert(\"hello\");\n            };\n            this.svgE.appendChild(roughNode);\n        };\n        this.showShape = (x, y, h, w)=>{\n            let roughNode = this.rc.circle(x, y, h);\n            this.svgE.appendChild(roughNode);\n            setTimeout(()=>{\n                this.svgE.removeChild(roughNode);\n            }, 1);\n        };\n        this.rc = roughjs_bin_rough__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg(svgElement);\n        this.svgE = svgElement;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Circle);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9TaGFwZXMvQ2lyY2xlLnRzIiwibWFwcGluZ3MiOiI7O0FBQXNDO0FBSXRDLE1BQU1DO0lBSUZDLFlBQVlDLFVBQXlCLENBQUU7YUFLdkNDLFlBQVksQ0FBQ0MsR0FBV0MsR0FBV0MsR0FBV0M7WUFDMUMsSUFBSUMsWUFBWSxJQUFJLENBQUNDLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDTixHQUFHQyxHQUFHQztZQUNyQ0UsVUFBVUcsT0FBTyxHQUFHO2dCQUNoQkMsTUFBTTtZQUNWO1lBQ0EsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFdBQVcsQ0FBQ047UUFDMUI7YUFFQU8sWUFBWSxDQUFDWCxHQUFXQyxHQUFXQyxHQUFXQztZQUMxQyxJQUFJQyxZQUFZLElBQUksQ0FBQ0MsRUFBRSxDQUFDQyxNQUFNLENBQUNOLEdBQUdDLEdBQUdDO1lBQ3JDLElBQUksQ0FBQ08sSUFBSSxDQUFDQyxXQUFXLENBQUNOO1lBQ3RCUSxXQUFXO2dCQUNQLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxXQUFXLENBQUNUO1lBQzFCLEdBQUc7UUFDUDtRQWxCSSxJQUFJLENBQUNDLEVBQUUsR0FBR1YseURBQUtBLENBQUNtQixHQUFHLENBQUNoQjtRQUNwQixJQUFJLENBQUNXLElBQUksR0FBR1g7SUFDaEI7QUFpQko7QUFFQSwrREFBZUYsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvU2hhcGVzL0NpcmNsZS50cz9hNjM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByb3VnaCBmcm9tICdyb3VnaGpzL2Jpbi9yb3VnaCc7XG5pbXBvcnQgeyBSb3VnaFNWRyB9IGZyb20gJ3JvdWdoanMvYmluL3N2Zyc7XG5pbXBvcnQgU2hhcGUgZnJvbSAnLi9TaGFwZXMnO1xuXG5jbGFzcyBDaXJjbGUgaW1wbGVtZW50cyBTaGFwZSB7XG4gICAgcmM6IFJvdWdoU1ZHO1xuICAgIHN2Z0U6IFNWR1NWR0VsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihzdmdFbGVtZW50OiBTVkdTVkdFbGVtZW50KSB7XG4gICAgICAgIHRoaXMucmMgPSByb3VnaC5zdmcoc3ZnRWxlbWVudCk7XG4gICAgICAgIHRoaXMuc3ZnRSA9IHN2Z0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgbWFrZVNoYXBlID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCBoOiBudW1iZXIsIHc6IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgcm91Z2hOb2RlID0gdGhpcy5yYy5jaXJjbGUoeCwgeSwgaCk7XG4gICAgICAgIHJvdWdoTm9kZS5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgYWxlcnQoXCJoZWxsb1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN2Z0UuYXBwZW5kQ2hpbGQocm91Z2hOb2RlKTtcbiAgICB9O1xuXG4gICAgc2hvd1NoYXBlID0gKHg6IG51bWJlciwgeTogbnVtYmVyLCBoOiBudW1iZXIsIHc6IG51bWJlcik6IHZvaWQgPT4ge1xuICAgICAgICBsZXQgcm91Z2hOb2RlID0gdGhpcy5yYy5jaXJjbGUoeCwgeSwgaCk7XG4gICAgICAgIHRoaXMuc3ZnRS5hcHBlbmRDaGlsZChyb3VnaE5vZGUpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ZnRS5yZW1vdmVDaGlsZChyb3VnaE5vZGUpO1xuICAgICAgICB9LCAxKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBDaXJjbGU7Il0sIm5hbWVzIjpbInJvdWdoIiwiQ2lyY2xlIiwiY29uc3RydWN0b3IiLCJzdmdFbGVtZW50IiwibWFrZVNoYXBlIiwieCIsInkiLCJoIiwidyIsInJvdWdoTm9kZSIsInJjIiwiY2lyY2xlIiwib25jbGljayIsImFsZXJ0Iiwic3ZnRSIsImFwcGVuZENoaWxkIiwic2hvd1NoYXBlIiwic2V0VGltZW91dCIsInJlbW92ZUNoaWxkIiwic3ZnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/Shapes/Circle.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/Shapes/Rectangle.ts":
/*!*********************************!*\
  !*** ./src/Shapes/Rectangle.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var roughjs_bin_rough__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! roughjs/bin/rough */ \"(app-pages-browser)/./node_modules/roughjs/bin/rough.js\");\n\nclass Rectangle {\n    constructor(svgElement){\n        this.makeShape = (x, y, h, w)=>{\n            var _roughNode_firstChild;\n            const roughNode = this.rc.rectangle(x, y, h, w);\n            (_roughNode_firstChild = roughNode.firstChild) === null || _roughNode_firstChild === void 0 ? void 0 : _roughNode_firstChild.addEventListener(\"mousedown\", (event)=>{\n                event.stopPropagation();\n            });\n            roughNode.addEventListener(\"mousedown\", (event)=>{\n                event.stopPropagation();\n                alert(\"hello\");\n            });\n            this.svgE.appendChild(roughNode);\n        };\n        this.showShape = (x, y, h, w)=>{\n            const roughNode = this.rc.rectangle(x, y, h, w);\n            this.svgE.appendChild(roughNode);\n            setTimeout(()=>{\n                this.svgE.removeChild(roughNode);\n            }, 1);\n        };\n        this.rc = roughjs_bin_rough__WEBPACK_IMPORTED_MODULE_0__[\"default\"].svg(svgElement);\n        this.svgE = svgElement;\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Rectangle);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9TaGFwZXMvUmVjdGFuZ2xlLnRzIiwibWFwcGluZ3MiOiI7O0FBQXNDO0FBSXRDLE1BQU1DO0lBSUZDLFlBQVlDLFVBQXlCLENBQUU7YUFLdkNDLFlBQVksQ0FBQ0MsR0FBV0MsR0FBV0MsR0FBV0M7Z0JBRzFDQztZQUZBLE1BQU1BLFlBQVksSUFBSSxDQUFDQyxFQUFFLENBQUNDLFNBQVMsQ0FBQ04sR0FBR0MsR0FBR0MsR0FBR0M7YUFFN0NDLHdCQUFBQSxVQUFVRyxVQUFVLGNBQXBCSCw0Q0FBQUEsc0JBQXNCSSxnQkFBZ0IsQ0FBQyxhQUFhLENBQUNDO2dCQUNqREEsTUFBTUMsZUFBZTtZQUN6QjtZQUVBTixVQUFVSSxnQkFBZ0IsQ0FBQyxhQUFhLENBQUNDO2dCQUNyQ0EsTUFBTUMsZUFBZTtnQkFFckJDLE1BQU07WUFDVjtZQUNBLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxXQUFXLENBQUNUO1FBQzFCO2FBR0FVLFlBQVksQ0FBQ2QsR0FBV0MsR0FBV0MsR0FBV0M7WUFDMUMsTUFBTUMsWUFBWSxJQUFJLENBQUNDLEVBQUUsQ0FBQ0MsU0FBUyxDQUFDTixHQUFHQyxHQUFHQyxHQUFHQztZQUM3QyxJQUFJLENBQUNTLElBQUksQ0FBQ0MsV0FBVyxDQUFDVDtZQUN0QlcsV0FBVztnQkFDUCxJQUFJLENBQUNILElBQUksQ0FBQ0ksV0FBVyxDQUFDWjtZQUMxQixHQUFHO1FBQ1A7UUExQkksSUFBSSxDQUFDQyxFQUFFLEdBQUdWLHlEQUFLQSxDQUFDc0IsR0FBRyxDQUFDbkI7UUFDcEIsSUFBSSxDQUFDYyxJQUFJLEdBQUdkO0lBQ2hCO0FBeUJKO0FBRUEsK0RBQWVGLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL1NoYXBlcy9SZWN0YW5nbGUudHM/MTMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm91Z2ggZnJvbSAncm91Z2hqcy9iaW4vcm91Z2gnO1xuaW1wb3J0IHsgUm91Z2hTVkcgfSBmcm9tICdyb3VnaGpzL2Jpbi9zdmcnO1xuaW1wb3J0IFNoYXBlIGZyb20gJy4vU2hhcGVzJztcblxuY2xhc3MgUmVjdGFuZ2xlIGltcGxlbWVudHMgU2hhcGUge1xuICAgIHJjOiBSb3VnaFNWRztcbiAgICBzdmdFOiBTVkdTVkdFbGVtZW50O1xuXG4gICAgY29uc3RydWN0b3Ioc3ZnRWxlbWVudDogU1ZHU1ZHRWxlbWVudCkge1xuICAgICAgICB0aGlzLnJjID0gcm91Z2guc3ZnKHN2Z0VsZW1lbnQpO1xuICAgICAgICB0aGlzLnN2Z0UgPSBzdmdFbGVtZW50O1xuICAgIH1cblxuICAgIG1ha2VTaGFwZSA9ICh4OiBudW1iZXIsIHk6IG51bWJlciwgaDogbnVtYmVyLCB3OiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgcm91Z2hOb2RlID0gdGhpcy5yYy5yZWN0YW5nbGUoeCwgeSwgaCwgdyk7XG5cbiAgICAgICAgcm91Z2hOb2RlLmZpcnN0Q2hpbGQ/LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgcm91Z2hOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIGFsZXJ0KFwiaGVsbG9cIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN2Z0UuYXBwZW5kQ2hpbGQocm91Z2hOb2RlKTtcbiAgICB9O1xuXG5cbiAgICBzaG93U2hhcGUgPSAoeDogbnVtYmVyLCB5OiBudW1iZXIsIGg6IG51bWJlciwgdzogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHJvdWdoTm9kZSA9IHRoaXMucmMucmVjdGFuZ2xlKHgsIHksIGgsIHcpO1xuICAgICAgICB0aGlzLnN2Z0UuYXBwZW5kQ2hpbGQocm91Z2hOb2RlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN2Z0UucmVtb3ZlQ2hpbGQocm91Z2hOb2RlKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVjdGFuZ2xlOyJdLCJuYW1lcyI6WyJyb3VnaCIsIlJlY3RhbmdsZSIsImNvbnN0cnVjdG9yIiwic3ZnRWxlbWVudCIsIm1ha2VTaGFwZSIsIngiLCJ5IiwiaCIsInciLCJyb3VnaE5vZGUiLCJyYyIsInJlY3RhbmdsZSIsImZpcnN0Q2hpbGQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJzdG9wUHJvcGFnYXRpb24iLCJhbGVydCIsInN2Z0UiLCJhcHBlbmRDaGlsZCIsInNob3dTaGFwZSIsInNldFRpbWVvdXQiLCJyZW1vdmVDaGlsZCIsInN2ZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/Shapes/Rectangle.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/_components/Modal/JoinRoomModal.tsx":
/*!*****************************************************!*\
  !*** ./src/app/_components/Modal/JoinRoomModal.tsx ***!
  \*****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nconst JoinRoomModal = (param)=>{\n    let { socket, name, getRoomNo, getInput } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col items-center\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                id: \"room-number\",\n                className: \"w-full mb-4 px-3 py-2 text-black bg-white rounded-md font-amatic text-3xl focus:outline-none focus:ring-2 focus:ring-green-500\",\n                type: \"number\",\n                placeholder: \"Enter Room Number\",\n                onInput: getInput\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/JoinRoomModal.tsx\",\n                lineNumber: 9,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                id: \"room-id-button\",\n                className: \"w-full bg-green-600 text-white font-semibold py-2 px-4 font-amatic text-3xl rounded-md hover:bg-green-700 transition duration-300\",\n                onClick: getRoomNo,\n                children: \"Join Room\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/JoinRoomModal.tsx\",\n                lineNumber: 16,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/JoinRoomModal.tsx\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, undefined);\n};\n_c = JoinRoomModal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (JoinRoomModal);\nvar _c;\n$RefreshReg$(_c, \"JoinRoomModal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvTW9kYWwvSm9pblJvb21Nb2RhbC50c3giLCJtYXBwaW5ncyI6Ijs7O0FBRUEsTUFBTUEsZ0JBQWdCO1FBQUMsRUFBRUMsTUFBTSxFQUFFQyxJQUFJLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUErRTtJQUVySSxxQkFHSSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNDO2dCQUNHQyxJQUFHO2dCQUNIRixXQUFVO2dCQUNWRyxNQUFLO2dCQUNMQyxhQUFZO2dCQUNaQyxTQUFTUDs7Ozs7OzBCQUViLDhEQUFDUTtnQkFDR0osSUFBRztnQkFDSEYsV0FBVTtnQkFDVk8sU0FBU1Y7MEJBRVo7Ozs7Ozs7Ozs7OztBQU9iO0tBekJNSDtBQTJCTiwrREFBZUEsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL19jb21wb25lbnRzL01vZGFsL0pvaW5Sb29tTW9kYWwudHN4PzA2OGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5cbmNvbnN0IEpvaW5Sb29tTW9kYWwgPSAoeyBzb2NrZXQsIG5hbWUsIGdldFJvb21ObywgZ2V0SW5wdXR9OiB7IHNvY2tldDogV2ViU29ja2V0LCBuYW1lOiBzdHJpbmcsIGdldFJvb21ObzogKCkgPT4gdm9pZCwgZ2V0SW5wdXQ6KCk9PnZvaWR9KSA9PiB7XG5cbiAgICByZXR1cm4gKFxuXG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgaWQ9XCJyb29tLW51bWJlclwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIG1iLTQgcHgtMyBweS0yIHRleHQtYmxhY2sgYmctd2hpdGUgcm91bmRlZC1tZCBmb250LWFtYXRpYyB0ZXh0LTN4bCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0yIGZvY3VzOnJpbmctZ3JlZW4tNTAwXCJcbiAgICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIFJvb20gTnVtYmVyXCJcbiAgICAgICAgICAgICAgICBvbklucHV0PXtnZXRJbnB1dH1cbiAgICAgICAgICAgID48L2lucHV0PlxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGlkPVwicm9vbS1pZC1idXR0b25cIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBiZy1ncmVlbi02MDAgdGV4dC13aGl0ZSBmb250LXNlbWlib2xkIHB5LTIgcHgtNCBmb250LWFtYXRpYyB0ZXh0LTN4bCByb3VuZGVkLW1kIGhvdmVyOmJnLWdyZWVuLTcwMCB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMFwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17Z2V0Um9vbU5vfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIEpvaW4gUm9vbVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuXG5cbiAgICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEpvaW5Sb29tTW9kYWw7Il0sIm5hbWVzIjpbIkpvaW5Sb29tTW9kYWwiLCJzb2NrZXQiLCJuYW1lIiwiZ2V0Um9vbU5vIiwiZ2V0SW5wdXQiLCJkaXYiLCJjbGFzc05hbWUiLCJpbnB1dCIsImlkIiwidHlwZSIsInBsYWNlaG9sZGVyIiwib25JbnB1dCIsImJ1dHRvbiIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/_components/Modal/JoinRoomModal.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/_components/Modal/Modal.tsx":
/*!*********************************************!*\
  !*** ./src/app/_components/Modal/Modal.tsx ***!
  \*********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ReactPortal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReactPortal */ \"(app-pages-browser)/./src/app/_components/Modal/ReactPortal.tsx\");\n\nvar _s = $RefreshSig$();\n\n\nfunction Modal(param) {\n    let { children, isOpen, handleClose, handleEnter } = param;\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const modal = document.getElementById(\"react-portal-modal-container\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"z-50\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"absolute\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"inset-0\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"my-auto\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"mx-auto\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"h-32\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"w-64\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"border\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"rounded-lg\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"z-40\");\n        modal === null || modal === void 0 ? void 0 : modal.classList.add(\"bg-green-300\");\n        if (isOpen) {\n            const root = document.getElementById(\"root\");\n            const dull = document.createElement(\"div\");\n            dull.setAttribute(\"id\", \"dull\");\n            dull.classList.add(\"absolute\");\n            dull.classList.add(\"inset-0\");\n            dull.classList.add(\"bg-black\");\n            dull.classList.add(\"opacity-50\");\n            root === null || root === void 0 ? void 0 : root.appendChild(dull);\n        }\n        const closeOnEscapeKey = (e)=>e.key === \"Escape\" ? handleClose() : null;\n        document.body.addEventListener(\"keydown\", closeOnEscapeKey);\n        const closeOnEnter = (e)=>e.key === \"Enter\" ? handleEnter() : null;\n        document.body.addEventListener(\"keydown\", closeOnEnter);\n        return ()=>{\n            document.body.removeEventListener(\"keydown\", closeOnEscapeKey);\n        };\n    });\n    if (!isOpen) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ReactPortal__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n        wrapperId: \"react-portal-modal-container\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            id: \"modal\",\n            className: \"fixed inset-0 flex items-center justify-center bg-black bg-opacity-50\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"bg-green-400 rounded-lg shadow-lg p-6 w-64\",\n                children: children\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/Modal.tsx\",\n                lineNumber: 53,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/Modal.tsx\",\n            lineNumber: 52,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/Modal.tsx\",\n        lineNumber: 51,\n        columnNumber: 9\n    }, this);\n}\n_s(Modal, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = Modal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Modal);\nvar _c;\n$RefreshReg$(_c, \"Modal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvTW9kYWwvTW9kYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7QUFDTDtBQUV4QyxTQUFTRSxNQUFNLEtBQXNJO1FBQXRJLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFQyxXQUFXLEVBQUdDLFdBQVcsRUFBeUYsR0FBdEk7O0lBQ1hOLGdEQUFTQSxDQUFDO1FBRU4sTUFBTU8sUUFBUUMsU0FBU0MsY0FBYyxDQUFDO1FBQ3RDRixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBQ3JCSixrQkFBQUEsNEJBQUFBLE1BQU9HLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1FBSXJCLElBQUlQLFFBQVE7WUFDUixNQUFNUSxPQUFPSixTQUFTQyxjQUFjLENBQUM7WUFDckMsTUFBTUksT0FBT0wsU0FBU00sYUFBYSxDQUFDO1lBQ3BDRCxLQUFLRSxZQUFZLENBQUMsTUFBTTtZQUN4QkYsS0FBS0gsU0FBUyxDQUFDQyxHQUFHLENBQUM7WUFDbkJFLEtBQUtILFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO1lBQ25CRSxLQUFLSCxTQUFTLENBQUNDLEdBQUcsQ0FBQztZQUNuQkUsS0FBS0gsU0FBUyxDQUFDQyxHQUFHLENBQUM7WUFDbkJDLGlCQUFBQSwyQkFBQUEsS0FBTUksV0FBVyxDQUFDSDtRQUN0QjtRQUVBLE1BQU1JLG1CQUFtQixDQUFDQyxJQUFxQkEsRUFBRUMsR0FBRyxLQUFLLFdBQVdkLGdCQUFnQjtRQUVwRkcsU0FBU1ksSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQyxXQUFXSjtRQUMxQyxNQUFNSyxlQUFjLENBQUNKLElBQXFCQSxFQUFFQyxHQUFHLEtBQUssVUFBVWIsZ0JBQWdCO1FBRTlFRSxTQUFTWSxJQUFJLENBQUNDLGdCQUFnQixDQUFDLFdBQVdDO1FBRTFDLE9BQU87WUFDSGQsU0FBU1ksSUFBSSxDQUFDRyxtQkFBbUIsQ0FBQyxXQUFXTjtRQUNqRDtJQUdKO0lBR0EsSUFBSSxDQUFDYixRQUFRLE9BQU87SUFFcEIscUJBQ0ksOERBQUNILG9EQUFXQTtRQUFDdUIsV0FBVTtrQkFDbkIsNEVBQUNDO1lBQUlDLElBQUc7WUFBUUMsV0FBVTtzQkFDdEIsNEVBQUNGO2dCQUFJRSxXQUFVOzBCQUNWeEI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFNckI7R0F4RFNEO0tBQUFBO0FBMERULCtEQUFlQSxLQUFLQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvTW9kYWwvTW9kYWwudHN4PzM0NjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVhY3ROb2RlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdFBvcnRhbCBmcm9tIFwiLi9SZWFjdFBvcnRhbFwiO1xuXG5mdW5jdGlvbiBNb2RhbCh7IGNoaWxkcmVuLCBpc09wZW4sIGhhbmRsZUNsb3NlICwgaGFuZGxlRW50ZXJ9OiB7IGNoaWxkcmVuOiBSZWFjdE5vZGUsIGlzT3BlbjogYm9vbGVhbiwgaGFuZGxlQ2xvc2U6ICgpID0+IHZvaWQsIGhhbmRsZUVudGVyOigpPT52b2lkfSkge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG5cbiAgICAgICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVhY3QtcG9ydGFsLW1vZGFsLWNvbnRhaW5lcicpITtcbiAgICAgICAgbW9kYWw/LmNsYXNzTGlzdC5hZGQoJ3otNTAnKTtcbiAgICAgICAgbW9kYWw/LmNsYXNzTGlzdC5hZGQoJ2Fic29sdXRlJyk7XG4gICAgICAgIG1vZGFsPy5jbGFzc0xpc3QuYWRkKCdpbnNldC0wJyk7XG4gICAgICAgIG1vZGFsPy5jbGFzc0xpc3QuYWRkKCdteS1hdXRvJyk7XG4gICAgICAgIG1vZGFsPy5jbGFzc0xpc3QuYWRkKCdteC1hdXRvJyk7XG4gICAgICAgIG1vZGFsPy5jbGFzc0xpc3QuYWRkKCdoLTMyJyk7XG4gICAgICAgIG1vZGFsPy5jbGFzc0xpc3QuYWRkKCd3LTY0Jyk7XG4gICAgICAgIG1vZGFsPy5jbGFzc0xpc3QuYWRkKCdib3JkZXInKTtcbiAgICAgICAgbW9kYWw/LmNsYXNzTGlzdC5hZGQoJ3JvdW5kZWQtbGcnKVxuICAgICAgICBtb2RhbD8uY2xhc3NMaXN0LmFkZCgnei00MCcpO1xuICAgICAgICBtb2RhbD8uY2xhc3NMaXN0LmFkZCgnYmctZ3JlZW4tMzAwJyk7XG5cblxuXG4gICAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpO1xuICAgICAgICAgICAgY29uc3QgZHVsbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZHVsbC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2R1bGwnKTtcbiAgICAgICAgICAgIGR1bGwuY2xhc3NMaXN0LmFkZCgnYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIGR1bGwuY2xhc3NMaXN0LmFkZCgnaW5zZXQtMCcpO1xuICAgICAgICAgICAgZHVsbC5jbGFzc0xpc3QuYWRkKCdiZy1ibGFjaycpO1xuICAgICAgICAgICAgZHVsbC5jbGFzc0xpc3QuYWRkKCdvcGFjaXR5LTUwJyk7XG4gICAgICAgICAgICByb290Py5hcHBlbmRDaGlsZChkdWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXkgPSAoZTogS2V5Ym9hcmRFdmVudCkgPT4gZS5rZXkgPT09IFwiRXNjYXBlXCIgPyBoYW5kbGVDbG9zZSgpIDogbnVsbDtcblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNsb3NlT25Fc2NhcGVLZXkpO1xuICAgICAgICBjb25zdCBjbG9zZU9uRW50ZXI9IChlOiBLZXlib2FyZEV2ZW50KSA9PiBlLmtleSA9PT0gXCJFbnRlclwiID8gaGFuZGxlRW50ZXIoKSA6IG51bGw7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBjbG9zZU9uRW50ZXIpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGNsb3NlT25Fc2NhcGVLZXkpO1xuICAgICAgICB9O1xuXG5cbiAgICB9LCk7XG5cblxuICAgIGlmICghaXNPcGVuKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSZWFjdFBvcnRhbCB3cmFwcGVySWQ9XCJyZWFjdC1wb3J0YWwtbW9kYWwtY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8ZGl2IGlkPVwibW9kYWxcIiBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLWJsYWNrIGJnLW9wYWNpdHktNTBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyZWVuLTQwMCByb3VuZGVkLWxnIHNoYWRvdy1sZyBwLTYgdy02NFwiPlxuICAgICAgICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9SZWFjdFBvcnRhbD5cblxuICAgIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgTW9kYWw7Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsIlJlYWN0UG9ydGFsIiwiTW9kYWwiLCJjaGlsZHJlbiIsImlzT3BlbiIsImhhbmRsZUNsb3NlIiwiaGFuZGxlRW50ZXIiLCJtb2RhbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjbGFzc0xpc3QiLCJhZGQiLCJyb290IiwiZHVsbCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJhcHBlbmRDaGlsZCIsImNsb3NlT25Fc2NhcGVLZXkiLCJlIiwia2V5IiwiYm9keSIsImFkZEV2ZW50TGlzdGVuZXIiLCJjbG9zZU9uRW50ZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid3JhcHBlcklkIiwiZGl2IiwiaWQiLCJjbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/_components/Modal/Modal.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/_components/Modal/ReactPortal.tsx":
/*!***************************************************!*\
  !*** ./src/app/_components/Modal/ReactPortal.tsx ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nfunction ReactPortal(param) {\n    let { children, wrapperId } = param;\n    _s();\n    const [isPortalReady, setIsPortalReady] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const wrapperElement = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(null);\n    let systemCreated;\n    const createAndAppendElement = ()=>{\n        const element = document.createElement(\"div\");\n        element.setAttribute(\"id\", wrapperId);\n        document.body.appendChild(element);\n        return element;\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(()=>{\n        let element = document.getElementById(wrapperId);\n        systemCreated = false;\n        if (!element) {\n            element = createAndAppendElement();\n            systemCreated = true;\n        }\n        wrapperElement.current = element;\n        setIsPortalReady(true);\n        return ()=>{\n            if (systemCreated && (element === null || element === void 0 ? void 0 : element.parentNode)) {\n                element.parentNode.removeChild(element);\n            }\n        };\n    }, [\n        wrapperId\n    ]);\n    if (isPortalReady) {\n        return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(children, wrapperElement.current);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"Loading...\"\n    }, void 0, false, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/Modal/ReactPortal.tsx\",\n        lineNumber: 36,\n        columnNumber: 12\n    }, this);\n}\n_s(ReactPortal, \"+BCejTwpEbth+79oPZNmXssNO+s=\");\n_c = ReactPortal;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ReactPortal);\nvar _c;\n$RefreshReg$(_c, \"ReactPortal\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvTW9kYWwvUmVhY3RQb3J0YWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDb0M7QUFFN0UsU0FBU0ksWUFBWSxLQUFzRTtRQUF0RSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBaUQsR0FBdEU7O0lBQ2pCLE1BQU0sQ0FBQ0MsZUFBZUMsaUJBQWlCLEdBQUdOLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU1PLGlCQUFpQk4sNkNBQU1BLENBQWlCO0lBQzlDLElBQUlPO0lBQ0osTUFBTUMseUJBQXlCO1FBQzNCLE1BQU1DLFVBQVVDLFNBQVNDLGFBQWEsQ0FBQztRQUN2Q0YsUUFBUUcsWUFBWSxDQUFDLE1BQU1UO1FBQzNCTyxTQUFTRyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0w7UUFDMUIsT0FBT0E7SUFDWDtJQUVBWCxnREFBU0EsQ0FBQztRQUNOLElBQUlXLFVBQVVDLFNBQVNLLGNBQWMsQ0FBQ1o7UUFDdENJLGdCQUFnQjtRQUVoQixJQUFJLENBQUNFLFNBQVM7WUFDVkEsVUFBVUQ7WUFDVkQsZ0JBQWdCO1FBQ3BCO1FBQ0FELGVBQWVVLE9BQU8sR0FBR1A7UUFFekJKLGlCQUFpQjtRQUVqQixPQUFPO1lBQ0gsSUFBSUUsa0JBQWlCRSxvQkFBQUEsOEJBQUFBLFFBQVNRLFVBQVUsR0FBRTtnQkFDdENSLFFBQVFRLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDVDtZQUNuQztRQUNKO0lBQ0osR0FBRztRQUFDTjtLQUFVO0lBQ2QsSUFBSUMsZUFBZTtRQUNmLHFCQUFPUCx1REFBWUEsQ0FBQ0ssVUFBVUksZUFBZVUsT0FBTztJQUN4RDtJQUNBLHFCQUFPLDhEQUFDRztrQkFBSTs7Ozs7O0FBQ2hCO0dBakNTbEI7S0FBQUE7QUFtQ1QsK0RBQWVBLFdBQVdBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9fY29tcG9uZW50cy9Nb2RhbC9SZWFjdFBvcnRhbC50c3g/MmI5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgeyBSZWFjdEVsZW1lbnQsIFJlYWN0Tm9kZSwgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5cbmZ1bmN0aW9uIFJlYWN0UG9ydGFsKHsgY2hpbGRyZW4sIHdyYXBwZXJJZCB9OiB7IGNoaWxkcmVuOiBSZWFjdEVsZW1lbnQ7IHdyYXBwZXJJZDogc3RyaW5nIH0pIHtcbiAgICBjb25zdCBbaXNQb3J0YWxSZWFkeSwgc2V0SXNQb3J0YWxSZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3Qgd3JhcHBlckVsZW1lbnQgPSB1c2VSZWY8RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICAgIGxldCBzeXN0ZW1DcmVhdGVkOiBib29sZWFuO1xuICAgIGNvbnN0IGNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgd3JhcHBlcklkKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh3cmFwcGVySWQpO1xuICAgICAgICBzeXN0ZW1DcmVhdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gY3JlYXRlQW5kQXBwZW5kRWxlbWVudCgpO1xuICAgICAgICAgICAgc3lzdGVtQ3JlYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlckVsZW1lbnQuY3VycmVudCA9IGVsZW1lbnQ7XG5cbiAgICAgICAgc2V0SXNQb3J0YWxSZWFkeSh0cnVlKTtcblxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN5c3RlbUNyZWF0ZWQgJiYgZWxlbWVudD8ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbd3JhcHBlcklkXSk7XG4gICAgaWYgKGlzUG9ydGFsUmVhZHkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgd3JhcHBlckVsZW1lbnQuY3VycmVudCEpO1xuICAgIH1cbiAgICByZXR1cm4gPGRpdj5Mb2FkaW5nLi4uPC9kaXY+O1xufVxuXG5leHBvcnQgZGVmYXVsdCBSZWFjdFBvcnRhbDtcbiJdLCJuYW1lcyI6WyJjcmVhdGVQb3J0YWwiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVJlZiIsIlJlYWN0UG9ydGFsIiwiY2hpbGRyZW4iLCJ3cmFwcGVySWQiLCJpc1BvcnRhbFJlYWR5Iiwic2V0SXNQb3J0YWxSZWFkeSIsIndyYXBwZXJFbGVtZW50Iiwic3lzdGVtQ3JlYXRlZCIsImNyZWF0ZUFuZEFwcGVuZEVsZW1lbnQiLCJlbGVtZW50IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZ2V0RWxlbWVudEJ5SWQiLCJjdXJyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/_components/Modal/ReactPortal.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/_components/People.tsx":
/*!****************************************!*\
  !*** ./src/app/_components/People.tsx ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction People(param) {\n    let { index } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"p-2 z-40\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"flex items-center justify-center h-12 w-12 rounded-full bg-emerald-400 opacity-50 shadow hover:opacity-70\",\n            title: index,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                className: \"text-black font-bold text-l opacity-100\",\n                children: index.charAt(0).toUpperCase()\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/People.tsx\",\n                lineNumber: 8,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/People.tsx\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/People.tsx\",\n        lineNumber: 6,\n        columnNumber: 5\n    }, this);\n}\n_c = People;\n/* harmony default export */ __webpack_exports__[\"default\"] = (People);\nvar _c;\n$RefreshReg$(_c, \"People\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvUGVvcGxlLnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjtBQUUxQixTQUFTQyxPQUFPLEtBQTRCO1FBQTVCLEVBQUVDLEtBQUssRUFBcUIsR0FBNUI7SUFFZCxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBVTtrQkFDYiw0RUFBQ0Q7WUFBSUMsV0FBWTtZQUE0R0MsT0FBT0g7c0JBQ2xJLDRFQUFDSTtnQkFBR0YsV0FBVTswQkFBMkNGLE1BQU1LLE1BQU0sQ0FBQyxHQUFHQyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7O0FBSTVGO0tBVFNQO0FBV1QsK0RBQWVBLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9fY29tcG9uZW50cy9QZW9wbGUudHN4P2Y0OGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5mdW5jdGlvbiBQZW9wbGUoeyBpbmRleCB9OiB7IGluZGV4OiBzdHJpbmcgfSkge1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJwLTIgei00MFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2BmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBoLTEyIHctMTIgcm91bmRlZC1mdWxsIGJnLWVtZXJhbGQtNDAwIG9wYWNpdHktNTAgc2hhZG93IGhvdmVyOm9wYWNpdHktNzBgfSB0aXRsZT17aW5kZXh9PlxuICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC1ibGFjayBmb250LWJvbGQgdGV4dC1sIG9wYWNpdHktMTAwXCI+e2luZGV4LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfTwvaDE+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGVvcGxlO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiUGVvcGxlIiwiaW5kZXgiLCJkaXYiLCJjbGFzc05hbWUiLCJ0aXRsZSIsImgxIiwiY2hhckF0IiwidG9VcHBlckNhc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/_components/People.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/_components/ToolBar.tsx":
/*!*****************************************!*\
  !*** ./src/app/_components/ToolBar.tsx ***!
  \*****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst Toolbar = (param)=>{\n    let { selectTool, websocket, createRoom, leaveRoom } = param;\n    _s();\n    const [drawing, setDrawing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const chooseTool = (e)=>{\n        const tool = e.target.innerHTML.toLowerCase();\n        selectTool(tool);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const svgElement = document.getElementById(\"svg\");\n        const saveButton = document.getElementById(\"save\");\n        saveButton === null || saveButton === void 0 ? void 0 : saveButton.addEventListener(\"click\", ()=>{\n            var svgString = new XMLSerializer().serializeToString(svgElement);\n            var canvas = document.createElement(\"canvas\");\n            var ctx = canvas.getContext(\"2d\");\n            var DOMURL = self.URL || self.webkitURL || self;\n            var img = new Image();\n            var svg = new Blob([\n                svgString\n            ], {\n                type: \"image/svg+xml;charset=utf-8\"\n            });\n            var url = DOMURL.createObjectURL(svg);\n            var png;\n            img.onload = function() {\n                ctx.drawImage(img, 0, 0);\n                png = canvas.toDataURL(\"image/png\");\n                DOMURL.revokeObjectURL(png);\n            };\n            img.src = url;\n            const downloadLInk = document.createElement(\"a\");\n            downloadLInk.href = url;\n            downloadLInk.download = \"drawing.png\";\n            downloadLInk.click();\n        });\n        const resetButton = document.getElementById(\"reset\");\n        resetButton === null || resetButton === void 0 ? void 0 : resetButton.addEventListener(\"click\", ()=>{\n            while(svgElement === null || svgElement === void 0 ? void 0 : svgElement.lastChild){\n                svgElement.removeChild(svgElement.lastChild);\n            }\n        });\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-row justify-center space-x-5 cursor-default font-amatic text-2xl\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                onClick: chooseTool,\n                children: \"Rectangle\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 50,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                onClick: chooseTool,\n                children: \"Circle\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 53,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                id: \"save\",\n                children: \"Save\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 56,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                id: \"reset\",\n                children: \"Reset\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 59,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                onClick: createRoom,\n                children: \"Create Room\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 62,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                id: \"open-modal\",\n                children: \"Join room\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"cursor-pointer\",\n                id: \"leave-room\",\n                onClick: leaveRoom,\n                children: \"Leave room\"\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n                lineNumber: 68,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/ToolBar.tsx\",\n        lineNumber: 49,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Toolbar, \"UJ5TZYBKRWvGe0MgRkfNlwWn+w8=\");\n_c = Toolbar;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Toolbar);\nvar _c;\n$RefreshReg$(_c, \"Toolbar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvVG9vbEJhci50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW1EO0FBQ25ELE1BQU1HLFVBQVU7UUFBQyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxTQUFTLEVBQXNHOztJQUVuSyxNQUFNLENBQUNDLFNBQVNDLFdBQVcsR0FBR1AsK0NBQVFBLENBQUM7SUFFdkMsTUFBTVEsYUFBYSxDQUFDQztRQUNsQixNQUFNQyxPQUFPLEVBQUdDLE1BQU0sQ0FBaUJDLFNBQVMsQ0FBQ0MsV0FBVztRQUM1RFgsV0FBV1E7SUFDYjtJQUVBWCxnREFBU0EsQ0FBQztRQUNSLE1BQU1lLGFBQWFDLFNBQVNDLGNBQWMsQ0FBQztRQUMzQyxNQUFNQyxhQUFhRixTQUFTQyxjQUFjLENBQUM7UUFDM0NDLHVCQUFBQSxpQ0FBQUEsV0FBWUMsZ0JBQWdCLENBQUMsU0FBUztZQUNwQyxJQUFJQyxZQUFZLElBQUlDLGdCQUFnQkMsaUJBQWlCLENBQUNQO1lBRXRELElBQUlRLFNBQVNQLFNBQVNRLGFBQWEsQ0FBQztZQUNwQyxJQUFJQyxNQUFNRixPQUFPRyxVQUFVLENBQUM7WUFDNUIsSUFBSUMsU0FBU0MsS0FBS0MsR0FBRyxJQUFJRCxLQUFLRSxTQUFTLElBQUlGO1lBQzNDLElBQUlHLE1BQU0sSUFBSUM7WUFDZCxJQUFJQyxNQUFNLElBQUlDLEtBQUs7Z0JBQUNkO2FBQVUsRUFBRTtnQkFBRWUsTUFBTTtZQUE4QjtZQUN0RSxJQUFJQyxNQUFNVCxPQUFPVSxlQUFlLENBQUNKO1lBQ2pDLElBQUlLO1lBQ0pQLElBQUlRLE1BQU0sR0FBRztnQkFDWGQsSUFBS2UsU0FBUyxDQUFDVCxLQUFLLEdBQUc7Z0JBQ3ZCTyxNQUFNZixPQUFPa0IsU0FBUyxDQUFDO2dCQUN2QmQsT0FBT2UsZUFBZSxDQUFDSjtZQUN6QjtZQUNBUCxJQUFJWSxHQUFHLEdBQUdQO1lBRVYsTUFBTVEsZUFBZTVCLFNBQVNRLGFBQWEsQ0FBQztZQUM1Q29CLGFBQWFDLElBQUksR0FBR1Q7WUFDcEJRLGFBQWFFLFFBQVEsR0FBRztZQUN4QkYsYUFBYUcsS0FBSztRQUNwQjtRQUdBLE1BQU1DLGNBQWNoQyxTQUFTQyxjQUFjLENBQUM7UUFDNUMrQix3QkFBQUEsa0NBQUFBLFlBQWE3QixnQkFBZ0IsQ0FBQyxTQUFTO1lBQ3JDLE1BQU9KLHVCQUFBQSxpQ0FBQUEsV0FBWWtDLFNBQVMsQ0FBRTtnQkFDNUJsQyxXQUFXbUMsV0FBVyxDQUFDbkMsV0FBV2tDLFNBQVM7WUFDN0M7UUFDRjtJQUdGLEdBQUcsRUFBRTtJQUVMLHFCQUNFLDhEQUFDRTtRQUFJQyxXQUFVOzswQkFDYiw4REFBQ0Q7Z0JBQUlDLFdBQVU7Z0JBQWlCQyxTQUFTNUM7MEJBQVk7Ozs7OzswQkFHckQsOERBQUMwQztnQkFBSUMsV0FBVTtnQkFBaUJDLFNBQVM1QzswQkFBWTs7Ozs7OzBCQUdyRCw4REFBQzBDO2dCQUFJQyxXQUFVO2dCQUFpQkUsSUFBRzswQkFBTzs7Ozs7OzBCQUcxQyw4REFBQ0g7Z0JBQUlDLFdBQVU7Z0JBQWlCRSxJQUFHOzBCQUFROzs7Ozs7MEJBRzNDLDhEQUFDSDtnQkFBSUMsV0FBVTtnQkFBaUJDLFNBQVNoRDswQkFBWTs7Ozs7OzBCQUdyRCw4REFBQzhDO2dCQUFJQyxXQUFVO2dCQUFpQkUsSUFBRzswQkFBYTs7Ozs7OzBCQUdoRCw4REFBQ0g7Z0JBQUlDLFdBQVU7Z0JBQWlCRSxJQUFHO2dCQUFhRCxTQUFTL0M7MEJBQVc7Ozs7Ozs7Ozs7OztBQUsxRTtHQXZFTUo7S0FBQUE7QUF5RU4sK0RBQWVBLE9BQU9BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2FwcC9fY29tcG9uZW50cy9Ub29sQmFyLnRzeD8yZjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuY29uc3QgVG9vbGJhciA9ICh7IHNlbGVjdFRvb2wsIHdlYnNvY2tldCwgY3JlYXRlUm9vbSwgbGVhdmVSb29tIH06e3NlbGVjdFRvb2w6KHRvb2w6c3RyaW5nKT0+dm9pZCwgd2Vic29ja2V0OldlYlNvY2tldHxudWxsLCBjcmVhdGVSb29tOigpPT52b2lkLCBsZWF2ZVJvb206KCk9PnZvaWR9KSA9PiB7XG5cbiAgY29uc3QgW2RyYXdpbmcsIHNldERyYXdpbmddID0gdXNlU3RhdGUoJycpO1xuXG4gIGNvbnN0IGNob29zZVRvb2wgPSAoZTpSZWFjdC5Nb3VzZUV2ZW50PEhUTUxFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IHRvb2wgPSAoZS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmlubmVySFRNTC50b0xvd2VyQ2FzZSgpO1xuICAgIHNlbGVjdFRvb2wodG9vbCk7XG4gIH07XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzdmdFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N2ZycpO1xuICAgIGNvbnN0IHNhdmVCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2F2ZScpO1xuICAgIHNhdmVCdXR0b24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgdmFyIHN2Z1N0cmluZyA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnRWxlbWVudCEpO1xuXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIHZhciBET01VUkwgPSBzZWxmLlVSTCB8fCBzZWxmLndlYmtpdFVSTCB8fCBzZWxmO1xuICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgdmFyIHN2ZyA9IG5ldyBCbG9iKFtzdmdTdHJpbmddLCB7IHR5cGU6IFwiaW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04XCIgfSk7XG4gICAgICB2YXIgdXJsID0gRE9NVVJMLmNyZWF0ZU9iamVjdFVSTChzdmcpO1xuICAgICAgdmFyIHBuZzogc3RyaW5nO1xuICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY3R4IS5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgICAgcG5nID0gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcbiAgICAgICAgRE9NVVJMLnJldm9rZU9iamVjdFVSTChwbmcpO1xuICAgICAgfTtcbiAgICAgIGltZy5zcmMgPSB1cmw7XG5cbiAgICAgIGNvbnN0IGRvd25sb2FkTEluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGRvd25sb2FkTEluay5ocmVmID0gdXJsO1xuICAgICAgZG93bmxvYWRMSW5rLmRvd25sb2FkID0gJ2RyYXdpbmcucG5nJztcbiAgICAgIGRvd25sb2FkTEluay5jbGljaygpO1xuICAgIH0pXG5cblxuICAgIGNvbnN0IHJlc2V0QnV0dG9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlc2V0Jyk7XG4gICAgcmVzZXRCdXR0b24/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgd2hpbGUgKHN2Z0VsZW1lbnQ/Lmxhc3RDaGlsZCkge1xuICAgICAgICBzdmdFbGVtZW50LnJlbW92ZUNoaWxkKHN2Z0VsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgIH1cbiAgICB9KVxuXG5cbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtcm93IGp1c3RpZnktY2VudGVyIHNwYWNlLXgtNSBjdXJzb3ItZGVmYXVsdCBmb250LWFtYXRpYyB0ZXh0LTJ4bFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjdXJzb3ItcG9pbnRlclwiIG9uQ2xpY2s9e2Nob29zZVRvb2x9PlxuICAgICAgICBSZWN0YW5nbGVcbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjdXJzb3ItcG9pbnRlclwiIG9uQ2xpY2s9e2Nob29zZVRvb2x9PlxuICAgICAgICBDaXJjbGVcbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9J2N1cnNvci1wb2ludGVyJyBpZD0nc2F2ZSc+XG4gICAgICAgIFNhdmVcbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9J2N1cnNvci1wb2ludGVyJyBpZD0ncmVzZXQnPlxuICAgICAgICBSZXNldFxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyXCIgb25DbGljaz17Y3JlYXRlUm9vbX0+XG4gICAgICAgIENyZWF0ZSBSb29tXG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY3Vyc29yLXBvaW50ZXJcIiBpZD0nb3Blbi1tb2RhbCc+XG4gICAgICAgIEpvaW4gcm9vbVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImN1cnNvci1wb2ludGVyXCIgaWQ9J2xlYXZlLXJvb20nIG9uQ2xpY2s9e2xlYXZlUm9vbX0+XG4gICAgICAgIExlYXZlIHJvb21cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhcjsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlRvb2xiYXIiLCJzZWxlY3RUb29sIiwid2Vic29ja2V0IiwiY3JlYXRlUm9vbSIsImxlYXZlUm9vbSIsImRyYXdpbmciLCJzZXREcmF3aW5nIiwiY2hvb3NlVG9vbCIsImUiLCJ0b29sIiwidGFyZ2V0IiwiaW5uZXJIVE1MIiwidG9Mb3dlckNhc2UiLCJzdmdFbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNhdmVCdXR0b24iLCJhZGRFdmVudExpc3RlbmVyIiwic3ZnU3RyaW5nIiwiWE1MU2VyaWFsaXplciIsInNlcmlhbGl6ZVRvU3RyaW5nIiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJET01VUkwiLCJzZWxmIiwiVVJMIiwid2Via2l0VVJMIiwiaW1nIiwiSW1hZ2UiLCJzdmciLCJCbG9iIiwidHlwZSIsInVybCIsImNyZWF0ZU9iamVjdFVSTCIsInBuZyIsIm9ubG9hZCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsInJldm9rZU9iamVjdFVSTCIsInNyYyIsImRvd25sb2FkTEluayIsImhyZWYiLCJkb3dubG9hZCIsImNsaWNrIiwicmVzZXRCdXR0b24iLCJsYXN0Q2hpbGQiLCJyZW1vdmVDaGlsZCIsImRpdiIsImNsYXNzTmFtZSIsIm9uQ2xpY2siLCJpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/_components/ToolBar.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/_components/WhiteBoard.tsx":
/*!********************************************!*\
  !*** ./src/app/_components/WhiteBoard.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ToolBar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ToolBar */ \"(app-pages-browser)/./src/app/_components/ToolBar.tsx\");\n/* harmony import */ var _People__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./People */ \"(app-pages-browser)/./src/app/_components/People.tsx\");\n/* harmony import */ var _Shapes_Rectangle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/Shapes/Rectangle */ \"(app-pages-browser)/./src/Shapes/Rectangle.ts\");\n/* harmony import */ var _Shapes_Circle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/Shapes/Circle */ \"(app-pages-browser)/./src/Shapes/Circle.ts\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _Modal_Modal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Modal/Modal */ \"(app-pages-browser)/./src/app/_components/Modal/Modal.tsx\");\n/* harmony import */ var _Modal_JoinRoomModal__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Modal/JoinRoomModal */ \"(app-pages-browser)/./src/app/_components/Modal/JoinRoomModal.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\nconst WhiteBoard = ()=>{\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        tool: null,\n        x2: 0,\n        y2: 0\n    });\n    const [isOpen, setisOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showRoomId, setshowRoomId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const roomID = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"0\");\n    const x1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const y1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const rectRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const circleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const name = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"\");\n    const [names, setNames] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([\n        \"\"\n    ]);\n    const roomNoInput = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(\"\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const queryParams = new URLSearchParams(window.location.search);\n        const btn = document.getElementById(\"open-modal\");\n        btn === null || btn === void 0 ? void 0 : btn.addEventListener(\"click\", ()=>{\n            setisOpen(true);\n        });\n        initWebSocket();\n        const svgElement = document.getElementById(\"svg\");\n        if (svgElement instanceof SVGSVGElement) {\n            const height = window.screen.height.toString();\n            const width = window.screen.width.toString();\n            svgElement.setAttribute(\"height\", height);\n            svgElement.setAttribute(\"width\", width);\n        } else {\n            console.error(\"The element is not an SVG element.\");\n        }\n        rectRef.current = new _Shapes_Rectangle__WEBPACK_IMPORTED_MODULE_4__[\"default\"](svgElement);\n        circleRef.current = new _Shapes_Circle__WEBPACK_IMPORTED_MODULE_5__[\"default\"](svgElement);\n        let moused = -1;\n        const mousedown = (event)=>{\n            if (moused === -1) {\n                x1.current = event.clientX;\n                y1.current = event.clientY;\n                if (state.tool) {\n                    svgElement === null || svgElement === void 0 ? void 0 : svgElement.addEventListener(\"mousemove\", mousemove);\n                    moused = setInterval(()=>whilemousedown(event), 1);\n                } else {\n                    alert(\"Select tool\");\n                }\n            }\n        };\n        const mouseup = (event)=>{\n            if (moused !== -1) {\n                var _state_tool;\n                clearInterval(moused);\n                (_state_tool = state.tool) === null || _state_tool === void 0 ? void 0 : _state_tool.makeShape(x1.current, y1.current, event.clientX - x1.current, event.clientY - y1.current);\n                setState((prevState)=>({\n                        ...prevState,\n                        x2: event.clientX,\n                        y2: event.clientY\n                    }));\n                let data;\n                let mes;\n                if (svgElement) {\n                    data = {\n                        x1: x1.current,\n                        x2: event.clientX,\n                        y1: y1.current,\n                        y2: event.clientY,\n                        tool: state.tool instanceof _Shapes_Rectangle__WEBPACK_IMPORTED_MODULE_4__[\"default\"] ? \"Rectangle\" : \"Circle\"\n                    };\n                }\n                if (socketRef.current && socketRef.current.readyState === WebSocket.OPEN) {\n                    mes = {\n                        data: JSON.stringify(data),\n                        type: \"request\",\n                        roomID: roomID.current,\n                        command: \"SEND DATA\",\n                        name: queryParams.get(\"name\")\n                    };\n                    socketRef.current.send(JSON.stringify(mes));\n                }\n                moused = -1;\n            }\n        };\n        const mousemove = (e)=>{\n            if (moused !== -1) {\n                var _state_tool;\n                (_state_tool = state.tool) === null || _state_tool === void 0 ? void 0 : _state_tool.showShape(x1.current, y1.current, e.clientX - x1.current, e.clientY - y1.current);\n            }\n        };\n        const whilemousedown = (event)=>{};\n        svgElement === null || svgElement === void 0 ? void 0 : svgElement.addEventListener(\"mousedown\", mousedown);\n        svgElement === null || svgElement === void 0 ? void 0 : svgElement.addEventListener(\"mouseup\", mouseup);\n        svgElement === null || svgElement === void 0 ? void 0 : svgElement.addEventListener(\"mouseout\", mouseup);\n        if (queryParams.has(\"roomId\")) {\n            setshowRoomId(true);\n        }\n        return ()=>{\n            svgElement === null || svgElement === void 0 ? void 0 : svgElement.removeEventListener(\"mousedown\", mousedown);\n            svgElement === null || svgElement === void 0 ? void 0 : svgElement.removeEventListener(\"mouseup\", mouseup);\n            svgElement === null || svgElement === void 0 ? void 0 : svgElement.removeEventListener(\"mouseout\", mouseup);\n        };\n    }, [\n        state.tool\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const searchParams = new URLSearchParams(window.location.search);\n        console.log(searchParams.get(\"roomId\"));\n        console.log(searchParams.get(\"name\"));\n        roomID.current = searchParams.get(\"roomId\");\n        name.current = searchParams.get(\"name\");\n        setNames([\n            name.current\n        ]);\n    }, []);\n    const initWebSocket = ()=>{\n        const socket = new WebSocket(\"wss://ideaflow-websocket-server.onrender.com\");\n        socketRef.current = socket;\n        socket.onopen = ()=>{\n            console.log(\"connected to websocket\");\n            console.log(socket.OPEN);\n        };\n        let mes = {\n            type: \"request\",\n            command: \"SEND NAMES\",\n            roomID: roomID.current,\n            data: \"\",\n            name: name.current\n        };\n        socket.addEventListener(\"open\", ()=>{\n            if (queryParams.has(\"roomId\")) {\n                socket.send(JSON.stringify(mes));\n            }\n        });\n        const queryParams = new URLSearchParams(window.location.search);\n        socket.onmessage = (ev)=>{\n            const mes = JSON.parse(ev.data);\n            if (mes.type === \"response\") {\n                switch(mes.command){\n                    case \"ROOM CREATED\":\n                        roomID.current = mes.roomID;\n                        queryParams.set(\"roomId\", mes.roomID);\n                        setshowRoomId(true);\n                        router.push(\"/whiteboard?\".concat(queryParams));\n                        break;\n                    case \"FULL SERVER\":\n                        alert(\"Sorry Server is full\");\n                        break;\n                    case \"JOINED ROOM\":\n                        if (queryParams.has(\"roomId\")) {\n                            queryParams.delete(\"roomId\");\n                        }\n                        queryParams.append(\"roomId\", \"\".concat(mes.roomID));\n                        router.push(\"/whiteboard?\".concat(queryParams));\n                        roomID.current = mes.roomID;\n                        setshowRoomId(true);\n                        break;\n                    case \"LEFT ROOM\":\n                        if (mes.name) {\n                            let n = mes.name.split(\",\");\n                            if (n.includes(name.current)) {\n                                setNames(n);\n                            } else {\n                                setNames([\n                                    name.current\n                                ]);\n                            }\n                        } else {\n                            setNames([\n                                name.current\n                            ]);\n                        }\n                        queryParams.delete(\"roomId\");\n                        setshowRoomId(false);\n                        router.push(\"/whiteboard?\".concat(queryParams));\n                        break;\n                    case \"DRAWING DATA\":\n                        const drawData = JSON.parse(mes.data);\n                        executeMessage(drawData);\n                        break;\n                    case \"USERNAMES\":\n                        if (mes.name) {\n                            const n = mes.name.split(\",\");\n                            if (n.includes(name.current)) {\n                                setNames(mes.name.split(\",\"));\n                            } else {\n                                setNames([\n                                    name.current\n                                ]);\n                            }\n                        }\n                        break;\n                }\n            }\n        };\n    };\n    const executeMessage = (data)=>{\n        console.log(\"making shapes\", data);\n        switch(data.tool){\n            case \"Rectangle\":\n                var _rectRef_current;\n                (_rectRef_current = rectRef.current) === null || _rectRef_current === void 0 ? void 0 : _rectRef_current.makeShape(data.x1, data.y1, data.x2 - data.x1, data.y2 - data.y1);\n                break;\n            case \"Circle\":\n                var _circleRef_current;\n                (_circleRef_current = circleRef.current) === null || _circleRef_current === void 0 ? void 0 : _circleRef_current.makeShape(data.x1, data.y1, data.x2 - data.x1, data.y2 - data.y1);\n                break;\n        }\n    };\n    const selecttheTool = (tool)=>{\n        console.log(\"the selected tool is \", tool);\n        if (tool === \"rectangle\") {\n            setState((prevState)=>({\n                    ...prevState,\n                    tool: rectRef.current\n                }));\n        } else if (tool === \"circle\") {\n            setState((prevState)=>({\n                    ...prevState,\n                    tool: circleRef.current\n                }));\n        }\n    };\n    const createRoom = ()=>{\n        var _socketRef_current, _socketRef_current1;\n        let mes = {\n            type: \"request\",\n            command: \"CREATE ROOM\",\n            roomID: \"0\",\n            data: \"\",\n            name: name.current\n        };\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.send(JSON.stringify(mes));\n        let mes1 = {\n            type: \"request\",\n            command: \"SEND NAMES\",\n            roomID: roomID.current,\n            data: \"\",\n            name: name.current\n        };\n        (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.send(JSON.stringify(mes1));\n    };\n    const leaveRoom = ()=>{\n        var _socketRef_current, _socketRef_current1;\n        let mes = {\n            type: \"request\",\n            command: \"LEAVE ROOM\",\n            roomID: roomID.current,\n            data: \"\",\n            name: name.current\n        };\n        (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.send(JSON.stringify(mes));\n        let mes1 = {\n            type: \"request\",\n            command: \"SEND NAMES\",\n            roomID: roomID.current,\n            data: \"\",\n            name: name.current\n        };\n        (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.send(JSON.stringify(mes1));\n    };\n    const getRoomNo = ()=>{\n        console.log(roomNoInput.current);\n        if (roomNoInput.current !== undefined) {\n            console.log(socketRef.current, \"\", roomNoInput.current);\n            const message = {\n                type: \"request\",\n                command: \"JOIN ROOM\",\n                roomID: roomNoInput.current,\n                data: \"\",\n                name: name.current\n            };\n            socketRef.current.send(JSON.stringify(message));\n            let mes1 = {\n                type: \"request\",\n                command: \"SEND NAMES\",\n                roomID: roomNoInput.current,\n                data: \"\",\n                name: name.current\n            };\n            socketRef.current.send(JSON.stringify(mes1));\n            handleClose();\n        } else {\n            alert(\"Enter Room No\");\n        }\n    };\n    const handleClose = ()=>{\n        let dull = document.getElementById(\"dull\");\n        while(dull){\n            var _dull_parentNode;\n            (_dull_parentNode = dull.parentNode) === null || _dull_parentNode === void 0 ? void 0 : _dull_parentNode.removeChild(dull);\n            dull = document.getElementById(\"dull\");\n        }\n        setisOpen(false);\n    };\n    const getInput = ()=>{\n        const roomINput = document.getElementById(\"room-number\");\n        roomNoInput.current = roomINput.value;\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"relative\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: showRoomId && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"absolute top-0 left-0 font-amatic text-3xl\",\n                    children: [\n                        \"Room Id:\",\n                        roomID.current\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                    lineNumber: 382,\n                    columnNumber: 25\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                lineNumber: 379,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-x-0 top-0 flex items-center justify-center min-h-24\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ToolBar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                    selectTool: selecttheTool,\n                    websocket: socketRef.current,\n                    createRoom: createRoom,\n                    leaveRoom: leaveRoom\n                }, void 0, false, {\n                    fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                    lineNumber: 390,\n                    columnNumber: 17\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                lineNumber: 389,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n                id: \"svg\",\n                className: \"border border-grey bg-green-200\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"rect\", {\n                    width: \"100%\",\n                    height: \"100%\",\n                    fill: \"#bbf7d0\"\n                }, void 0, false, {\n                    fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                    lineNumber: 393,\n                    columnNumber: 17\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                lineNumber: 392,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col items-end p-2 cursor-default border border-grey absolute bottom-0 right-0\",\n                children: names.map((n)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_People__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        index: n\n                    }, n, false, {\n                        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                        lineNumber: 397,\n                        columnNumber: 21\n                    }, undefined))\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                lineNumber: 395,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Modal_Modal__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                handleClose: handleClose,\n                isOpen: isOpen,\n                handleEnter: getRoomNo,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Modal_JoinRoomModal__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                    socket: socketRef.current,\n                    name: name.current,\n                    getRoomNo: getRoomNo,\n                    getInput: getInput\n                }, void 0, false, {\n                    fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                    lineNumber: 404,\n                    columnNumber: 17\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n                lineNumber: 400,\n                columnNumber: 13\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/_components/WhiteBoard.tsx\",\n        lineNumber: 378,\n        columnNumber: 9\n    }, undefined);\n};\n_s(WhiteBoard, \"5JpDpTTSw1mdlFJnsL6YqLF5uXA=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_6__.useRouter\n    ];\n});\n_c = WhiteBoard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (WhiteBoard);\nvar _c;\n$RefreshReg$(_c, \"WhiteBoard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvX2NvbXBvbmVudHMvV2hpdGVCb2FyZC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUMyRDtBQUMzQjtBQUNGO0FBRWE7QUFDTjtBQUNPO0FBQ1Y7QUFDZ0I7QUF3QmxELE1BQU1XLGFBQXVCOztJQUV6QixNQUFNQyxTQUFTSiwwREFBU0E7SUFDeEIsTUFBTSxDQUFDSyxPQUFPQyxTQUFTLEdBQUdaLCtDQUFRQSxDQUFRO1FBQ3RDYSxNQUFNO1FBQ05DLElBQUk7UUFDSkMsSUFBSTtJQUNSO0lBQ0EsTUFBTSxDQUFDQyxRQUFRQyxVQUFVLEdBQUdqQiwrQ0FBUUEsQ0FBQztJQUNyQyxNQUFNLENBQUNrQixZQUFZQyxjQUFjLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNb0IsU0FBU25CLDZDQUFNQSxDQUFnQjtJQUVyQyxNQUFNb0IsS0FBS3BCLDZDQUFNQSxDQUFTO0lBQzFCLE1BQU1xQixLQUFLckIsNkNBQU1BLENBQVM7SUFFMUIsTUFBTXNCLFVBQVV0Qiw2Q0FBTUEsQ0FBbUI7SUFDekMsTUFBTXVCLFlBQVl2Qiw2Q0FBTUEsQ0FBZ0I7SUFDeEMsTUFBTXdCLFlBQVl4Qiw2Q0FBTUEsQ0FBbUI7SUFDM0MsTUFBTXlCLE9BQU96Qiw2Q0FBTUEsQ0FBQztJQUNwQixNQUFNLENBQUMwQixPQUFPQyxTQUFTLEdBQUc1QiwrQ0FBUUEsQ0FBQztRQUFDO0tBQUc7SUFDdkMsTUFBTTZCLGNBQVk1Qiw2Q0FBTUEsQ0FBQztJQUl6QkYsZ0RBQVNBLENBQUM7UUFDTixNQUFNK0IsY0FBK0IsSUFBSUMsZ0JBQWdCQyxPQUFPQyxRQUFRLENBQUNDLE1BQU07UUFFL0UsTUFBTUMsTUFBTUMsU0FBU0MsY0FBYyxDQUFDO1FBQ3BDRixnQkFBQUEsMEJBQUFBLElBQUtHLGdCQUFnQixDQUFDLFNBQVM7WUFDM0JyQixVQUFVO1FBQ2Q7UUFFQXNCO1FBQ0EsTUFBTUMsYUFBYUosU0FBU0MsY0FBYyxDQUFDO1FBQzNDLElBQUlHLHNCQUFzQkMsZUFBZTtZQUNyQyxNQUFNQyxTQUFTLE9BQVFDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFFRSxRQUFRO1lBQzlDLE1BQU1DLFFBQVEsT0FBUUYsTUFBTSxDQUFDRSxLQUFLLENBQUVELFFBQVE7WUFDNUNKLFdBQVdNLFlBQVksQ0FBQyxVQUFVSjtZQUNsQ0YsV0FBV00sWUFBWSxDQUFDLFNBQVNEO1FBQ3JDLE9BQU87WUFDSEUsUUFBUUMsS0FBSyxDQUFDO1FBQ2xCO1FBRUF6QixRQUFRMEIsT0FBTyxHQUFHLElBQUk3Qyx5REFBU0EsQ0FBQ29DO1FBQ2hDaEIsVUFBVXlCLE9BQU8sR0FBRyxJQUFJNUMsc0RBQU1BLENBQUNtQztRQUUvQixJQUFJVSxTQUFrQyxDQUFDO1FBRXZDLE1BQU1DLFlBQVksQ0FBQ0M7WUFDZixJQUFJRixXQUFXLENBQUMsR0FBRztnQkFDZjdCLEdBQUc0QixPQUFPLEdBQUdHLE1BQU1DLE9BQU87Z0JBQzFCL0IsR0FBRzJCLE9BQU8sR0FBR0csTUFBTUUsT0FBTztnQkFDMUIsSUFBSTNDLE1BQU1FLElBQUksRUFBRTtvQkFDWjJCLHVCQUFBQSxpQ0FBQUEsV0FBWUYsZ0JBQWdCLENBQUMsYUFBYWlCO29CQUMxQ0wsU0FBU00sWUFBWSxJQUFNQyxlQUFlTCxRQUFRO2dCQUN0RCxPQUFPO29CQUNITSxNQUFNO2dCQUNWO1lBQ0o7UUFDSjtRQUVBLE1BQU1DLFVBQVUsQ0FBQ1A7WUFDYixJQUFJRixXQUFXLENBQUMsR0FBRztvQkFFZnZDO2dCQURBaUQsY0FBY1Y7aUJBQ2R2QyxjQUFBQSxNQUFNRSxJQUFJLGNBQVZGLGtDQUFBQSxZQUFZa0QsU0FBUyxDQUFDeEMsR0FBRzRCLE9BQU8sRUFBRTNCLEdBQUcyQixPQUFPLEVBQUVHLE1BQU1DLE9BQU8sR0FBR2hDLEdBQUc0QixPQUFPLEVBQUVHLE1BQU1FLE9BQU8sR0FBR2hDLEdBQUcyQixPQUFPO2dCQUNwR3JDLFNBQVMsQ0FBQ2tELFlBQWU7d0JBQ3JCLEdBQUdBLFNBQVM7d0JBQ1poRCxJQUFJc0MsTUFBTUMsT0FBTzt3QkFDakJ0QyxJQUFJcUMsTUFBTUUsT0FBTztvQkFDckI7Z0JBRUEsSUFBSVM7Z0JBQ0osSUFBSUM7Z0JBQ0osSUFBSXhCLFlBQVk7b0JBQ1p1QixPQUFPO3dCQUNIMUMsSUFBSUEsR0FBRzRCLE9BQU87d0JBQ2RuQyxJQUFJc0MsTUFBTUMsT0FBTzt3QkFDakIvQixJQUFJQSxHQUFHMkIsT0FBTzt3QkFDZGxDLElBQUlxQyxNQUFNRSxPQUFPO3dCQUNqQnpDLE1BQU1GLE1BQU1FLElBQUksWUFBWVQseURBQVNBLEdBQUcsY0FBYztvQkFDMUQ7Z0JBQ0o7Z0JBRUEsSUFBSXFCLFVBQVV3QixPQUFPLElBQUl4QixVQUFVd0IsT0FBTyxDQUFDZ0IsVUFBVSxLQUFLQyxVQUFVQyxJQUFJLEVBQUU7b0JBQ3RFSCxNQUFNO3dCQUNGRCxNQUFNSyxLQUFLQyxTQUFTLENBQUNOO3dCQUNyQk8sTUFBTTt3QkFDTmxELFFBQVFBLE9BQU82QixPQUFPO3dCQUN0QnNCLFNBQVM7d0JBQ1Q3QyxNQUFNSSxZQUFZMEMsR0FBRyxDQUFDO29CQUMxQjtvQkFDQS9DLFVBQVV3QixPQUFPLENBQUN3QixJQUFJLENBQUNMLEtBQUtDLFNBQVMsQ0FBQ0w7Z0JBQzFDO2dCQUNBZCxTQUFTLENBQUM7WUFDZDtRQUNKO1FBRUEsTUFBTUssWUFBWSxDQUFDbUI7WUFDZixJQUFJeEIsV0FBVyxDQUFDLEdBQUc7b0JBQ2Z2QztpQkFBQUEsY0FBQUEsTUFBTUUsSUFBSSxjQUFWRixrQ0FBQUEsWUFBWWdFLFNBQVMsQ0FBQ3RELEdBQUc0QixPQUFPLEVBQUUzQixHQUFHMkIsT0FBTyxFQUFFeUIsRUFBRXJCLE9BQU8sR0FBR2hDLEdBQUc0QixPQUFPLEVBQUV5QixFQUFFcEIsT0FBTyxHQUFHaEMsR0FBRzJCLE9BQU87WUFDaEc7UUFDSjtRQUVBLE1BQU1RLGlCQUFpQixDQUFDTCxTQUN4QjtRQUVBWix1QkFBQUEsaUNBQUFBLFdBQVlGLGdCQUFnQixDQUFDLGFBQWFhO1FBQzFDWCx1QkFBQUEsaUNBQUFBLFdBQVlGLGdCQUFnQixDQUFDLFdBQVdxQjtRQUN4Q25CLHVCQUFBQSxpQ0FBQUEsV0FBWUYsZ0JBQWdCLENBQUMsWUFBWXFCO1FBRXpDLElBQUk3QixZQUFZOEMsR0FBRyxDQUFDLFdBQVc7WUFDM0J6RCxjQUFjO1FBQ2xCO1FBRUEsT0FBTztZQUNIcUIsdUJBQUFBLGlDQUFBQSxXQUFZcUMsbUJBQW1CLENBQUMsYUFBYTFCO1lBQzdDWCx1QkFBQUEsaUNBQUFBLFdBQVlxQyxtQkFBbUIsQ0FBQyxXQUFXbEI7WUFDM0NuQix1QkFBQUEsaUNBQUFBLFdBQVlxQyxtQkFBbUIsQ0FBQyxZQUFZbEI7UUFDaEQ7SUFDSixHQUFFO1FBQUNoRCxNQUFNRSxJQUFJO0tBQUM7SUFJZGQsZ0RBQVNBLENBQUM7UUFDTixNQUFNK0UsZUFBZ0MsSUFBSS9DLGdCQUFnQkMsT0FBT0MsUUFBUSxDQUFDQyxNQUFNO1FBRWhGYSxRQUFRZ0MsR0FBRyxDQUFDRCxhQUFhTixHQUFHLENBQUM7UUFDN0J6QixRQUFRZ0MsR0FBRyxDQUFDRCxhQUFhTixHQUFHLENBQUM7UUFFN0JwRCxPQUFPNkIsT0FBTyxHQUFHNkIsYUFBYU4sR0FBRyxDQUFDO1FBQ2xDOUMsS0FBS3VCLE9BQU8sR0FBRzZCLGFBQWFOLEdBQUcsQ0FBQztRQUNoQzVDLFNBQVM7WUFBQ0YsS0FBS3VCLE9BQU87U0FBQztJQUMzQixHQUFHLEVBQUU7SUFLTCxNQUFNVixnQkFBZ0I7UUFDbEIsTUFBTXlDLFNBQVMsSUFBSWQsVUFBVTtRQUM3QnpDLFVBQVV3QixPQUFPLEdBQUcrQjtRQUVwQkEsT0FBT0MsTUFBTSxHQUFHO1lBQ1psQyxRQUFRZ0MsR0FBRyxDQUFDO1lBQ1poQyxRQUFRZ0MsR0FBRyxDQUFDQyxPQUFPYixJQUFJO1FBQzNCO1FBRUEsSUFBSUgsTUFBZTtZQUNmTSxNQUFNO1lBQ05DLFNBQVM7WUFDVG5ELFFBQVFBLE9BQU82QixPQUFPO1lBQ3RCYyxNQUFNO1lBQ05yQyxNQUFNQSxLQUFLdUIsT0FBTztRQUN0QjtRQUVBK0IsT0FBTzFDLGdCQUFnQixDQUFDLFFBQVE7WUFDNUIsSUFBSVIsWUFBWThDLEdBQUcsQ0FBQyxXQUFXO2dCQUMzQkksT0FBT1AsSUFBSSxDQUFDTCxLQUFLQyxTQUFTLENBQUNMO1lBQy9CO1FBQ0o7UUFFQSxNQUFNbEMsY0FBYyxJQUFJQyxnQkFBZ0JDLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTTtRQUU5RDhDLE9BQU9FLFNBQVMsR0FBRyxDQUFDQztZQUNoQixNQUFNbkIsTUFBZUksS0FBS2dCLEtBQUssQ0FBQ0QsR0FBR3BCLElBQUk7WUFDdkMsSUFBSUMsSUFBSU0sSUFBSSxLQUFLLFlBQVk7Z0JBRXpCLE9BQVFOLElBQUlPLE9BQU87b0JBQ2YsS0FBSzt3QkFDRG5ELE9BQU82QixPQUFPLEdBQUdlLElBQUk1QyxNQUFNO3dCQUMzQlUsWUFBWXVELEdBQUcsQ0FBQyxVQUFVckIsSUFBSTVDLE1BQU07d0JBQ3BDRCxjQUFjO3dCQUNkVCxPQUFPNEUsSUFBSSxDQUFDLGVBQTJCLE9BQVp4RDt3QkFDM0I7b0JBRUosS0FBSzt3QkFDRDRCLE1BQU07d0JBQ047b0JBRUosS0FBSzt3QkFDRCxJQUFJNUIsWUFBWThDLEdBQUcsQ0FBQyxXQUFXOzRCQUMzQjlDLFlBQVl5RCxNQUFNLENBQUM7d0JBQ3ZCO3dCQUNBekQsWUFBWTBELE1BQU0sQ0FBQyxVQUFVLEdBQWMsT0FBWHhCLElBQUk1QyxNQUFNO3dCQUUxQ1YsT0FBTzRFLElBQUksQ0FBQyxlQUEyQixPQUFaeEQ7d0JBQzNCVixPQUFPNkIsT0FBTyxHQUFHZSxJQUFJNUMsTUFBTTt3QkFDM0JELGNBQWM7d0JBQ2Q7b0JBRUosS0FBSzt3QkFDRCxJQUFJNkMsSUFBSXRDLElBQUksRUFBRTs0QkFDVixJQUFJK0QsSUFBSXpCLElBQUl0QyxJQUFJLENBQUNnRSxLQUFLLENBQUM7NEJBQ3ZCLElBQUlELEVBQUVFLFFBQVEsQ0FBQ2pFLEtBQUt1QixPQUFPLEdBQUc7Z0NBQzFCckIsU0FBUzZEOzRCQUNiLE9BQ0s7Z0NBQ0Q3RCxTQUFTO29DQUFDRixLQUFLdUIsT0FBTztpQ0FBQzs0QkFDM0I7d0JBQ0osT0FDSzs0QkFDRHJCLFNBQVM7Z0NBQUNGLEtBQUt1QixPQUFPOzZCQUFDO3dCQUMzQjt3QkFDQW5CLFlBQVl5RCxNQUFNLENBQUM7d0JBQ25CcEUsY0FBYzt3QkFDZFQsT0FBTzRFLElBQUksQ0FBQyxlQUEyQixPQUFaeEQ7d0JBQzNCO29CQUVKLEtBQUs7d0JBQ0QsTUFBTThELFdBQVd4QixLQUFLZ0IsS0FBSyxDQUFDcEIsSUFBSUQsSUFBSTt3QkFDcEM4QixlQUFlRDt3QkFDZjtvQkFFSixLQUFLO3dCQUNELElBQUk1QixJQUFJdEMsSUFBSSxFQUFFOzRCQUNWLE1BQU0rRCxJQUFJekIsSUFBSXRDLElBQUksQ0FBQ2dFLEtBQUssQ0FBQzs0QkFDekIsSUFBSUQsRUFBRUUsUUFBUSxDQUFDakUsS0FBS3VCLE9BQU8sR0FBRztnQ0FDMUJyQixTQUFTb0MsSUFBSXRDLElBQUksQ0FBQ2dFLEtBQUssQ0FBQzs0QkFDNUIsT0FDSztnQ0FDRDlELFNBQVM7b0NBQUNGLEtBQUt1QixPQUFPO2lDQUFDOzRCQUMzQjt3QkFDSjt3QkFDQTtnQkFDUjtZQUNKO1FBQ0o7SUFDSjtJQUVBLE1BQU00QyxpQkFBaUIsQ0FBQzlCO1FBQ3BCaEIsUUFBUWdDLEdBQUcsQ0FBQyxpQkFBaUJoQjtRQUM3QixPQUFRQSxLQUFLbEQsSUFBSTtZQUNiLEtBQUs7b0JBQ0RVO2lCQUFBQSxtQkFBQUEsUUFBUTBCLE9BQU8sY0FBZjFCLHVDQUFBQSxpQkFBaUJzQyxTQUFTLENBQUNFLEtBQUsxQyxFQUFFLEVBQUUwQyxLQUFLekMsRUFBRSxFQUFFeUMsS0FBS2pELEVBQUUsR0FBR2lELEtBQUsxQyxFQUFFLEVBQUUwQyxLQUFLaEQsRUFBRSxHQUFHZ0QsS0FBS3pDLEVBQUU7Z0JBQ2pGO1lBQ0osS0FBSztvQkFDREU7aUJBQUFBLHFCQUFBQSxVQUFVeUIsT0FBTyxjQUFqQnpCLHlDQUFBQSxtQkFBbUJxQyxTQUFTLENBQUNFLEtBQUsxQyxFQUFFLEVBQUUwQyxLQUFLekMsRUFBRSxFQUFFeUMsS0FBS2pELEVBQUUsR0FBR2lELEtBQUsxQyxFQUFFLEVBQUUwQyxLQUFLaEQsRUFBRSxHQUFHZ0QsS0FBS3pDLEVBQUU7Z0JBQ25GO1FBQ1I7SUFDSjtJQUVBLE1BQU13RSxnQkFBZ0IsQ0FBQ2pGO1FBQ25Ca0MsUUFBUWdDLEdBQUcsQ0FBQyx5QkFBeUJsRTtRQUNyQyxJQUFJQSxTQUFTLGFBQWE7WUFDdEJELFNBQVMsQ0FBQ2tELFlBQWU7b0JBQ3JCLEdBQUdBLFNBQVM7b0JBQ1pqRCxNQUFNVSxRQUFRMEIsT0FBTztnQkFDekI7UUFDSixPQUFPLElBQUlwQyxTQUFTLFVBQVU7WUFDMUJELFNBQVMsQ0FBQ2tELFlBQWU7b0JBQ3JCLEdBQUdBLFNBQVM7b0JBQ1pqRCxNQUFNVyxVQUFVeUIsT0FBTztnQkFDM0I7UUFDSjtJQUNKO0lBRUEsTUFBTThDLGFBQWE7WUFTZnRFLG9CQVNBQTtRQWpCQSxJQUFJdUMsTUFBZTtZQUNmTSxNQUFNO1lBQ05DLFNBQVM7WUFDVG5ELFFBQVE7WUFDUjJDLE1BQU07WUFDTnJDLE1BQU1BLEtBQUt1QixPQUFPO1FBQ3RCO1NBRUF4QixxQkFBQUEsVUFBVXdCLE9BQU8sY0FBakJ4Qix5Q0FBQUEsbUJBQW1CZ0QsSUFBSSxDQUFDTCxLQUFLQyxTQUFTLENBQUNMO1FBRXZDLElBQUlnQyxPQUFnQjtZQUNoQjFCLE1BQU07WUFDTkMsU0FBUztZQUNUbkQsUUFBUUEsT0FBTzZCLE9BQU87WUFDdEJjLE1BQU07WUFDTnJDLE1BQU1BLEtBQUt1QixPQUFPO1FBQ3RCO1NBQ0F4QixzQkFBQUEsVUFBVXdCLE9BQU8sY0FBakJ4QiwwQ0FBQUEsb0JBQW1CZ0QsSUFBSSxDQUFDTCxLQUFLQyxTQUFTLENBQUMyQjtJQUUzQztJQUVBLE1BQU1DLFlBQVk7WUFRZHhFLG9CQVNBQTtRQWhCQSxJQUFJdUMsTUFBZTtZQUNmTSxNQUFNO1lBQ05DLFNBQVM7WUFDVG5ELFFBQVFBLE9BQU82QixPQUFPO1lBQ3RCYyxNQUFNO1lBQ05yQyxNQUFNQSxLQUFLdUIsT0FBTztRQUN0QjtTQUNBeEIscUJBQUFBLFVBQVV3QixPQUFPLGNBQWpCeEIseUNBQUFBLG1CQUFtQmdELElBQUksQ0FBQ0wsS0FBS0MsU0FBUyxDQUFDTDtRQUV2QyxJQUFJZ0MsT0FBZ0I7WUFDaEIxQixNQUFNO1lBQ05DLFNBQVM7WUFDVG5ELFFBQVFBLE9BQU82QixPQUFPO1lBQ3RCYyxNQUFNO1lBQ05yQyxNQUFNQSxLQUFLdUIsT0FBTztRQUN0QjtTQUNBeEIsc0JBQUFBLFVBQVV3QixPQUFPLGNBQWpCeEIsMENBQUFBLG9CQUFtQmdELElBQUksQ0FBQ0wsS0FBS0MsU0FBUyxDQUFDMkI7SUFFM0M7SUFHQSxNQUFNRSxZQUFZO1FBQ2RuRCxRQUFRZ0MsR0FBRyxDQUFDbEQsWUFBWW9CLE9BQU87UUFDL0IsSUFBSXBCLFlBQVlvQixPQUFPLEtBQUtrRCxXQUFXO1lBQ25DcEQsUUFBUWdDLEdBQUcsQ0FBQ3RELFVBQVV3QixPQUFPLEVBQUUsSUFBSXBCLFlBQVlvQixPQUFPO1lBQ3RELE1BQU1tRCxVQUFVO2dCQUNaOUIsTUFBTTtnQkFDTkMsU0FBUztnQkFDVG5ELFFBQVFTLFlBQVlvQixPQUFPO2dCQUMzQmMsTUFBTTtnQkFDTnJDLE1BQU1BLEtBQUt1QixPQUFPO1lBQ3RCO1lBQ0F4QixVQUFVd0IsT0FBTyxDQUFFd0IsSUFBSSxDQUFDTCxLQUFLQyxTQUFTLENBQUMrQjtZQUV2QyxJQUFJSixPQUFPO2dCQUNQMUIsTUFBTTtnQkFDTkMsU0FBUztnQkFDVG5ELFFBQVFTLFlBQVlvQixPQUFPO2dCQUMzQmMsTUFBTTtnQkFDTnJDLE1BQU1BLEtBQUt1QixPQUFPO1lBQ3RCO1lBQ0F4QixVQUFVd0IsT0FBTyxDQUFFd0IsSUFBSSxDQUFDTCxLQUFLQyxTQUFTLENBQUMyQjtZQUN2Q0s7UUFFSixPQUNLO1lBQ0QzQyxNQUFNO1FBQ1Y7SUFDSjtJQUVBLE1BQU0yQyxjQUFjO1FBQ2hCLElBQUlDLE9BQU9sRSxTQUFTQyxjQUFjLENBQUM7UUFDbkMsTUFBT2lFLEtBQU07Z0JBQ1RBO2FBQUFBLG1CQUFBQSxLQUFLQyxVQUFVLGNBQWZELHVDQUFBQSxpQkFBaUJFLFdBQVcsQ0FBQ0Y7WUFDN0JBLE9BQU9sRSxTQUFTQyxjQUFjLENBQUM7UUFDbkM7UUFDQXBCLFVBQVU7SUFDZDtJQUVBLE1BQU13RixXQUFXO1FBQ2IsTUFBTUMsWUFBVXRFLFNBQVNDLGNBQWMsQ0FBQztRQUN4Q1IsWUFBWW9CLE9BQU8sR0FBQ3lELFVBQVVDLEtBQUs7SUFDdkM7SUFHQSxxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTs7MEJBQ1gsOERBQUNEOzBCQUNJMUYsNEJBRU8sOERBQUMwRjtvQkFBSUMsV0FBVTs7d0JBQTZDO3dCQUMvQ3pGLE9BQU82QixPQUFPOzs7Ozs7Ozs7Ozs7MEJBTXZDLDhEQUFDMkQ7Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUMzRyxnREFBT0E7b0JBQUM0RyxZQUFZaEI7b0JBQWVpQixXQUFXdEYsVUFBVXdCLE9BQU87b0JBQUU4QyxZQUFZQTtvQkFBWUUsV0FBV0E7Ozs7Ozs7Ozs7OzBCQUV6Ryw4REFBQ2U7Z0JBQUlDLElBQUc7Z0JBQU1KLFdBQVU7MEJBQ3BCLDRFQUFDSztvQkFBS3JFLE9BQU07b0JBQU9ILFFBQU87b0JBQU95RSxNQUFLOzs7Ozs7Ozs7OzswQkFFMUMsOERBQUNQO2dCQUFJQyxXQUFVOzBCQUNWbEYsTUFBTXlGLEdBQUcsQ0FBQyxDQUFDM0Isa0JBQ1IsOERBQUN0RiwrQ0FBTUE7d0JBQVNrSCxPQUFPNUI7dUJBQVZBOzs7Ozs7Ozs7OzBCQUdyQiw4REFBQ2xGLG9EQUFLQTtnQkFBQzhGLGFBQWFBO2dCQUNuQnJGLFFBQVFBO2dCQUNSc0csYUFBYXBCOzBCQUVWLDRFQUFDMUYsNERBQWFBO29CQUFDd0UsUUFBUXZELFVBQVV3QixPQUFPO29CQUFHdkIsTUFBTUEsS0FBS3VCLE9BQU87b0JBQUVpRCxXQUFXQTtvQkFBV08sVUFBVUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSS9HO0dBdFhNaEc7O1FBRWFILHNEQUFTQTs7O0tBRnRCRztBQXdYTiwrREFBZUEsVUFBVUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL19jb21wb25lbnRzL1doaXRlQm9hcmQudHN4P2RjYjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRvb2xCYXIgZnJvbSAnLi9Ub29sQmFyJztcbmltcG9ydCBQZW9wbGUgZnJvbSAnLi9QZW9wbGUnO1xuaW1wb3J0IFNoYXBlIGZyb20gJ0AvU2hhcGVzL1NoYXBlcyc7XG5pbXBvcnQgUmVjdGFuZ2xlIGZyb20gJ0AvU2hhcGVzL1JlY3RhbmdsZSc7XG5pbXBvcnQgQ2lyY2xlIGZyb20gJ0AvU2hhcGVzL0NpcmNsZSc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L25hdmlnYXRpb24nO1xuaW1wb3J0IE1vZGFsIGZyb20gJy4vTW9kYWwvTW9kYWwnO1xuaW1wb3J0IEpvaW5Sb29tTW9kYWwgZnJvbSAnLi9Nb2RhbC9Kb2luUm9vbU1vZGFsJztcblxuaW50ZXJmYWNlIFN0YXRlIHtcbiAgICB0b29sOiBTaGFwZSB8IG51bGw7XG4gICAgeDI6IG51bWJlcjtcbiAgICB5MjogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIHJvb21JRDogc3RyaW5nIHwgbnVsbDtcbiAgICBkYXRhOiBzdHJpbmc7XG4gICAgY29tbWFuZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgRHJhd0RhdGEge1xuICAgIHgxOiBudW1iZXIsXG4gICAgeDI6IG51bWJlcixcbiAgICB5MTogbnVtYmVyLFxuICAgIHkyOiBudW1iZXIsXG4gICAgdG9vbDogc3RyaW5nLFxufVxuXG5jb25zdCBXaGl0ZUJvYXJkOiBSZWFjdC5GQyA9ICgpID0+IHtcblxuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICAgIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGU8U3RhdGU+KHtcbiAgICAgICAgdG9vbDogbnVsbCxcbiAgICAgICAgeDI6IDAsXG4gICAgICAgIHkyOiAwLFxuICAgIH0pO1xuICAgIGNvbnN0IFtpc09wZW4sIHNldGlzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Nob3dSb29tSWQsIHNldHNob3dSb29tSWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHJvb21JRCA9IHVzZVJlZjxzdHJpbmcgfCBudWxsPignMCcpO1xuXG4gICAgY29uc3QgeDEgPSB1c2VSZWY8bnVtYmVyPigwKTtcbiAgICBjb25zdCB5MSA9IHVzZVJlZjxudW1iZXI+KDApO1xuXG4gICAgY29uc3QgcmVjdFJlZiA9IHVzZVJlZjxSZWN0YW5nbGUgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBjaXJjbGVSZWYgPSB1c2VSZWY8Q2lyY2xlIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3Qgc29ja2V0UmVmID0gdXNlUmVmPFdlYlNvY2tldCB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IG5hbWUgPSB1c2VSZWYoJycpO1xuICAgIGNvbnN0IFtuYW1lcywgc2V0TmFtZXNdID0gdXNlU3RhdGUoWycnXSk7XG4gICAgY29uc3Qgcm9vbU5vSW5wdXQ9dXNlUmVmKCcnKTtcblxuXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBxdWVyeVBhcmFtczogVVJMU2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcblxuICAgICAgICBjb25zdCBidG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3Blbi1tb2RhbCcpO1xuICAgICAgICBidG4/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgc2V0aXNPcGVuKHRydWUpO1xuICAgICAgICB9KVxuXG4gICAgICAgIGluaXRXZWJTb2NrZXQoKTtcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdmcnKSBhcyB1bmtub3duIGFzIFNWR1NWR0VsZW1lbnQ7XG4gICAgICAgIGlmIChzdmdFbGVtZW50IGluc3RhbmNlb2YgU1ZHU1ZHRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKHdpbmRvdy5zY3JlZW4uaGVpZ2h0KS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAod2luZG93LnNjcmVlbi53aWR0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBoZWlnaHQpO1xuICAgICAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVGhlIGVsZW1lbnQgaXMgbm90IGFuIFNWRyBlbGVtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdFJlZi5jdXJyZW50ID0gbmV3IFJlY3RhbmdsZShzdmdFbGVtZW50KTtcbiAgICAgICAgY2lyY2xlUmVmLmN1cnJlbnQgPSBuZXcgQ2lyY2xlKHN2Z0VsZW1lbnQpO1xuXG4gICAgICAgIGxldCBtb3VzZWQ6IG51bWJlciB8IE5vZGVKUy5UaW1lb3V0ID0gLTE7XG5cbiAgICAgICAgY29uc3QgbW91c2Vkb3duID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAobW91c2VkID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHgxLmN1cnJlbnQgPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgIHkxLmN1cnJlbnQgPSBldmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS50b29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHN2Z0VsZW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIG1vdXNlZCA9IHNldEludGVydmFsKCgpID0+IHdoaWxlbW91c2Vkb3duKGV2ZW50KSwgMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ1NlbGVjdCB0b29sJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG1vdXNldXAgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChtb3VzZWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChtb3VzZWQpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnRvb2w/Lm1ha2VTaGFwZSh4MS5jdXJyZW50LCB5MS5jdXJyZW50LCBldmVudC5jbGllbnRYIC0geDEuY3VycmVudCwgZXZlbnQuY2xpZW50WSAtIHkxLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHNldFN0YXRlKChwcmV2U3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgeDI6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHkyOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIGxldCBkYXRhOiBEcmF3RGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgbWVzOiBNZXNzYWdlO1xuICAgICAgICAgICAgICAgIGlmIChzdmdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4MTogeDEuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHgyOiBldmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTE6IHkxLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5MjogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IHN0YXRlLnRvb2wgaW5zdGFuY2VvZiBSZWN0YW5nbGUgPyAnUmVjdGFuZ2xlJyA6ICdDaXJjbGUnLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCAmJiBzb2NrZXRSZWYuY3VycmVudC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICAgICAgICBtZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhISksXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICByb29tSUQ6IHJvb21JRC5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDogJ1NFTkQgREFUQScsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBxdWVyeVBhcmFtcy5nZXQoJ25hbWUnKSEsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuc2VuZChKU09OLnN0cmluZ2lmeShtZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW91c2VkID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbW91c2Vtb3ZlID0gKGU6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChtb3VzZWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudG9vbD8uc2hvd1NoYXBlKHgxLmN1cnJlbnQsIHkxLmN1cnJlbnQsIGUuY2xpZW50WCAtIHgxLmN1cnJlbnQsIGUuY2xpZW50WSAtIHkxLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHdoaWxlbW91c2Vkb3duID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIH07XG5cbiAgICAgICAgc3ZnRWxlbWVudD8uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2Vkb3duKTtcbiAgICAgICAgc3ZnRWxlbWVudD8uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG1vdXNldXApO1xuICAgICAgICBzdmdFbGVtZW50Py5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG1vdXNldXApO1xuXG4gICAgICAgIGlmIChxdWVyeVBhcmFtcy5oYXMoJ3Jvb21JZCcpKSB7XG4gICAgICAgICAgICBzZXRzaG93Um9vbUlkKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN2Z0VsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG1vdXNlZG93bik7XG4gICAgICAgICAgICBzdmdFbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2V1cCk7XG4gICAgICAgICAgICBzdmdFbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIG1vdXNldXApO1xuICAgICAgICB9O1xuICAgIH0sW3N0YXRlLnRvb2xdKTtcblxuXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBzZWFyY2hQYXJhbXM6IFVSTFNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICAgICAgY29uc29sZS5sb2coc2VhcmNoUGFyYW1zLmdldCgncm9vbUlkJykpO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWFyY2hQYXJhbXMuZ2V0KCduYW1lJykpO1xuXG4gICAgICAgIHJvb21JRC5jdXJyZW50ID0gc2VhcmNoUGFyYW1zLmdldCgncm9vbUlkJyk7XG4gICAgICAgIG5hbWUuY3VycmVudCA9IHNlYXJjaFBhcmFtcy5nZXQoJ25hbWUnKSE7XG4gICAgICAgIHNldE5hbWVzKFtuYW1lLmN1cnJlbnRdKTtcbiAgICB9LCBbXSlcblxuXG5cblxuICAgIGNvbnN0IGluaXRXZWJTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBXZWJTb2NrZXQoJ3dzczovL2lkZWFmbG93LXdlYnNvY2tldC1zZXJ2ZXIub25yZW5kZXIuY29tJyk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gc29ja2V0O1xuXG4gICAgICAgIHNvY2tldC5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdGVkIHRvIHdlYnNvY2tldCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coc29ja2V0Lk9QRU4pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxldCBtZXM6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnU0VORCBOQU1FUycsXG4gICAgICAgICAgICByb29tSUQ6IHJvb21JRC5jdXJyZW50LFxuICAgICAgICAgICAgZGF0YTogJycsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLmN1cnJlbnRcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zLmhhcygncm9vbUlkJykpIHtcbiAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICAgICAgc29ja2V0Lm9ubWVzc2FnZSA9IChldjogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXM6IE1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xuICAgICAgICAgICAgaWYgKG1lcy50eXBlID09PSAncmVzcG9uc2UnKSB7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lcy5jb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JPT00gQ1JFQVRFRCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByb29tSUQuY3VycmVudCA9IG1lcy5yb29tSUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoJ3Jvb21JZCcsIG1lcy5yb29tSUQhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHNob3dSb29tSWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXIucHVzaChgL3doaXRlYm9hcmQ/JHtxdWVyeVBhcmFtc31gKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRlVMTCBTRVJWRVInOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ1NvcnJ5IFNlcnZlciBpcyBmdWxsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdKT0lORUQgUk9PTSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVlcnlQYXJhbXMuaGFzKCdyb29tSWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmRlbGV0ZSgncm9vbUlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5hcHBlbmQoJ3Jvb21JZCcsIGAke21lcy5yb29tSUR9YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlci5wdXNoKGAvd2hpdGVib2FyZD8ke3F1ZXJ5UGFyYW1zfWApXG4gICAgICAgICAgICAgICAgICAgICAgICByb29tSUQuY3VycmVudCA9IG1lcy5yb29tSUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRzaG93Um9vbUlkKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTEVGVCBST09NJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXMubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuID0gbWVzLm5hbWUuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobi5pbmNsdWRlcyhuYW1lLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE5hbWVzKG4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmFtZXMoW25hbWUuY3VycmVudF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE5hbWVzKFtuYW1lLmN1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLmRlbGV0ZSgncm9vbUlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRzaG93Um9vbUlkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlci5wdXNoKGAvd2hpdGVib2FyZD8ke3F1ZXJ5UGFyYW1zfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRFJBV0lORyBEQVRBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYXdEYXRhID0gSlNPTi5wYXJzZShtZXMuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjdXRlTWVzc2FnZShkcmF3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdVU0VSTkFNRVMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IG1lcy5uYW1lLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uaW5jbHVkZXMobmFtZS5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXROYW1lcyhtZXMubmFtZS5zcGxpdCgnLCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldE5hbWVzKFtuYW1lLmN1cnJlbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZXhlY3V0ZU1lc3NhZ2UgPSAoZGF0YTogRHJhd0RhdGEpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ21ha2luZyBzaGFwZXMnLCBkYXRhKTtcbiAgICAgICAgc3dpdGNoIChkYXRhLnRvb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ1JlY3RhbmdsZSc6XG4gICAgICAgICAgICAgICAgcmVjdFJlZi5jdXJyZW50Py5tYWtlU2hhcGUoZGF0YS54MSwgZGF0YS55MSwgZGF0YS54MiAtIGRhdGEueDEsIGRhdGEueTIgLSBkYXRhLnkxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0NpcmNsZSc6XG4gICAgICAgICAgICAgICAgY2lyY2xlUmVmLmN1cnJlbnQ/Lm1ha2VTaGFwZShkYXRhLngxLCBkYXRhLnkxLCBkYXRhLngyIC0gZGF0YS54MSwgZGF0YS55MiAtIGRhdGEueTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHNlbGVjdHRoZVRvb2wgPSAodG9vbDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCd0aGUgc2VsZWN0ZWQgdG9vbCBpcyAnLCB0b29sKTtcbiAgICAgICAgaWYgKHRvb2wgPT09ICdyZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICBzZXRTdGF0ZSgocHJldlN0YXRlKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnByZXZTdGF0ZSxcbiAgICAgICAgICAgICAgICB0b29sOiByZWN0UmVmLmN1cnJlbnQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9vbCA9PT0gJ2NpcmNsZScpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKChwcmV2U3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucHJldlN0YXRlLFxuICAgICAgICAgICAgICAgIHRvb2w6IGNpcmNsZVJlZi5jdXJyZW50LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZVJvb20gPSAoKSA9PiB7XG4gICAgICAgIGxldCBtZXM6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnQ1JFQVRFIFJPT00nLFxuICAgICAgICAgICAgcm9vbUlEOiAnMCcsXG4gICAgICAgICAgICBkYXRhOiAnJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUuY3VycmVudFxuICAgICAgICB9XG5cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzKSk7XG5cbiAgICAgICAgbGV0IG1lczE6IE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICAgICAgICBjb21tYW5kOiAnU0VORCBOQU1FUycsXG4gICAgICAgICAgICByb29tSUQ6IHJvb21JRC5jdXJyZW50LFxuICAgICAgICAgICAgZGF0YTogJycsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLmN1cnJlbnRcbiAgICAgICAgfVxuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uc2VuZChKU09OLnN0cmluZ2lmeShtZXMxKSk7XG5cbiAgICB9O1xuXG4gICAgY29uc3QgbGVhdmVSb29tID0gKCkgPT4ge1xuICAgICAgICBsZXQgbWVzOiBNZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgY29tbWFuZDogJ0xFQVZFIFJPT00nLFxuICAgICAgICAgICAgcm9vbUlEOiByb29tSUQuY3VycmVudCxcbiAgICAgICAgICAgIGRhdGE6ICcnLFxuICAgICAgICAgICAgbmFtZTogbmFtZS5jdXJyZW50LFxuICAgICAgICB9XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5zZW5kKEpTT04uc3RyaW5naWZ5KG1lcykpO1xuXG4gICAgICAgIGxldCBtZXMxOiBNZXNzYWdlID0ge1xuICAgICAgICAgICAgdHlwZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgY29tbWFuZDogJ1NFTkQgTkFNRVMnLFxuICAgICAgICAgICAgcm9vbUlEOiByb29tSUQuY3VycmVudCxcbiAgICAgICAgICAgIGRhdGE6ICcnLFxuICAgICAgICAgICAgbmFtZTogbmFtZS5jdXJyZW50XG4gICAgICAgIH1cbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzMSkpO1xuXG4gICAgfVxuXG5cbiAgICBjb25zdCBnZXRSb29tTm8gPSAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKHJvb21Ob0lucHV0LmN1cnJlbnQpO1xuICAgICAgICBpZiAocm9vbU5vSW5wdXQuY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzb2NrZXRSZWYuY3VycmVudCwgJycsIHJvb21Ob0lucHV0LmN1cnJlbnQpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVxdWVzdCcsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ0pPSU4gUk9PTScsXG4gICAgICAgICAgICAgICAgcm9vbUlEOiByb29tTm9JbnB1dC5jdXJyZW50LFxuICAgICAgICAgICAgICAgIGRhdGE6ICcnLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUuY3VycmVudCxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50IS5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTtcblxuICAgICAgICAgICAgbGV0IG1lczEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlcXVlc3QnLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6ICdTRU5EIE5BTUVTJyxcbiAgICAgICAgICAgICAgICByb29tSUQ6IHJvb21Ob0lucHV0LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgZGF0YTogJycsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZS5jdXJyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudCEuc2VuZChKU09OLnN0cmluZ2lmeShtZXMxKSk7XG4gICAgICAgICAgICBoYW5kbGVDbG9zZSgpO1xuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbGVydCgnRW50ZXIgUm9vbSBObycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIGxldCBkdWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R1bGwnKTtcbiAgICAgICAgd2hpbGUgKGR1bGwpIHtcbiAgICAgICAgICAgIGR1bGwucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQoZHVsbCk7XG4gICAgICAgICAgICBkdWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R1bGwnKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRpc09wZW4oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGdldElucHV0ID0gKCk9PntcbiAgICAgICAgY29uc3Qgcm9vbUlOcHV0PWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb29tLW51bWJlcicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIHJvb21Ob0lucHV0LmN1cnJlbnQ9cm9vbUlOcHV0LnZhbHVlO1xuICAgIH1cblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J3JlbGF0aXZlJz5cbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAge3Nob3dSb29tSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2Fic29sdXRlIHRvcC0wIGxlZnQtMCBmb250LWFtYXRpYyB0ZXh0LTN4bCc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUm9vbSBJZDp7cm9vbUlELmN1cnJlbnR9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT0nYWJzb2x1dGUgaW5zZXQteC0wIHRvcC0wIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG1pbi1oLTI0Jz5cbiAgICAgICAgICAgICAgICA8VG9vbEJhciBzZWxlY3RUb29sPXtzZWxlY3R0aGVUb29sfSB3ZWJzb2NrZXQ9e3NvY2tldFJlZi5jdXJyZW50fSBjcmVhdGVSb29tPXtjcmVhdGVSb29tfSBsZWF2ZVJvb209e2xlYXZlUm9vbX0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHN2ZyBpZD1cInN2Z1wiIGNsYXNzTmFtZT1cImJvcmRlciBib3JkZXItZ3JleSBiZy1ncmVlbi0yMDBcIj5cbiAgICAgICAgICAgICAgICA8cmVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgZmlsbD1cIiNiYmY3ZDBcIj48L3JlY3Q+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmbGV4IGZsZXgtY29sIGl0ZW1zLWVuZCBwLTIgY3Vyc29yLWRlZmF1bHQgYm9yZGVyIGJvcmRlci1ncmV5IGFic29sdXRlIGJvdHRvbS0wIHJpZ2h0LTAnPlxuICAgICAgICAgICAgICAgIHtuYW1lcy5tYXAoKG4pID0+IChcbiAgICAgICAgICAgICAgICAgICAgPFBlb3BsZSBrZXk9e259IGluZGV4PXtufSAvPlxuICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8TW9kYWwgaGFuZGxlQ2xvc2U9e2hhbmRsZUNsb3NlfVxuICAgICAgICAgICAgIGlzT3Blbj17aXNPcGVufVxuICAgICAgICAgICAgIGhhbmRsZUVudGVyPXtnZXRSb29tTm99XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPEpvaW5Sb29tTW9kYWwgc29ja2V0PXtzb2NrZXRSZWYuY3VycmVudCF9IG5hbWU9e25hbWUuY3VycmVudH0gZ2V0Um9vbU5vPXtnZXRSb29tTm99IGdldElucHV0PXtnZXRJbnB1dH0vPlxuICAgICAgICAgICAgPC9Nb2RhbD5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdoaXRlQm9hcmQ7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJUb29sQmFyIiwiUGVvcGxlIiwiUmVjdGFuZ2xlIiwiQ2lyY2xlIiwidXNlUm91dGVyIiwiTW9kYWwiLCJKb2luUm9vbU1vZGFsIiwiV2hpdGVCb2FyZCIsInJvdXRlciIsInN0YXRlIiwic2V0U3RhdGUiLCJ0b29sIiwieDIiLCJ5MiIsImlzT3BlbiIsInNldGlzT3BlbiIsInNob3dSb29tSWQiLCJzZXRzaG93Um9vbUlkIiwicm9vbUlEIiwieDEiLCJ5MSIsInJlY3RSZWYiLCJjaXJjbGVSZWYiLCJzb2NrZXRSZWYiLCJuYW1lIiwibmFtZXMiLCJzZXROYW1lcyIsInJvb21Ob0lucHV0IiwicXVlcnlQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInNlYXJjaCIsImJ0biIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdFdlYlNvY2tldCIsInN2Z0VsZW1lbnQiLCJTVkdTVkdFbGVtZW50IiwiaGVpZ2h0Iiwic2NyZWVuIiwidG9TdHJpbmciLCJ3aWR0aCIsInNldEF0dHJpYnV0ZSIsImNvbnNvbGUiLCJlcnJvciIsImN1cnJlbnQiLCJtb3VzZWQiLCJtb3VzZWRvd24iLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwibW91c2Vtb3ZlIiwic2V0SW50ZXJ2YWwiLCJ3aGlsZW1vdXNlZG93biIsImFsZXJ0IiwibW91c2V1cCIsImNsZWFySW50ZXJ2YWwiLCJtYWtlU2hhcGUiLCJwcmV2U3RhdGUiLCJkYXRhIiwibWVzIiwicmVhZHlTdGF0ZSIsIldlYlNvY2tldCIsIk9QRU4iLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZSIsImNvbW1hbmQiLCJnZXQiLCJzZW5kIiwiZSIsInNob3dTaGFwZSIsImhhcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZWFyY2hQYXJhbXMiLCJsb2ciLCJzb2NrZXQiLCJvbm9wZW4iLCJvbm1lc3NhZ2UiLCJldiIsInBhcnNlIiwic2V0IiwicHVzaCIsImRlbGV0ZSIsImFwcGVuZCIsIm4iLCJzcGxpdCIsImluY2x1ZGVzIiwiZHJhd0RhdGEiLCJleGVjdXRlTWVzc2FnZSIsInNlbGVjdHRoZVRvb2wiLCJjcmVhdGVSb29tIiwibWVzMSIsImxlYXZlUm9vbSIsImdldFJvb21ObyIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJoYW5kbGVDbG9zZSIsImR1bGwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJnZXRJbnB1dCIsInJvb21JTnB1dCIsInZhbHVlIiwiZGl2IiwiY2xhc3NOYW1lIiwic2VsZWN0VG9vbCIsIndlYnNvY2tldCIsInN2ZyIsImlkIiwicmVjdCIsImZpbGwiLCJtYXAiLCJpbmRleCIsImhhbmRsZUVudGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/_components/WhiteBoard.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/whiteboard/app.tsx":
/*!************************************!*\
  !*** ./src/app/whiteboard/app.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global.css */ \"(app-pages-browser)/./src/app/global.css\");\n/* harmony import */ var _components_WhiteBoard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../_components/WhiteBoard */ \"(app-pages-browser)/./src/app/_components/WhiteBoard.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nfunction App() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex items-center justify-center border border-grey relative z-50\",\n        id: \"root\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_WhiteBoard__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/whiteboard/app.tsx\",\n                lineNumber: 10,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/whiteboard/app.tsx\",\n            lineNumber: 9,\n            columnNumber: 13\n        }, this)\n    }, void 0, false, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/whiteboard/app.tsx\",\n        lineNumber: 8,\n        columnNumber: 9\n    }, this);\n}\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvd2hpdGVib2FyZC9hcHAudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFDMEI7QUFDSDtBQUM0QjtBQUVwQyxTQUFTRTtJQUNwQixxQkFDSSw4REFBQ0M7UUFBSUMsV0FBVTtRQUFvRUMsSUFBRztrQkFDbEYsNEVBQUNGO1lBQUlDLFdBQVU7c0JBQ1gsNEVBQUNILDhEQUFVQTs7Ozs7Ozs7Ozs7Ozs7O0FBSTNCO0tBUndCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3doaXRlYm9hcmQvYXBwLnRzeD8yZDgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAnLi4vZ2xvYmFsLmNzcyc7XG5pbXBvcnQgV2hpdGVCb2FyZCBmcm9tICcuLi9fY29tcG9uZW50cy9XaGl0ZUJvYXJkJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKCkge1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBib3JkZXIgYm9yZGVyLWdyZXkgcmVsYXRpdmUgei01MCcgaWQ9J3Jvb3QnPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9Jyc+XG4gICAgICAgICAgICAgICAgPFdoaXRlQm9hcmQgLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSJdLCJuYW1lcyI6WyJSZWFjdCIsIldoaXRlQm9hcmQiLCJBcHAiLCJkaXYiLCJjbGFzc05hbWUiLCJpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/whiteboard/app.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/whiteboard/page.tsx":
/*!*************************************!*\
  !*** ./src/app/whiteboard/page.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Page; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _global_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../global.css */ \"(app-pages-browser)/./src/app/global.css\");\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app */ \"(app-pages-browser)/./src/app/whiteboard/app.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nfunction Page() {\n    // useEffect(() => {\n    //   document.body.classList.add('bg-green-200');\n    // })\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_app__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n        fileName: \"/home/taksh/Desktop/ideaflow/client/src/app/whiteboard/page.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n_c = Page;\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvd2hpdGVib2FyZC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ3lDO0FBQ2xCO0FBQ0M7QUFFVCxTQUFTRTtJQUN0QixvQkFBb0I7SUFDcEIsaURBQWlEO0lBQ2pELEtBQUs7SUFDTCxxQkFDRSw4REFBQ0QsNENBQUdBOzs7OztBQUVSO0tBUHdCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3doaXRlYm9hcmQvcGFnZS50c3g/MWI4NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgJy4uL2dsb2JhbC5jc3MnO1xuaW1wb3J0IEFwcCBmcm9tICcuL2FwcCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFBhZ2UoKSB7XG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XG4gIC8vICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdiZy1ncmVlbi0yMDAnKTtcbiAgLy8gfSlcbiAgcmV0dXJuIChcbiAgICA8QXBwIC8+XG4gICk7XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwiQXBwIiwiUGFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/whiteboard/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYzs7O0FBR2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZ0hBQWdIOztBQUVoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiwyREFBMkQsVUFBVTtBQUNyRSx5QkFBeUIsVUFBVTtBQUNuQztBQUNBLGFBQWEsVUFBVTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxHQUFHO0FBQ2Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0RBQW9EO0FBQ3BELHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksU0FBUztBQUNyQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9jYmExIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/Nzk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/hachure-fill/bin/hachure.js":
/*!**************************************************!*\
  !*** ./node_modules/hachure-fill/bin/hachure.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hachureLines: function() { return /* binding */ hachureLines; }\n/* harmony export */ });\nfunction rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        for (const p of points) {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        }\n    }\n}\nfunction rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nfunction hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n    const angle = hachureAngle;\n    const gap = Math.max(hachureGap, 0.1);\n    const polygonList = (polygons[0] && polygons[0][0] && (typeof polygons[0][0] === 'number')) ? [polygons] : polygons;\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n    const vertexArray = [];\n    for (const polygon of polygons) {\n        const vertices = [...polygon];\n        if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    let iteration = 0;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if ((hachureStepOffset !== 1) || (iteration % gap === 0)) {\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y],\n                    ]);\n                }\n            }\n        }\n        y += hachureStepOffset;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (hachureStepOffset * ae.edge.islope);\n        });\n        iteration++;\n    }\n    return lines;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oYWNodXJlLWZpbGwvYmluL2hhY2h1cmUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0JBQXdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9oYWNodXJlLWZpbGwvYmluL2hhY2h1cmUuanM/NDMyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiByb3RhdGVQb2ludHMocG9pbnRzLCBjZW50ZXIsIGRlZ3JlZXMpIHtcbiAgICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgW2N4LCBjeV0gPSBjZW50ZXI7XG4gICAgICAgIGNvbnN0IGFuZ2xlID0gKE1hdGguUEkgLyAxODApICogZGVncmVlcztcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IHA7XG4gICAgICAgICAgICBwWzBdID0gKCh4IC0gY3gpICogY29zKSAtICgoeSAtIGN5KSAqIHNpbikgKyBjeDtcbiAgICAgICAgICAgIHBbMV0gPSAoKHggLSBjeCkgKiBzaW4pICsgKCh5IC0gY3kpICogY29zKSArIGN5O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcm90YXRlTGluZXMobGluZXMsIGNlbnRlciwgZGVncmVlcykge1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGxpbmVzLmZvckVhY2goKGxpbmUpID0+IHBvaW50cy5wdXNoKC4uLmxpbmUpKTtcbiAgICByb3RhdGVQb2ludHMocG9pbnRzLCBjZW50ZXIsIGRlZ3JlZXMpO1xufVxuZnVuY3Rpb24gYXJlU2FtZVBvaW50cyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDFbMF0gPT09IHAyWzBdICYmIHAxWzFdID09PSBwMlsxXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYWNodXJlTGluZXMocG9seWdvbnMsIGhhY2h1cmVHYXAsIGhhY2h1cmVBbmdsZSwgaGFjaHVyZVN0ZXBPZmZzZXQgPSAxKSB7XG4gICAgY29uc3QgYW5nbGUgPSBoYWNodXJlQW5nbGU7XG4gICAgY29uc3QgZ2FwID0gTWF0aC5tYXgoaGFjaHVyZUdhcCwgMC4xKTtcbiAgICBjb25zdCBwb2x5Z29uTGlzdCA9IChwb2x5Z29uc1swXSAmJiBwb2x5Z29uc1swXVswXSAmJiAodHlwZW9mIHBvbHlnb25zWzBdWzBdID09PSAnbnVtYmVyJykpID8gW3BvbHlnb25zXSA6IHBvbHlnb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uQ2VudGVyID0gWzAsIDBdO1xuICAgIGlmIChhbmdsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBvbHlnb24gb2YgcG9seWdvbkxpc3QpIHtcbiAgICAgICAgICAgIHJvdGF0ZVBvaW50cyhwb2x5Z29uLCByb3RhdGlvbkNlbnRlciwgYW5nbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gc3RyYWlnaHRIYWNodXJlTGluZXMocG9seWdvbkxpc3QsIGdhcCwgaGFjaHVyZVN0ZXBPZmZzZXQpO1xuICAgIGlmIChhbmdsZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBvbHlnb24gb2YgcG9seWdvbkxpc3QpIHtcbiAgICAgICAgICAgIHJvdGF0ZVBvaW50cyhwb2x5Z29uLCByb3RhdGlvbkNlbnRlciwgLWFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICByb3RhdGVMaW5lcyhsaW5lcywgcm90YXRpb25DZW50ZXIsIC1hbmdsZSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbmZ1bmN0aW9uIHN0cmFpZ2h0SGFjaHVyZUxpbmVzKHBvbHlnb25zLCBnYXAsIGhhY2h1cmVTdGVwT2Zmc2V0KSB7XG4gICAgY29uc3QgdmVydGV4QXJyYXkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBvbHlnb24gb2YgcG9seWdvbnMpIHtcbiAgICAgICAgY29uc3QgdmVydGljZXMgPSBbLi4ucG9seWdvbl07XG4gICAgICAgIGlmICghYXJlU2FtZVBvaW50cyh2ZXJ0aWNlc1swXSwgdmVydGljZXNbdmVydGljZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt2ZXJ0aWNlc1swXVswXSwgdmVydGljZXNbMF1bMV1dKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVydGljZXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmVydGV4QXJyYXkucHVzaCh2ZXJ0aWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBnYXAgPSBNYXRoLm1heChnYXAsIDAuMSk7XG4gICAgLy8gQ3JlYXRlIHNvcnRlZCBlZGdlcyB0YWJsZVxuICAgIGNvbnN0IGVkZ2VzID0gW107XG4gICAgZm9yIChjb25zdCB2ZXJ0aWNlcyBvZiB2ZXJ0ZXhBcnJheSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcDEgPSB2ZXJ0aWNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHAyID0gdmVydGljZXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHAxWzFdICE9PSBwMlsxXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHltaW4gPSBNYXRoLm1pbihwMVsxXSwgcDJbMV0pO1xuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB5bWluLFxuICAgICAgICAgICAgICAgICAgICB5bWF4OiBNYXRoLm1heChwMVsxXSwgcDJbMV0pLFxuICAgICAgICAgICAgICAgICAgICB4OiB5bWluID09PSBwMVsxXSA/IHAxWzBdIDogcDJbMF0sXG4gICAgICAgICAgICAgICAgICAgIGlzbG9wZTogKHAyWzBdIC0gcDFbMF0pIC8gKHAyWzFdIC0gcDFbMV0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVkZ2VzLnNvcnQoKGUxLCBlMikgPT4ge1xuICAgICAgICBpZiAoZTEueW1pbiA8IGUyLnltaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZTEueW1pbiA+IGUyLnltaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlMS54IDwgZTIueCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlMS54ID4gZTIueCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUxLnltYXggPT09IGUyLnltYXgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZTEueW1heCAtIGUyLnltYXgpIC8gTWF0aC5hYnMoKGUxLnltYXggLSBlMi55bWF4KSk7XG4gICAgfSk7XG4gICAgaWYgKCFlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICAvLyBTdGFydCBzY2FubmluZ1xuICAgIGxldCBhY3RpdmVFZGdlcyA9IFtdO1xuICAgIGxldCB5ID0gZWRnZXNbMF0ueW1pbjtcbiAgICBsZXQgaXRlcmF0aW9uID0gMDtcbiAgICB3aGlsZSAoYWN0aXZlRWRnZXMubGVuZ3RoIHx8IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgaXggPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZXNbaV0ueW1pbiA+IHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSBlZGdlcy5zcGxpY2UoMCwgaXggKyAxKTtcbiAgICAgICAgICAgIHJlbW92ZWQuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVkZ2VzLnB1c2goeyBzOiB5LCBlZGdlIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWN0aXZlRWRnZXMgPSBhY3RpdmVFZGdlcy5maWx0ZXIoKGFlKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWUuZWRnZS55bWF4IDw9IHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGl2ZUVkZ2VzLnNvcnQoKGFlMSwgYWUyKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWUxLmVkZ2UueCA9PT0gYWUyLmVkZ2UueCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChhZTEuZWRnZS54IC0gYWUyLmVkZ2UueCkgLyBNYXRoLmFicygoYWUxLmVkZ2UueCAtIGFlMi5lZGdlLngpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGZpbGwgYmV0d2VlbiB0aGUgZWRnZXNcbiAgICAgICAgaWYgKChoYWNodXJlU3RlcE9mZnNldCAhPT0gMSkgfHwgKGl0ZXJhdGlvbiAlIGdhcCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVFZGdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmVFZGdlcy5sZW5ndGg7IGkgPSBpICsgMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0aSA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dGkgPj0gYWN0aXZlRWRnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZSA9IGFjdGl2ZUVkZ2VzW2ldLmVkZ2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lID0gYWN0aXZlRWRnZXNbbmV4dGldLmVkZ2U7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgucm91bmQoY2UueCksIHldLFxuICAgICAgICAgICAgICAgICAgICAgICAgW01hdGgucm91bmQobmUueCksIHldLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeSArPSBoYWNodXJlU3RlcE9mZnNldDtcbiAgICAgICAgYWN0aXZlRWRnZXMuZm9yRWFjaCgoYWUpID0+IHtcbiAgICAgICAgICAgIGFlLmVkZ2UueCA9IGFlLmVkZ2UueCArIChoYWNodXJlU3RlcE9mZnNldCAqIGFlLmVkZ2UuaXNsb3BlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGl0ZXJhdGlvbisrO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hachure-fill/bin/hachure.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2Fhome%2Ftaksh%2FDesktop%2Fideaflow%2Fclient%2Fsrc%2Fapp%2Fwhiteboard%2Fpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);
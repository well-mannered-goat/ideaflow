"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/points-on-path";
exports.ids = ["vendor-chunks/points-on-path"];
exports.modules = {

/***/ "(ssr)/./node_modules/points-on-path/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/points-on-path/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointsOnPath: () => (/* binding */ pointsOnPath)\n/* harmony export */ });\n/* harmony import */ var points_on_curve__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! points-on-curve */ \"(ssr)/./node_modules/points-on-curve/lib/index.js\");\n/* harmony import */ var path_data_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path-data-parser */ \"(ssr)/./node_modules/path-data-parser/lib/index.js\");\n\n\nfunction pointsOnPath(path, tolerance, distance) {\n    const segments = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_1__.parsePath)(path);\n    const normalized = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_1__.normalize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_1__.absolutize)(segments));\n    const sets = [];\n    let currentPoints = [];\n    let start = [0, 0];\n    let pendingCurve = [];\n    const appendPendingCurve = () => {\n        if (pendingCurve.length >= 4) {\n            currentPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_0__.pointsOnBezierCurves)(pendingCurve, tolerance));\n        }\n        pendingCurve = [];\n    };\n    const appendPendingPoints = () => {\n        appendPendingCurve();\n        if (currentPoints.length) {\n            sets.push(currentPoints);\n            currentPoints = [];\n        }\n    };\n    for (const { key, data } of normalized) {\n        switch (key) {\n            case 'M':\n                appendPendingPoints();\n                start = [data[0], data[1]];\n                currentPoints.push(start);\n                break;\n            case 'L':\n                appendPendingCurve();\n                currentPoints.push([data[0], data[1]]);\n                break;\n            case 'C':\n                if (!pendingCurve.length) {\n                    const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;\n                    pendingCurve.push([lastPoint[0], lastPoint[1]]);\n                }\n                pendingCurve.push([data[0], data[1]]);\n                pendingCurve.push([data[2], data[3]]);\n                pendingCurve.push([data[4], data[5]]);\n                break;\n            case 'Z':\n                appendPendingCurve();\n                currentPoints.push([start[0], start[1]]);\n                break;\n        }\n    }\n    appendPendingPoints();\n    if (!distance) {\n        return sets;\n    }\n    const out = [];\n    for (const set of sets) {\n        const simplifiedSet = (0,points_on_curve__WEBPACK_IMPORTED_MODULE_0__.simplify)(set, distance);\n        if (simplifiedSet.length) {\n            out.push(simplifiedSet);\n        }\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLXBhdGgvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRTtBQUNHO0FBQzdEO0FBQ1AscUJBQXFCLDJEQUFTO0FBQzlCLHVCQUF1QiwyREFBUyxDQUFDLDREQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxRUFBb0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5REFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9wb2ludHMtb24tcGF0aC9saWIvaW5kZXguanM/OWIzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwb2ludHNPbkJlemllckN1cnZlcywgc2ltcGxpZnkgfSBmcm9tICdwb2ludHMtb24tY3VydmUnO1xuaW1wb3J0IHsgcGFyc2VQYXRoLCBhYnNvbHV0aXplLCBub3JtYWxpemUgfSBmcm9tICdwYXRoLWRhdGEtcGFyc2VyJztcbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNPblBhdGgocGF0aCwgdG9sZXJhbmNlLCBkaXN0YW5jZSkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gcGFyc2VQYXRoKHBhdGgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBub3JtYWxpemUoYWJzb2x1dGl6ZShzZWdtZW50cykpO1xuICAgIGNvbnN0IHNldHMgPSBbXTtcbiAgICBsZXQgY3VycmVudFBvaW50cyA9IFtdO1xuICAgIGxldCBzdGFydCA9IFswLCAwXTtcbiAgICBsZXQgcGVuZGluZ0N1cnZlID0gW107XG4gICAgY29uc3QgYXBwZW5kUGVuZGluZ0N1cnZlID0gKCkgPT4ge1xuICAgICAgICBpZiAocGVuZGluZ0N1cnZlLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2goLi4ucG9pbnRzT25CZXppZXJDdXJ2ZXMocGVuZGluZ0N1cnZlLCB0b2xlcmFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nQ3VydmUgPSBbXTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGVuZFBlbmRpbmdQb2ludHMgPSAoKSA9PiB7XG4gICAgICAgIGFwcGVuZFBlbmRpbmdDdXJ2ZSgpO1xuICAgICAgICBpZiAoY3VycmVudFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldHMucHVzaChjdXJyZW50UG9pbnRzKTtcbiAgICAgICAgICAgIGN1cnJlbnRQb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCB7IGtleSwgZGF0YSB9IG9mIG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgIGFwcGVuZFBlbmRpbmdQb2ludHMoKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IFtkYXRhWzBdLCBkYXRhWzFdXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2goc3RhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgYXBwZW5kUGVuZGluZ0N1cnZlKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKFtkYXRhWzBdLCBkYXRhWzFdXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdDdXJ2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gY3VycmVudFBvaW50cy5sZW5ndGggPyBjdXJyZW50UG9pbnRzW2N1cnJlbnRQb2ludHMubGVuZ3RoIC0gMV0gOiBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0N1cnZlLnB1c2goW2xhc3RQb2ludFswXSwgbGFzdFBvaW50WzFdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBlbmRpbmdDdXJ2ZS5wdXNoKFtkYXRhWzBdLCBkYXRhWzFdXSk7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0N1cnZlLnB1c2goW2RhdGFbMl0sIGRhdGFbM11dKTtcbiAgICAgICAgICAgICAgICBwZW5kaW5nQ3VydmUucHVzaChbZGF0YVs0XSwgZGF0YVs1XV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgYXBwZW5kUGVuZGluZ0N1cnZlKCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKFtzdGFydFswXSwgc3RhcnRbMV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmRQZW5kaW5nUG9pbnRzKCk7XG4gICAgaWYgKCFkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gc2V0cztcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgZm9yIChjb25zdCBzZXQgb2Ygc2V0cykge1xuICAgICAgICBjb25zdCBzaW1wbGlmaWVkU2V0ID0gc2ltcGxpZnkoc2V0LCBkaXN0YW5jZSk7XG4gICAgICAgIGlmIChzaW1wbGlmaWVkU2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0LnB1c2goc2ltcGxpZmllZFNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/points-on-path/lib/index.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hachure-fill";
exports.ids = ["vendor-chunks/hachure-fill"];
exports.modules = {

/***/ "(ssr)/./node_modules/hachure-fill/bin/hachure.js":
/*!**************************************************!*\
  !*** ./node_modules/hachure-fill/bin/hachure.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hachureLines: () => (/* binding */ hachureLines)\n/* harmony export */ });\nfunction rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        for (const p of points) {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        }\n    }\n}\nfunction rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nfunction areSamePoints(p1, p2) {\n    return p1[0] === p2[0] && p1[1] === p2[1];\n}\nfunction hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {\n    const angle = hachureAngle;\n    const gap = Math.max(hachureGap, 0.1);\n    const polygonList = (polygons[0] && polygons[0][0] && (typeof polygons[0][0] === 'number')) ? [polygons] : polygons;\n    const rotationCenter = [0, 0];\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, angle);\n        }\n    }\n    const lines = straightHachureLines(polygonList, gap, hachureStepOffset);\n    if (angle) {\n        for (const polygon of polygonList) {\n            rotatePoints(polygon, rotationCenter, -angle);\n        }\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(polygons, gap, hachureStepOffset) {\n    const vertexArray = [];\n    for (const polygon of polygons) {\n        const vertices = [...polygon];\n        if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {\n            vertices.push([vertices[0][0], vertices[0][1]]);\n        }\n        if (vertices.length > 2) {\n            vertexArray.push(vertices);\n        }\n    }\n    const lines = [];\n    gap = Math.max(gap, 0.1);\n    // Create sorted edges table\n    const edges = [];\n    for (const vertices of vertexArray) {\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1]),\n                });\n            }\n        }\n    }\n    edges.sort((e1, e2) => {\n        if (e1.ymin < e2.ymin) {\n            return -1;\n        }\n        if (e1.ymin > e2.ymin) {\n            return 1;\n        }\n        if (e1.x < e2.x) {\n            return -1;\n        }\n        if (e1.x > e2.x) {\n            return 1;\n        }\n        if (e1.ymax === e2.ymax) {\n            return 0;\n        }\n        return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n    });\n    if (!edges.length) {\n        return lines;\n    }\n    // Start scanning\n    let activeEdges = [];\n    let y = edges[0].ymin;\n    let iteration = 0;\n    while (activeEdges.length || edges.length) {\n        if (edges.length) {\n            let ix = -1;\n            for (let i = 0; i < edges.length; i++) {\n                if (edges[i].ymin > y) {\n                    break;\n                }\n                ix = i;\n            }\n            const removed = edges.splice(0, ix + 1);\n            removed.forEach((edge) => {\n                activeEdges.push({ s: y, edge });\n            });\n        }\n        activeEdges = activeEdges.filter((ae) => {\n            if (ae.edge.ymax <= y) {\n                return false;\n            }\n            return true;\n        });\n        activeEdges.sort((ae1, ae2) => {\n            if (ae1.edge.x === ae2.edge.x) {\n                return 0;\n            }\n            return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n        });\n        // fill between the edges\n        if ((hachureStepOffset !== 1) || (iteration % gap === 0)) {\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y],\n                    ]);\n                }\n            }\n        }\n        y += hachureStepOffset;\n        activeEdges.forEach((ae) => {\n            ae.edge.x = ae.edge.x + (hachureStepOffset * ae.edge.islope);\n        });\n        iteration++;\n    }\n    return lines;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGFjaHVyZS1maWxsL2Jpbi9oYWNodXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWTtBQUMvQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL2hhY2h1cmUtZmlsbC9iaW4vaGFjaHVyZS5qcz83ZTZkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHJvdGF0ZVBvaW50cyhwb2ludHMsIGNlbnRlciwgZGVncmVlcykge1xuICAgIGlmIChwb2ludHMgJiYgcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBbY3gsIGN5XSA9IGNlbnRlcjtcbiAgICAgICAgY29uc3QgYW5nbGUgPSAoTWF0aC5QSSAvIDE4MCkgKiBkZWdyZWVzO1xuICAgICAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgW3gsIHldID0gcDtcbiAgICAgICAgICAgIHBbMF0gPSAoKHggLSBjeCkgKiBjb3MpIC0gKCh5IC0gY3kpICogc2luKSArIGN4O1xuICAgICAgICAgICAgcFsxXSA9ICgoeCAtIGN4KSAqIHNpbikgKyAoKHkgLSBjeSkgKiBjb3MpICsgY3k7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByb3RhdGVMaW5lcyhsaW5lcywgY2VudGVyLCBkZWdyZWVzKSB7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4gcG9pbnRzLnB1c2goLi4ubGluZSkpO1xuICAgIHJvdGF0ZVBvaW50cyhwb2ludHMsIGNlbnRlciwgZGVncmVlcyk7XG59XG5mdW5jdGlvbiBhcmVTYW1lUG9pbnRzKHAxLCBwMikge1xuICAgIHJldHVybiBwMVswXSA9PT0gcDJbMF0gJiYgcDFbMV0gPT09IHAyWzFdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhY2h1cmVMaW5lcyhwb2x5Z29ucywgaGFjaHVyZUdhcCwgaGFjaHVyZUFuZ2xlLCBoYWNodXJlU3RlcE9mZnNldCA9IDEpIHtcbiAgICBjb25zdCBhbmdsZSA9IGhhY2h1cmVBbmdsZTtcbiAgICBjb25zdCBnYXAgPSBNYXRoLm1heChoYWNodXJlR2FwLCAwLjEpO1xuICAgIGNvbnN0IHBvbHlnb25MaXN0ID0gKHBvbHlnb25zWzBdICYmIHBvbHlnb25zWzBdWzBdICYmICh0eXBlb2YgcG9seWdvbnNbMF1bMF0gPT09ICdudW1iZXInKSkgPyBbcG9seWdvbnNdIDogcG9seWdvbnM7XG4gICAgY29uc3Qgcm90YXRpb25DZW50ZXIgPSBbMCwgMF07XG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29uTGlzdCkge1xuICAgICAgICAgICAgcm90YXRlUG9pbnRzKHBvbHlnb24sIHJvdGF0aW9uQ2VudGVyLCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBzdHJhaWdodEhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgZ2FwLCBoYWNodXJlU3RlcE9mZnNldCk7XG4gICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29uTGlzdCkge1xuICAgICAgICAgICAgcm90YXRlUG9pbnRzKHBvbHlnb24sIHJvdGF0aW9uQ2VudGVyLCAtYW5nbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJvdGF0ZUxpbmVzKGxpbmVzLCByb3RhdGlvbkNlbnRlciwgLWFuZ2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gc3RyYWlnaHRIYWNodXJlTGluZXMocG9seWdvbnMsIGdhcCwgaGFjaHVyZVN0ZXBPZmZzZXQpIHtcbiAgICBjb25zdCB2ZXJ0ZXhBcnJheSA9IFtdO1xuICAgIGZvciAoY29uc3QgcG9seWdvbiBvZiBwb2x5Z29ucykge1xuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IFsuLi5wb2x5Z29uXTtcbiAgICAgICAgaWYgKCFhcmVTYW1lUG9pbnRzKHZlcnRpY2VzWzBdLCB2ZXJ0aWNlc1t2ZXJ0aWNlcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3ZlcnRpY2VzWzBdWzBdLCB2ZXJ0aWNlc1swXVsxXV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2ZXJ0ZXhBcnJheS5wdXNoKHZlcnRpY2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGdhcCA9IE1hdGgubWF4KGdhcCwgMC4xKTtcbiAgICAvLyBDcmVhdGUgc29ydGVkIGVkZ2VzIHRhYmxlXG4gICAgY29uc3QgZWRnZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZlcnRpY2VzIG9mIHZlcnRleEFycmF5KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwMSA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgY29uc3QgcDIgPSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocDFbMV0gIT09IHAyWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeW1pbiA9IE1hdGgubWluKHAxWzFdLCBwMlsxXSk7XG4gICAgICAgICAgICAgICAgZWRnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHltaW4sXG4gICAgICAgICAgICAgICAgICAgIHltYXg6IE1hdGgubWF4KHAxWzFdLCBwMlsxXSksXG4gICAgICAgICAgICAgICAgICAgIHg6IHltaW4gPT09IHAxWzFdID8gcDFbMF0gOiBwMlswXSxcbiAgICAgICAgICAgICAgICAgICAgaXNsb3BlOiAocDJbMF0gLSBwMVswXSkgLyAocDJbMV0gLSBwMVsxXSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWRnZXMuc29ydCgoZTEsIGUyKSA9PiB7XG4gICAgICAgIGlmIChlMS55bWluIDwgZTIueW1pbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlMS55bWluID4gZTIueW1pbikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUxLnggPCBlMi54KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUxLnggPiBlMi54KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZTEueW1heCA9PT0gZTIueW1heCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlMS55bWF4IC0gZTIueW1heCkgLyBNYXRoLmFicygoZTEueW1heCAtIGUyLnltYXgpKTtcbiAgICB9KTtcbiAgICBpZiAoIWVkZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIC8vIFN0YXJ0IHNjYW5uaW5nXG4gICAgbGV0IGFjdGl2ZUVkZ2VzID0gW107XG4gICAgbGV0IHkgPSBlZGdlc1swXS55bWluO1xuICAgIGxldCBpdGVyYXRpb24gPSAwO1xuICAgIHdoaWxlIChhY3RpdmVFZGdlcy5sZW5ndGggfHwgZWRnZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBpeCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChlZGdlc1tpXS55bWluID4geSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IGVkZ2VzLnNwbGljZSgwLCBpeCArIDEpO1xuICAgICAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRWRnZXMucHVzaCh7IHM6IHksIGVkZ2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmVFZGdlcyA9IGFjdGl2ZUVkZ2VzLmZpbHRlcigoYWUpID0+IHtcbiAgICAgICAgICAgIGlmIChhZS5lZGdlLnltYXggPD0geSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aXZlRWRnZXMuc29ydCgoYWUxLCBhZTIpID0+IHtcbiAgICAgICAgICAgIGlmIChhZTEuZWRnZS54ID09PSBhZTIuZWRnZS54KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKGFlMS5lZGdlLnggLSBhZTIuZWRnZS54KSAvIE1hdGguYWJzKChhZTEuZWRnZS54IC0gYWUyLmVkZ2UueCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZmlsbCBiZXR3ZWVuIHRoZSBlZGdlc1xuICAgICAgICBpZiAoKGhhY2h1cmVTdGVwT2Zmc2V0ICE9PSAxKSB8fCAoaXRlcmF0aW9uICUgZ2FwID09PSAwKSkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZUVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZUVkZ2VzLmxlbmd0aDsgaSA9IGkgKyAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRpID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0aSA+PSBhY3RpdmVFZGdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlID0gYWN0aXZlRWRnZXNbaV0uZWRnZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmUgPSBhY3RpdmVFZGdlc1tuZXh0aV0uZWRnZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5yb3VuZChjZS54KSwgeV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5yb3VuZChuZS54KSwgeV0sXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5ICs9IGhhY2h1cmVTdGVwT2Zmc2V0O1xuICAgICAgICBhY3RpdmVFZGdlcy5mb3JFYWNoKChhZSkgPT4ge1xuICAgICAgICAgICAgYWUuZWRnZS54ID0gYWUuZWRnZS54ICsgKGhhY2h1cmVTdGVwT2Zmc2V0ICogYWUuZWRnZS5pc2xvcGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlcmF0aW9uKys7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hachure-fill/bin/hachure.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/roughjs";
exports.ids = ["vendor-chunks/roughjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/roughjs/bin/canvas.js":
/*!********************************************!*\
  !*** ./node_modules/roughjs/bin/canvas.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughCanvas: () => (/* binding */ RoughCanvas)\n/* harmony export */ });\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generator */ \"(ssr)/./node_modules/roughjs/bin/generator.js\");\n\nclass RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new _generator__WEBPACK_IMPORTED_MODULE_0__.RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing, precision);\n                    ctx.restore();\n                    break;\n                case 'fillPath': {\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon' || drawable.shape === 'path') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, precision, fillRule);\n                    ctx.restore();\n                    break;\n                }\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, fixedDecimals, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY2FudmFzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY2FudmFzLmpzPzViNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm91Z2hHZW5lcmF0b3IgfSBmcm9tICcuL2dlbmVyYXRvcic7XG5leHBvcnQgY2xhc3MgUm91Z2hDYW52YXMge1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuZ2VuID0gbmV3IFJvdWdoR2VuZXJhdG9yKGNvbmZpZyk7XG4gICAgfVxuICAgIGRyYXcoZHJhd2FibGUpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IGRyYXdhYmxlLnNldHMgfHwgW107XG4gICAgICAgIGNvbnN0IG8gPSBkcmF3YWJsZS5vcHRpb25zIHx8IHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGRyYXdhYmxlLm9wdGlvbnMuZml4ZWREZWNpbWFsUGxhY2VEaWdpdHM7XG4gICAgICAgIGZvciAoY29uc3QgZHJhd2luZyBvZiBzZXRzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRyYXdpbmcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvLnN0cm9rZSA9PT0gJ25vbmUnID8gJ3RyYW5zcGFyZW50JyA6IG8uc3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gby5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3Ryb2tlTGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChvLnN0cm9rZUxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoby5zdHJva2VMaW5lRGFzaE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gby5zdHJva2VMaW5lRGFzaE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3VG9Db250ZXh0KGN0eCwgZHJhd2luZywgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbFBhdGgnOiB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvLmZpbGwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxSdWxlID0gKGRyYXdhYmxlLnNoYXBlID09PSAnY3VydmUnIHx8IGRyYXdhYmxlLnNoYXBlID09PSAncG9seWdvbicgfHwgZHJhd2FibGUuc2hhcGUgPT09ICdwYXRoJykgPyAnZXZlbm9kZCcgOiAnbm9uemVybyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdUb0NvbnRleHQoY3R4LCBkcmF3aW5nLCBwcmVjaXNpb24sIGZpbGxSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxTa2V0Y2gnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxTa2V0Y2goY3R4LCBkcmF3aW5nLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlsbFNrZXRjaChjdHgsIGRyYXdpbmcsIG8pIHtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmIChvLmZpbGxMaW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKG8uZmlsbExpbmVEYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5maWxsTGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG8uZmlsbExpbmVEYXNoT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG8uZmlsbCB8fCAnJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGZ3ZWlnaHQ7XG4gICAgICAgIHRoaXMuX2RyYXdUb0NvbnRleHQoY3R4LCBkcmF3aW5nLCBvLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgX2RyYXdUb0NvbnRleHQoY3R4LCBkcmF3aW5nLCBmaXhlZERlY2ltYWxzLCBydWxlID0gJ25vbnplcm8nKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRyYXdpbmcub3BzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKCh0eXBlb2YgZml4ZWREZWNpbWFscyA9PT0gJ251bWJlcicpICYmIGZpeGVkRGVjaW1hbHMgPj0gMCkgPyAoaXRlbS5kYXRhLm1hcCgoZCkgPT4gK2QudG9GaXhlZChmaXhlZERlY2ltYWxzKSkpIDogaXRlbS5kYXRhO1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JjdXJ2ZVRvJzpcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSwgZGF0YVs0XSwgZGF0YVs1XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmVUbyc6XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcmF3aW5nLnR5cGUgPT09ICdmaWxsUGF0aCcpIHtcbiAgICAgICAgICAgIGN0eC5maWxsKHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBnZW5lcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbjtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9ucztcbiAgICB9XG4gICAgbGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uZWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5jaXJjbGUoeCwgeSwgZGlhbWV0ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBsaW5lYXJQYXRoKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBwb2x5Z29uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ucG9seWdvbihwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCA9IGZhbHNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5hcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGN1cnZlKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uY3VydmUocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgcGF0aChkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRyYXdpbmcgPSB0aGlzLmdlbi5wYXRoKGQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZHJhd2luZyk7XG4gICAgICAgIHJldHVybiBkcmF3aW5nO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/canvas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/core.js":
/*!******************************************!*\
  !*** ./node_modules/roughjs/bin/core.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGNS: () => (/* binding */ SVGNS)\n/* harmony export */ });\nconst SVGNS = 'http://www.w3.org/2000/svg';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9jb3JlLmpzP2Q5MmYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFNWR05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/dashed-filler.js":
/*!***********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/dashed-filler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DashedFiller: () => (/* binding */ DashedFiller)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kYXNoZWQtZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNpQjtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVFQUFtQjtBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2Rhc2hlZC1maWxsZXIuanM/NmI0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaW5lTGVuZ3RoIH0gZnJvbSAnLi4vZ2VvbWV0cnknO1xuaW1wb3J0IHsgcG9seWdvbkhhY2h1cmVMaW5lcyB9IGZyb20gJy4vc2Nhbi1saW5lLWhhY2h1cmUnO1xuZXhwb3J0IGNsYXNzIERhc2hlZEZpbGxlciB7XG4gICAgY29uc3RydWN0b3IoaGVscGVyKSB7XG4gICAgICAgIHRoaXMuaGVscGVyID0gaGVscGVyO1xuICAgIH1cbiAgICBmaWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxTa2V0Y2gnLCBvcHM6IHRoaXMuZGFzaGVkTGluZShsaW5lcywgbykgfTtcbiAgICB9XG4gICAgZGFzaGVkTGluZShsaW5lcywgbykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBvLmRhc2hPZmZzZXQgPCAwID8gKG8uaGFjaHVyZUdhcCA8IDAgPyAoby5zdHJva2VXaWR0aCAqIDQpIDogby5oYWNodXJlR2FwKSA6IG8uZGFzaE9mZnNldDtcbiAgICAgICAgY29uc3QgZ2FwID0gby5kYXNoR2FwIDwgMCA/IChvLmhhY2h1cmVHYXAgPCAwID8gKG8uc3Ryb2tlV2lkdGggKiA0KSA6IG8uaGFjaHVyZUdhcCkgOiBvLmRhc2hHYXA7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIChvZmZzZXQgKyBnYXApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gKGxlbmd0aCArIGdhcCAtIChjb3VudCAqIChvZmZzZXQgKyBnYXApKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHAxID0gbGluZVswXTtcbiAgICAgICAgICAgIGxldCBwMiA9IGxpbmVbMV07XG4gICAgICAgICAgICBpZiAocDFbMF0gPiBwMlswXSkge1xuICAgICAgICAgICAgICAgIHAxID0gbGluZVsxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGxpbmVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IE1hdGguYXRhbigocDJbMV0gLSBwMVsxXSkgLyAocDJbMF0gLSBwMVswXSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbHN0YXJ0ID0gaSAqIChvZmZzZXQgKyBnYXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmQgPSBsc3RhcnQgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBbcDFbMF0gKyAobHN0YXJ0ICogTWF0aC5jb3MoYWxwaGEpKSArIChzdGFydE9mZnNldCAqIE1hdGguY29zKGFscGhhKSksIHAxWzFdICsgbHN0YXJ0ICogTWF0aC5zaW4oYWxwaGEpICsgKHN0YXJ0T2Zmc2V0ICogTWF0aC5zaW4oYWxwaGEpKV07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gW3AxWzBdICsgKGxlbmQgKiBNYXRoLmNvcyhhbHBoYSkpICsgKHN0YXJ0T2Zmc2V0ICogTWF0aC5jb3MoYWxwaGEpKSwgcDFbMV0gKyAobGVuZCAqIE1hdGguc2luKGFscGhhKSkgKyAoc3RhcnRPZmZzZXQgKiBNYXRoLnNpbihhbHBoYSkpXTtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKHN0YXJ0WzBdLCBzdGFydFsxXSwgZW5kWzBdLCBlbmRbMV0sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/dashed-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/dot-filler.js":
/*!********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/dot-filler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DotFiller: () => (/* binding */ DotFiller)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kb3QtZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNpQjtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8saUJBQWlCO0FBQ3BELHNCQUFzQix1RUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kb3QtZmlsbGVyLmpzP2Y0YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmV4cG9ydCBjbGFzcyBEb3RGaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlbHBlcikge1xuICAgICAgICB0aGlzLmhlbHBlciA9IGhlbHBlcjtcbiAgICB9XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIG8gPSBPYmplY3QuYXNzaWduKHt9LCBvLCB7IGhhY2h1cmVBbmdsZTogMCB9KTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG90c09uTGluZXMobGluZXMsIG8pO1xuICAgIH1cbiAgICBkb3RzT25MaW5lcyhsaW5lcywgbykge1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgbGV0IGdhcCA9IG8uaGFjaHVyZUdhcDtcbiAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgIGdhcCA9IG8uc3Ryb2tlV2lkdGggKiA0O1xuICAgICAgICB9XG4gICAgICAgIGdhcCA9IE1hdGgubWF4KGdhcCwgMC4xKTtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvID0gZ2FwIC8gNDtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgZGwgPSBsZW5ndGggLyBnYXA7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGguY2VpbChkbCkgLSAxO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbGVuZ3RoIC0gKGNvdW50ICogZ2FwKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSAoKGxpbmVbMF1bMF0gKyBsaW5lWzFdWzBdKSAvIDIpIC0gKGdhcCAvIDQpO1xuICAgICAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKGxpbmVbMF1bMV0sIGxpbmVbMV1bMV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG1pblkgKyBvZmZzZXQgKyAoaSAqIGdhcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSAoeCAtIHJvKSArIE1hdGgucmFuZG9tKCkgKiAyICogcm87XG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSAoeSAtIHJvKSArIE1hdGgucmFuZG9tKCkgKiAyICogcm87XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmhlbHBlci5lbGxpcHNlKGN4LCBjeSwgZndlaWdodCwgZndlaWdodCwgbyk7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4uZWwub3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnZmlsbFNrZXRjaCcsIG9wcyB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/dot-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/filler.js":
/*!****************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/filler.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFiller: () => (/* binding */ getFiller)\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n/* harmony import */ var _zigzag_filler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zigzag-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/zigzag-filler.js\");\n/* harmony import */ var _hatch_filler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hatch-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hatch-filler.js\");\n/* harmony import */ var _dot_filler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dot-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/dot-filler.js\");\n/* harmony import */ var _dashed_filler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dashed-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/dashed-filler.js\");\n/* harmony import */ var _zigzag_line_filler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zigzag-line-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js\");\n\n\n\n\n\n\nconst fillers = {};\nfunction getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _zigzag_filler__WEBPACK_IMPORTED_MODULE_1__.ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _hatch_filler__WEBPACK_IMPORTED_MODULE_2__.HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _dot_filler__WEBPACK_IMPORTED_MODULE_3__.DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _dashed_filler__WEBPACK_IMPORTED_MODULE_4__.DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _zigzag_line_filler__WEBPACK_IMPORTED_MODULE_5__.ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNGO0FBQ0Y7QUFDSjtBQUNNO0FBQ1M7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0RBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUVBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwREFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2ZpbGxlci5qcz80OTMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhY2h1cmVGaWxsZXIgfSBmcm9tICcuL2hhY2h1cmUtZmlsbGVyJztcbmltcG9ydCB7IFppZ1phZ0ZpbGxlciB9IGZyb20gJy4vemlnemFnLWZpbGxlcic7XG5pbXBvcnQgeyBIYXRjaEZpbGxlciB9IGZyb20gJy4vaGF0Y2gtZmlsbGVyJztcbmltcG9ydCB7IERvdEZpbGxlciB9IGZyb20gJy4vZG90LWZpbGxlcic7XG5pbXBvcnQgeyBEYXNoZWRGaWxsZXIgfSBmcm9tICcuL2Rhc2hlZC1maWxsZXInO1xuaW1wb3J0IHsgWmlnWmFnTGluZUZpbGxlciB9IGZyb20gJy4vemlnemFnLWxpbmUtZmlsbGVyJztcbmNvbnN0IGZpbGxlcnMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxsZXIobywgaGVscGVyKSB7XG4gICAgbGV0IGZpbGxlck5hbWUgPSBvLmZpbGxTdHlsZSB8fCAnaGFjaHVyZSc7XG4gICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgIHN3aXRjaCAoZmlsbGVyTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnemlnemFnJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBaaWdaYWdGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcm9zcy1oYXRjaCc6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgSGF0Y2hGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3RzJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBEb3RGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICAgIGlmICghZmlsbGVyc1tmaWxsZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsZXJzW2ZpbGxlck5hbWVdID0gbmV3IERhc2hlZEZpbGxlcihoZWxwZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ppZ3phZy1saW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBaaWdaYWdMaW5lRmlsbGVyKGhlbHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGFjaHVyZSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZpbGxlck5hbWUgPSAnaGFjaHVyZSc7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgSGFjaHVyZUZpbGxlcihoZWxwZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsbGVyc1tmaWxsZXJOYW1lXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js":
/*!************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/hachure-filler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HachureFiller: () => (/* binding */ HachureFiller)\n/* harmony export */ });\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\nclass HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_0__.polygonHachureLines)(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9oYWNodXJlLWZpbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRDtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVFQUFtQjtBQUN6QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2hhY2h1cmUtZmlsbGVyLmpzP2YzYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9seWdvbkhhY2h1cmVMaW5lcyB9IGZyb20gJy4vc2Nhbi1saW5lLWhhY2h1cmUnO1xuZXhwb3J0IGNsYXNzIEhhY2h1cmVGaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlbHBlcikge1xuICAgICAgICB0aGlzLmhlbHBlciA9IGhlbHBlcjtcbiAgICB9XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pO1xuICAgIH1cbiAgICBfZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMucmVuZGVyTGluZXMobGluZXMsIG8pO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnZmlsbFNrZXRjaCcsIG9wcyB9O1xuICAgIH1cbiAgICByZW5kZXJMaW5lcyhsaW5lcywgbykge1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBvcHMucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKGxpbmVbMF1bMF0sIGxpbmVbMF1bMV0sIGxpbmVbMV1bMF0sIGxpbmVbMV1bMV0sIG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/hatch-filler.js":
/*!**********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/hatch-filler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HatchFiller: () => (/* binding */ HatchFiller)\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n\nclass HatchFiller extends _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9oYXRjaC1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDMUMsMEJBQTBCLDBEQUFhO0FBQzlDO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTyxtQ0FBbUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvaGF0Y2gtZmlsbGVyLmpzPzYwZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFjaHVyZUZpbGxlciB9IGZyb20gJy4vaGFjaHVyZS1maWxsZXInO1xuZXhwb3J0IGNsYXNzIEhhdGNoRmlsbGVyIGV4dGVuZHMgSGFjaHVyZUZpbGxlciB7XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuX2ZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIGNvbnN0IG8yID0gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBoYWNodXJlQW5nbGU6IG8uaGFjaHVyZUFuZ2xlICsgOTAgfSk7XG4gICAgICAgIGNvbnN0IHNldDIgPSB0aGlzLl9maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8yKTtcbiAgICAgICAgc2V0Lm9wcyA9IHNldC5vcHMuY29uY2F0KHNldDIub3BzKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/hatch-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js":
/*!***************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/scan-line-hachure.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polygonHachureLines: () => (/* binding */ polygonHachureLines)\n/* harmony export */ });\n/* harmony import */ var hachure_fill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hachure-fill */ \"(ssr)/./node_modules/hachure-fill/bin/hachure.js\");\n\nfunction polygonHachureLines(polygonList, o) {\n    var _a;\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.round(Math.max(gap, 0.1));\n    let skipOffset = 1;\n    if (o.roughness >= 1) {\n        if ((((_a = o.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {\n            skipOffset = gap;\n        }\n    }\n    return (0,hachure_fill__WEBPACK_IMPORTED_MODULE_0__.hachureLines)(polygonList, gap, angle, skipOffset || 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9zY2FuLWxpbmUtaGFjaHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUNyQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBWTtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvc2Nhbi1saW5lLWhhY2h1cmUuanM/MjYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYWNodXJlTGluZXMgfSBmcm9tICdoYWNodXJlLWZpbGwnO1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25IYWNodXJlTGluZXMocG9seWdvbkxpc3QsIG8pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYW5nbGUgPSBvLmhhY2h1cmVBbmdsZSArIDkwO1xuICAgIGxldCBnYXAgPSBvLmhhY2h1cmVHYXA7XG4gICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgZ2FwID0gby5zdHJva2VXaWR0aCAqIDQ7XG4gICAgfVxuICAgIGdhcCA9IE1hdGgucm91bmQoTWF0aC5tYXgoZ2FwLCAwLjEpKTtcbiAgICBsZXQgc2tpcE9mZnNldCA9IDE7XG4gICAgaWYgKG8ucm91Z2huZXNzID49IDEpIHtcbiAgICAgICAgaWYgKCgoKF9hID0gby5yYW5kb21pemVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dCgpKSB8fCBNYXRoLnJhbmRvbSgpKSA+IDAuNykge1xuICAgICAgICAgICAgc2tpcE9mZnNldCA9IGdhcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBnYXAsIGFuZ2xlLCBza2lwT2Zmc2V0IHx8IDEpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/zigzag-filler.js":
/*!***********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/zigzag-filler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZigZagFiller: () => (/* binding */ ZigZagFiller)\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n\n\n\nclass ZigZagFiller extends _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if ((0,_geometry__WEBPACK_IMPORTED_MODULE_2__.lineLength)([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy96aWd6YWctZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDUztBQUNqQjtBQUNsQywyQkFBMkIsMERBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU8saUJBQWlCO0FBQzNELHNCQUFzQix1RUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy96aWd6YWctZmlsbGVyLmpzPzhhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFjaHVyZUZpbGxlciB9IGZyb20gJy4vaGFjaHVyZS1maWxsZXInO1xuaW1wb3J0IHsgcG9seWdvbkhhY2h1cmVMaW5lcyB9IGZyb20gJy4vc2Nhbi1saW5lLWhhY2h1cmUnO1xuaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmV4cG9ydCBjbGFzcyBaaWdaYWdGaWxsZXIgZXh0ZW5kcyBIYWNodXJlRmlsbGVyIHtcbiAgICBmaWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG8uaGFjaHVyZUdhcDtcbiAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgIGdhcCA9IG8uc3Ryb2tlV2lkdGggKiA0O1xuICAgICAgICB9XG4gICAgICAgIGdhcCA9IE1hdGgubWF4KGdhcCwgMC4xKTtcbiAgICAgICAgY29uc3QgbzIgPSBPYmplY3QuYXNzaWduKHt9LCBvLCB7IGhhY2h1cmVHYXA6IGdhcCB9KTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvMik7XG4gICAgICAgIGNvbnN0IHppZ1phZ0FuZ2xlID0gKE1hdGguUEkgLyAxODApICogby5oYWNodXJlQW5nbGU7XG4gICAgICAgIGNvbnN0IHppZ3phZ0xpbmVzID0gW107XG4gICAgICAgIGNvbnN0IGRneCA9IGdhcCAqIDAuNSAqIE1hdGguY29zKHppZ1phZ0FuZ2xlKTtcbiAgICAgICAgY29uc3QgZGd5ID0gZ2FwICogMC41ICogTWF0aC5zaW4oemlnWmFnQW5nbGUpO1xuICAgICAgICBmb3IgKGNvbnN0IFtwMSwgcDJdIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZUxlbmd0aChbcDEsIHAyXSkpIHtcbiAgICAgICAgICAgICAgICB6aWd6YWdMaW5lcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgW3AxWzBdIC0gZGd4LCBwMVsxXSArIGRneV0sXG4gICAgICAgICAgICAgICAgICAgIFsuLi5wMl0sXG4gICAgICAgICAgICAgICAgXSwgW1xuICAgICAgICAgICAgICAgICAgICBbcDFbMF0gKyBkZ3gsIHAxWzFdIC0gZGd5XSxcbiAgICAgICAgICAgICAgICAgICAgWy4uLnAyXSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLnJlbmRlckxpbmVzKHppZ3phZ0xpbmVzLCBvKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxTa2V0Y2gnLCBvcHMgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/zigzag-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js":
/*!****************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/zigzag-line-filler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZigZagLineFiller: () => (/* binding */ ZigZagLineFiller)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy96aWd6YWctbGluZS1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBQ2lCO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sc0JBQXNCO0FBQ3pELHNCQUFzQix1RUFBbUI7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvemlnemFnLWxpbmUtZmlsbGVyLmpzP2NjMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmV4cG9ydCBjbGFzcyBaaWdaYWdMaW5lRmlsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihoZWxwZXIpIHtcbiAgICAgICAgdGhpcy5oZWxwZXIgPSBoZWxwZXI7XG4gICAgfVxuICAgIGZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgICAgICBjb25zdCBnYXAgPSBvLmhhY2h1cmVHYXAgPCAwID8gKG8uc3Ryb2tlV2lkdGggKiA0KSA6IG8uaGFjaHVyZUdhcDtcbiAgICAgICAgY29uc3Qgem8gPSBvLnppZ3phZ09mZnNldCA8IDAgPyBnYXAgOiBvLnppZ3phZ09mZnNldDtcbiAgICAgICAgbyA9IE9iamVjdC5hc3NpZ24oe30sIG8sIHsgaGFjaHVyZUdhcDogZ2FwICsgem8gfSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdmaWxsU2tldGNoJywgb3BzOiB0aGlzLnppZ3phZ0xpbmVzKGxpbmVzLCB6bywgbykgfTtcbiAgICB9XG4gICAgemlnemFnTGluZXMobGluZXMsIHpvLCBvKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLnJvdW5kKGxlbmd0aCAvICgyICogem8pKTtcbiAgICAgICAgICAgIGxldCBwMSA9IGxpbmVbMF07XG4gICAgICAgICAgICBsZXQgcDIgPSBsaW5lWzFdO1xuICAgICAgICAgICAgaWYgKHAxWzBdID4gcDJbMF0pIHtcbiAgICAgICAgICAgICAgICBwMSA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgcDIgPSBsaW5lWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxwaGEgPSBNYXRoLmF0YW4oKHAyWzFdIC0gcDFbMV0pIC8gKHAyWzBdIC0gcDFbMF0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxzdGFydCA9IGkgKiAyICogem87XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZCA9IChpICsgMSkgKiAyICogem87XG4gICAgICAgICAgICAgICAgY29uc3QgZHogPSBNYXRoLnNxcnQoMiAqIE1hdGgucG93KHpvLCAyKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBbcDFbMF0gKyAobHN0YXJ0ICogTWF0aC5jb3MoYWxwaGEpKSwgcDFbMV0gKyBsc3RhcnQgKiBNYXRoLnNpbihhbHBoYSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IFtwMVswXSArIChsZW5kICogTWF0aC5jb3MoYWxwaGEpKSwgcDFbMV0gKyAobGVuZCAqIE1hdGguc2luKGFscGhhKSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IFtzdGFydFswXSArIGR6ICogTWF0aC5jb3MoYWxwaGEgKyBNYXRoLlBJIC8gNCksIHN0YXJ0WzFdICsgZHogKiBNYXRoLnNpbihhbHBoYSArIE1hdGguUEkgLyA0KV07XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhzdGFydFswXSwgc3RhcnRbMV0sIG1pZGRsZVswXSwgbWlkZGxlWzFdLCBvKSwgLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhtaWRkbGVbMF0sIG1pZGRsZVsxXSwgZW5kWzBdLCBlbmRbMV0sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/generator.js":
/*!***********************************************!*\
  !*** ./node_modules/roughjs/bin/generator.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughGenerator: () => (/* binding */ RoughGenerator)\n/* harmony export */ });\n/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer.js */ \"(ssr)/./node_modules/roughjs/bin/renderer.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/roughjs/bin/math.js\");\n/* harmony import */ var points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! points-on-curve/lib/curve-to-bezier.js */ \"(ssr)/./node_modules/points-on-curve/lib/curve-to-bezier.js\");\n/* harmony import */ var points_on_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! points-on-curve */ \"(ssr)/./node_modules/points-on-curve/lib/index.js\");\n/* harmony import */ var points_on_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! points-on-path */ \"(ssr)/./node_modules/points-on-path/lib/index.js\");\n\n\n\n\n\nconst NOS = 'none';\nclass RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.randomSeed)();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [(0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.line)(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.rectangle)(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)([points], o));\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.generateEllipseParams)(width, height, o);\n        const ellipseResponse = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.ellipseWithParams)(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.ellipseWithParams)(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [(0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.arc)(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.arc)(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillArc)(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.curve)(points, o);\n        if (o.fill && o.fill !== NOS) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.curve)(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const polyPoints = [];\n                const inputPoints = points;\n                if (inputPoints.length) {\n                    const p1 = inputPoints[0];\n                    const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n                    for (const points of pointsList) {\n                        if (points.length < 3) {\n                            polyPoints.push(...points);\n                        }\n                        else if (points.length === 3) {\n                            polyPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_3__.pointsOnBezierCurves)((0,points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__.curveToBezier)([\n                                points[0],\n                                points[0],\n                                points[1],\n                                points[2],\n                            ]), 10, (1 + o.roughness) / 2));\n                        }\n                        else {\n                            polyPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_3__.pointsOnBezierCurves)((0,points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__.curveToBezier)(points), 10, (1 + o.roughness) / 2));\n                        }\n                    }\n                }\n                if (polyPoints.length) {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([polyPoints], o));\n                }\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)([points], o));\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = (0,points_on_path__WEBPACK_IMPORTED_MODULE_4__.pointsOnPath)(d, 1, distance);\n        const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.svgPath)(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.svgPath)(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)(sets, o));\n                }\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrTDtBQUMzSTtBQUNnQztBQUNoQjtBQUNUO0FBQzlDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBVTtBQUN6QjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBZ0I7QUFDM0M7QUFDQTtBQUNBLDJCQUEyQixpRUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQXFCO0FBQ25ELGdDQUFnQywrREFBaUI7QUFDakQ7QUFDQTtBQUNBLDhCQUE4QiwrREFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQUc7QUFDM0I7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDhCQUE4QixpREFBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBSztBQUM3QjtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFLLHVDQUF1QyxRQUFRLGlHQUFpRztBQUN2TDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFFQUFvQixDQUFDLHFGQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFFQUFvQixDQUFDLHFGQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFVO0FBQ2xDO0FBQ0E7QUFDQSwyQkFBMkIsOERBQWdCO0FBQzNDO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBWTtBQUNqQyxzQkFBc0IscURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFEQUFPLGtDQUFrQyxRQUFRLGlHQUFpRztBQUN4TDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLCtCQUErQiw4REFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdEQUFVO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTLEVBQUUsU0FBUztBQUNwRDtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxRQUFRLElBQUksU0FBUyxFQUFFLFFBQVEsSUFBSSxTQUFTLEVBQUUsU0FBUztBQUNsRztBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2dlbmVyYXRvci5qcz9kZWVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpbmUsIHNvbGlkRmlsbFBvbHlnb24sIHBhdHRlcm5GaWxsUG9seWdvbnMsIHJlY3RhbmdsZSwgZWxsaXBzZVdpdGhQYXJhbXMsIGdlbmVyYXRlRWxsaXBzZVBhcmFtcywgbGluZWFyUGF0aCwgYXJjLCBwYXR0ZXJuRmlsbEFyYywgY3VydmUsIHN2Z1BhdGggfSBmcm9tICcuL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IHJhbmRvbVNlZWQgfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHsgY3VydmVUb0JlemllciB9IGZyb20gJ3BvaW50cy1vbi1jdXJ2ZS9saWIvY3VydmUtdG8tYmV6aWVyLmpzJztcbmltcG9ydCB7IHBvaW50c09uQmV6aWVyQ3VydmVzIH0gZnJvbSAncG9pbnRzLW9uLWN1cnZlJztcbmltcG9ydCB7IHBvaW50c09uUGF0aCB9IGZyb20gJ3BvaW50cy1vbi1wYXRoJztcbmNvbnN0IE5PUyA9ICdub25lJztcbmV4cG9ydCBjbGFzcyBSb3VnaEdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXhSYW5kb21uZXNzT2Zmc2V0OiAyLFxuICAgICAgICAgICAgcm91Z2huZXNzOiAxLFxuICAgICAgICAgICAgYm93aW5nOiAxLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIGN1cnZlVGlnaHRuZXNzOiAwLFxuICAgICAgICAgICAgY3VydmVGaXR0aW5nOiAwLjk1LFxuICAgICAgICAgICAgY3VydmVTdGVwQ291bnQ6IDksXG4gICAgICAgICAgICBmaWxsU3R5bGU6ICdoYWNodXJlJyxcbiAgICAgICAgICAgIGZpbGxXZWlnaHQ6IC0xLFxuICAgICAgICAgICAgaGFjaHVyZUFuZ2xlOiAtNDEsXG4gICAgICAgICAgICBoYWNodXJlR2FwOiAtMSxcbiAgICAgICAgICAgIGRhc2hPZmZzZXQ6IC0xLFxuICAgICAgICAgICAgZGFzaEdhcDogLTEsXG4gICAgICAgICAgICB6aWd6YWdPZmZzZXQ6IC0xLFxuICAgICAgICAgICAgc2VlZDogMCxcbiAgICAgICAgICAgIGRpc2FibGVNdWx0aVN0cm9rZTogZmFsc2UsXG4gICAgICAgICAgICBkaXNhYmxlTXVsdGlTdHJva2VGaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIHByZXNlcnZlVmVydGljZXM6IGZhbHNlLFxuICAgICAgICAgICAgZmlsbFNoYXBlUm91Z2huZXNzR2FpbjogMC44LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB0aGlzLl9vKHRoaXMuY29uZmlnLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBuZXdTZWVkKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tU2VlZCgpO1xuICAgIH1cbiAgICBfbyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucykgOiB0aGlzLmRlZmF1bHRPcHRpb25zO1xuICAgIH1cbiAgICBfZChzaGFwZSwgc2V0cywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4geyBzaGFwZSwgc2V0czogc2V0cyB8fCBbXSwgb3B0aW9uczogb3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRPcHRpb25zIH07XG4gICAgfVxuICAgIGxpbmUoeDEsIHkxLCB4MiwgeTIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdsaW5lJywgW2xpbmUoeDEsIHkxLCB4MiwgeTIsIG8pXSwgbyk7XG4gICAgfVxuICAgIHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gcmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG8pO1xuICAgICAgICBpZiAoby5maWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbW3gsIHldLCBbeCArIHdpZHRoLCB5XSwgW3ggKyB3aWR0aCwgeSArIGhlaWdodF0sIFt4LCB5ICsgaGVpZ2h0XV07XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNvbGlkRmlsbFBvbHlnb24oW3BvaW50c10sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhbcG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvLnN0cm9rZSAhPT0gTk9TKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKG91dGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdyZWN0YW5nbGUnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fbyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgY29uc3QgZWxsaXBzZVBhcmFtcyA9IGdlbmVyYXRlRWxsaXBzZVBhcmFtcyh3aWR0aCwgaGVpZ2h0LCBvKTtcbiAgICAgICAgY29uc3QgZWxsaXBzZVJlc3BvbnNlID0gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgZWxsaXBzZVBhcmFtcyk7XG4gICAgICAgIGlmIChvLmZpbGwpIHtcbiAgICAgICAgICAgIGlmIChvLmZpbGxTdHlsZSA9PT0gJ3NvbGlkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgZWxsaXBzZVBhcmFtcykub3BzZXQ7XG4gICAgICAgICAgICAgICAgc2hhcGUudHlwZSA9ICdmaWxsUGF0aCc7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdHRlcm5GaWxsUG9seWdvbnMoW2VsbGlwc2VSZXNwb25zZS5lc3RpbWF0ZWRQb2ludHNdLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uc3Ryb2tlICE9PSBOT1MpIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2goZWxsaXBzZVJlc3BvbnNlLm9wc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgnZWxsaXBzZScsIHBhdGhzLCBvKTtcbiAgICB9XG4gICAgY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuZWxsaXBzZSh4LCB5LCBkaWFtZXRlciwgZGlhbWV0ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXQuc2hhcGUgPSAnY2lyY2xlJztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdsaW5lYXJQYXRoJywgW2xpbmVhclBhdGgocG9pbnRzLCBmYWxzZSwgbyldLCBvKTtcbiAgICB9XG4gICAgYXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBjbG9zZWQgPSBmYWxzZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fbyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgY2xvc2VkLCB0cnVlLCBvKTtcbiAgICAgICAgaWYgKGNsb3NlZCAmJiBvLmZpbGwpIHtcbiAgICAgICAgICAgIGlmIChvLmZpbGxTdHlsZSA9PT0gJ3NvbGlkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbyk7XG4gICAgICAgICAgICAgICAgZmlsbE9wdGlvbnMuZGlzYWJsZU11bHRpU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZSA9IGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgdHJ1ZSwgZmFsc2UsIGZpbGxPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBzaGFwZS50eXBlID0gJ2ZpbGxQYXRoJztcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxBcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5zdHJva2UgIT09IE5PUykge1xuICAgICAgICAgICAgcGF0aHMucHVzaChvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgnYXJjJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBjdXJ2ZShwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBjdXJ2ZShwb2ludHMsIG8pO1xuICAgICAgICBpZiAoby5maWxsICYmIG8uZmlsbCAhPT0gTk9TKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU2hhcGUgPSBjdXJ2ZShwb2ludHMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbyksIHsgZGlzYWJsZU11bHRpU3Ryb2tlOiB0cnVlLCByb3VnaG5lc3M6IG8ucm91Z2huZXNzID8gKG8ucm91Z2huZXNzICsgby5maWxsU2hhcGVSb3VnaG5lc3NHYWluKSA6IDAgfSkpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmlsbFBhdGgnLFxuICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMuX21lcmdlZFNoYXBlKGZpbGxTaGFwZS5vcHMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9seVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0UG9pbnRzID0gcG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcDEgPSBpbnB1dFBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzTGlzdCA9ICh0eXBlb2YgcDFbMF0gPT09ICdudW1iZXInKSA/IFtpbnB1dFBvaW50c10gOiBpbnB1dFBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludHMgb2YgcG9pbnRzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seVBvaW50cy5wdXNoKC4uLnBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seVBvaW50cy5wdXNoKC4uLnBvaW50c09uQmV6aWVyQ3VydmVzKGN1cnZlVG9CZXppZXIoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIDEwLCAoMSArIG8ucm91Z2huZXNzKSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlQb2ludHMucHVzaCguLi5wb2ludHNPbkJlemllckN1cnZlcyhjdXJ2ZVRvQmV6aWVyKHBvaW50cyksIDEwLCAoMSArIG8ucm91Z2huZXNzKSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9seVBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXR0ZXJuRmlsbFBvbHlnb25zKFtwb2x5UG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5zdHJva2UgIT09IE5PUykge1xuICAgICAgICAgICAgcGF0aHMucHVzaChvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgnY3VydmUnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIHBvbHlnb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gbGluZWFyUGF0aChwb2ludHMsIHRydWUsIG8pO1xuICAgICAgICBpZiAoby5maWxsKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNvbGlkRmlsbFBvbHlnb24oW3BvaW50c10sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhbcG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvLnN0cm9rZSAhPT0gTk9TKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKG91dGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdwb2x5Z29uJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBwYXRoKGQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ3BhdGgnLCBwYXRocywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgZCA9IChkIHx8ICcnKS5yZXBsYWNlKC9cXG4vZywgJyAnKS5yZXBsYWNlKC8oLVxccykvZywgJy0nKS5yZXBsYWNlKCcvKFxcc1xccykvZycsICcgJyk7XG4gICAgICAgIGNvbnN0IGhhc0ZpbGwgPSBvLmZpbGwgJiYgby5maWxsICE9PSAndHJhbnNwYXJlbnQnICYmIG8uZmlsbCAhPT0gTk9TO1xuICAgICAgICBjb25zdCBoYXNTdHJva2UgPSBvLnN0cm9rZSAhPT0gTk9TO1xuICAgICAgICBjb25zdCBzaW1wbGlmaWVkID0gISEoby5zaW1wbGlmaWNhdGlvbiAmJiAoby5zaW1wbGlmaWNhdGlvbiA8IDEpKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBzaW1wbGlmaWVkID8gKDQgLSA0ICogKG8uc2ltcGxpZmljYXRpb24gfHwgMSkpIDogKCgxICsgby5yb3VnaG5lc3MpIC8gMik7XG4gICAgICAgIGNvbnN0IHNldHMgPSBwb2ludHNPblBhdGgoZCwgMSwgZGlzdGFuY2UpO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHN2Z1BhdGgoZCwgbyk7XG4gICAgICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsbFNoYXBlID0gc3ZnUGF0aChkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG8pLCB7IGRpc2FibGVNdWx0aVN0cm9rZTogdHJ1ZSwgcm91Z2huZXNzOiBvLnJvdWdobmVzcyA/IChvLnJvdWdobmVzcyArIG8uZmlsbFNoYXBlUm91Z2huZXNzR2FpbikgOiAwIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmlsbFBhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0aGlzLl9tZXJnZWRTaGFwZShmaWxsU2hhcGUub3BzKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNvbGlkRmlsbFBvbHlnb24oc2V0cywgbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhzZXRzLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0cm9rZSkge1xuICAgICAgICAgICAgaWYgKHNpbXBsaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRzLmZvckVhY2goKHNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKGxpbmVhclBhdGgoc2V0LCBmYWxzZSwgbykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ3BhdGgnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIG9wc1RvUGF0aChkcmF3aW5nLCBmaXhlZERlY2ltYWxzKSB7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkcmF3aW5nLm9wcykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIGZpeGVkRGVjaW1hbHMgPT09ICdudW1iZXInKSAmJiBmaXhlZERlY2ltYWxzID49IDApID8gKGl0ZW0uZGF0YS5tYXAoKGQpID0+ICtkLnRvRml4ZWQoZml4ZWREZWNpbWFscykpKSA6IGl0ZW0uZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IGBNJHtkYXRhWzBdfSAke2RhdGFbMV19IGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JjdXJ2ZVRvJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBgQyR7ZGF0YVswXX0gJHtkYXRhWzFdfSwgJHtkYXRhWzJdfSAke2RhdGFbM119LCAke2RhdGFbNF19ICR7ZGF0YVs1XX0gYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZVRvJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBgTCR7ZGF0YVswXX0gJHtkYXRhWzFdfSBgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC50cmltKCk7XG4gICAgfVxuICAgIHRvUGF0aHMoZHJhd2FibGUpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IGRyYXdhYmxlLnNldHMgfHwgW107XG4gICAgICAgIGNvbnN0IG8gPSBkcmF3YWJsZS5vcHRpb25zIHx8IHRoaXMuZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZHJhd2luZyBvZiBzZXRzKSB7XG4gICAgICAgICAgICBsZXQgcGF0aCA9IG51bGw7XG4gICAgICAgICAgICBzd2l0Y2ggKGRyYXdpbmcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDogdGhpcy5vcHNUb1BhdGgoZHJhd2luZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG8uc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG8uc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBOT1MsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxQYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ6IHRoaXMub3BzVG9QYXRoKGRyYXdpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBOT1MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IG8uZmlsbCB8fCBOT1MsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxTa2V0Y2gnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5maWxsU2tldGNoKGRyYXdpbmcsIG8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfVxuICAgIGZpbGxTa2V0Y2goZHJhd2luZywgbykge1xuICAgICAgICBsZXQgZndlaWdodCA9IG8uZmlsbFdlaWdodDtcbiAgICAgICAgaWYgKGZ3ZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBmd2VpZ2h0ID0gby5zdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGQ6IHRoaXMub3BzVG9QYXRoKGRyYXdpbmcpLFxuICAgICAgICAgICAgc3Ryb2tlOiBvLmZpbGwgfHwgTk9TLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IGZ3ZWlnaHQsXG4gICAgICAgICAgICBmaWxsOiBOT1MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9tZXJnZWRTaGFwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQub3AgPT09ICdtb3ZlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/generator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/geometry.js":
/*!**********************************************!*\
  !*** ./node_modules/roughjs/bin/geometry.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lineLength: () => (/* binding */ lineLength)\n/* harmony export */ });\nfunction lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZ2VvbWV0cnkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9nZW9tZXRyeS5qcz9iZGM4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBsaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBjb25zdCBwMSA9IGxpbmVbMF07XG4gICAgY29uc3QgcDIgPSBsaW5lWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgKyBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/geometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/math.js":
/*!******************************************!*\
  !*** ./node_modules/roughjs/bin/math.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Random: () => (/* binding */ Random),\n/* harmony export */   randomSeed: () => (/* binding */ randomSeed)\n/* harmony export */ });\nfunction randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nclass Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vbWF0aC5qcz9mN2FiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByYW5kb21TZWVkKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICoqIDMxKTtcbn1cbmV4cG9ydCBjbGFzcyBSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgoMiAqKiAzMSAtIDEpICYgKHRoaXMuc2VlZCA9IE1hdGguaW11bCg0ODI3MSwgdGhpcy5zZWVkKSkpIC8gMiAqKiAzMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/renderer.js":
/*!**********************************************!*\
  !*** ./node_modules/roughjs/bin/renderer.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arc: () => (/* binding */ arc),\n/* harmony export */   curve: () => (/* binding */ curve),\n/* harmony export */   doubleLineFillOps: () => (/* binding */ doubleLineFillOps),\n/* harmony export */   ellipse: () => (/* binding */ ellipse),\n/* harmony export */   ellipseWithParams: () => (/* binding */ ellipseWithParams),\n/* harmony export */   generateEllipseParams: () => (/* binding */ generateEllipseParams),\n/* harmony export */   line: () => (/* binding */ line),\n/* harmony export */   linearPath: () => (/* binding */ linearPath),\n/* harmony export */   patternFillArc: () => (/* binding */ patternFillArc),\n/* harmony export */   patternFillPolygons: () => (/* binding */ patternFillPolygons),\n/* harmony export */   polygon: () => (/* binding */ polygon),\n/* harmony export */   randOffset: () => (/* binding */ randOffset),\n/* harmony export */   randOffsetWithRange: () => (/* binding */ randOffsetWithRange),\n/* harmony export */   rectangle: () => (/* binding */ rectangle),\n/* harmony export */   solidFillPolygon: () => (/* binding */ solidFillPolygon),\n/* harmony export */   svgPath: () => (/* binding */ svgPath)\n/* harmony export */ });\n/* harmony import */ var _fillers_filler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fillers/filler.js */ \"(ssr)/./node_modules/roughjs/bin/fillers/filler.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/roughjs/bin/math.js\");\n/* harmony import */ var path_data_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-data-parser */ \"(ssr)/./node_modules/path-data-parser/lib/index.js\");\n\n\n\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nfunction line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nfunction linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nfunction polygon(points, o) {\n    return linearPath(points, true, o);\n}\nfunction rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nfunction curve(inputPoints, o) {\n    if (inputPoints.length) {\n        const p1 = inputPoints[0];\n        const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n        const o1 = _curveWithOffset(pointsList[0], 1 * (1 + o.roughness * 0.2), o);\n        const o2 = o.disableMultiStroke ? [] : _curveWithOffset(pointsList[0], 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        for (let i = 1; i < pointsList.length; i++) {\n            const points = pointsList[i];\n            if (points.length) {\n                const underlay = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n                const overlay = o.disableMultiStroke ? [] : _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n                for (const item of underlay) {\n                    if (item.op !== 'move') {\n                        o1.push(item);\n                    }\n                }\n                for (const item of overlay) {\n                    if (item.op !== 'move') {\n                        o2.push(item);\n                    }\n                }\n            }\n        }\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    return { type: 'path', ops: [] };\n}\nfunction ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nfunction generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nfunction ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nfunction arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nfunction svgPath(path, o) {\n    const segments = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.normalize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.absolutize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.parsePath)(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nfunction solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nfunction patternFillPolygons(polygonList, o) {\n    return (0,_fillers_filler_js__WEBPACK_IMPORTED_MODULE_0__.getFiller)(o, helper).fillPolygons(polygonList, o);\n}\nfunction patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nfunction randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nfunction randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nfunction doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new _math_js__WEBPACK_IMPORTED_MODULE_1__.Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    if (!points.length) {\n        return [];\n    }\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._line(points[0][0], points[0][1], points[1][0], points[1][1], o, true, true));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNiO0FBQ2lDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhCQUE4QixJQUFJLDBFQUEwRTtBQUNuSTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxxQkFBcUIsMkRBQVMsQ0FBQyw0REFBVSxDQUFDLDJEQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnR0FBZ0c7QUFDM0gsZ0NBQWdDLFNBQVM7QUFDekMsK0JBQStCLGtHQUFrRztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1AsV0FBVyw2REFBUztBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRDQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWdEO0FBQ25FLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEVBQThFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0RkFBNEY7QUFDbkg7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFnRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsOElBQThJO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9yZW5kZXJlci5qcz9iZmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZpbGxlciB9IGZyb20gJy4vZmlsbGVycy9maWxsZXIuanMnO1xuaW1wb3J0IHsgUmFuZG9tIH0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7IHBhcnNlUGF0aCwgbm9ybWFsaXplLCBhYnNvbHV0aXplIH0gZnJvbSAncGF0aC1kYXRhLXBhcnNlcic7XG5jb25zdCBoZWxwZXIgPSB7XG4gICAgcmFuZE9mZnNldCxcbiAgICByYW5kT2Zmc2V0V2l0aFJhbmdlLFxuICAgIGVsbGlwc2UsXG4gICAgZG91YmxlTGluZU9wczogZG91YmxlTGluZUZpbGxPcHMsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIsIG8pIHtcbiAgICByZXR1cm4geyB0eXBlOiAncGF0aCcsIG9wczogX2RvdWJsZUxpbmUoeDEsIHkxLCB4MiwgeTIsIG8pIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUGF0aChwb2ludHMsIGNsb3NlLCBvKSB7XG4gICAgY29uc3QgbGVuID0gKHBvaW50cyB8fCBbXSkubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBvcHMucHVzaCguLi5fZG91YmxlTGluZShwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSwgcG9pbnRzW2kgKyAxXVswXSwgcG9pbnRzW2kgKyAxXVsxXSwgbykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUocG9pbnRzW2xlbiAtIDFdWzBdLCBwb2ludHNbbGVuIC0gMV1bMV0sIHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdLCBvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3BhdGgnLCBvcHMgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIHJldHVybiBsaW5lKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdLCBwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXSwgbyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzOiBbXSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24ocG9pbnRzLCBvKSB7XG4gICAgcmV0dXJuIGxpbmVhclBhdGgocG9pbnRzLCB0cnVlLCBvKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgbykge1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgICAgW3gsIHldLFxuICAgICAgICBbeCArIHdpZHRoLCB5XSxcbiAgICAgICAgW3ggKyB3aWR0aCwgeSArIGhlaWdodF0sXG4gICAgICAgIFt4LCB5ICsgaGVpZ2h0XSxcbiAgICBdO1xuICAgIHJldHVybiBwb2x5Z29uKHBvaW50cywgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VydmUoaW5wdXRQb2ludHMsIG8pIHtcbiAgICBpZiAoaW5wdXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHAxID0gaW5wdXRQb2ludHNbMF07XG4gICAgICAgIGNvbnN0IHBvaW50c0xpc3QgPSAodHlwZW9mIHAxWzBdID09PSAnbnVtYmVyJykgPyBbaW5wdXRQb2ludHNdIDogaW5wdXRQb2ludHM7XG4gICAgICAgIGNvbnN0IG8xID0gX2N1cnZlV2l0aE9mZnNldChwb2ludHNMaXN0WzBdLCAxICogKDEgKyBvLnJvdWdobmVzcyAqIDAuMiksIG8pO1xuICAgICAgICBjb25zdCBvMiA9IG8uZGlzYWJsZU11bHRpU3Ryb2tlID8gW10gOiBfY3VydmVXaXRoT2Zmc2V0KHBvaW50c0xpc3RbMF0sIDEuNSAqICgxICsgby5yb3VnaG5lc3MgKiAwLjIyKSwgY2xvbmVPcHRpb25zQWx0ZXJTZWVkKG8pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBwb2ludHNMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmRlcmxheSA9IF9jdXJ2ZVdpdGhPZmZzZXQocG9pbnRzLCAxICogKDEgKyBvLnJvdWdobmVzcyAqIDAuMiksIG8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvLmRpc2FibGVNdWx0aVN0cm9rZSA/IFtdIDogX2N1cnZlV2l0aE9mZnNldChwb2ludHMsIDEuNSAqICgxICsgby5yb3VnaG5lc3MgKiAwLjIyKSwgY2xvbmVPcHRpb25zQWx0ZXJTZWVkKG8pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdW5kZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3AgIT09ICdtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbzEucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcCAhPT0gJ21vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvMi5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzOiBvMS5jb25jYXQobzIpIH07XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzOiBbXSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgbykge1xuICAgIGNvbnN0IHBhcmFtcyA9IGdlbmVyYXRlRWxsaXBzZVBhcmFtcyh3aWR0aCwgaGVpZ2h0LCBvKTtcbiAgICByZXR1cm4gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgcGFyYW1zKS5vcHNldDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVsbGlwc2VQYXJhbXMod2lkdGgsIGhlaWdodCwgbykge1xuICAgIGNvbnN0IHBzcSA9IE1hdGguc3FydChNYXRoLlBJICogMiAqIE1hdGguc3FydCgoTWF0aC5wb3cod2lkdGggLyAyLCAyKSArIE1hdGgucG93KGhlaWdodCAvIDIsIDIpKSAvIDIpKTtcbiAgICBjb25zdCBzdGVwQ291bnQgPSBNYXRoLmNlaWwoTWF0aC5tYXgoby5jdXJ2ZVN0ZXBDb3VudCwgKG8uY3VydmVTdGVwQ291bnQgLyBNYXRoLnNxcnQoMjAwKSkgKiBwc3EpKTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSAoTWF0aC5QSSAqIDIpIC8gc3RlcENvdW50O1xuICAgIGxldCByeCA9IE1hdGguYWJzKHdpZHRoIC8gMik7XG4gICAgbGV0IHJ5ID0gTWF0aC5hYnMoaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgY3VydmVGaXRSYW5kb21uZXNzID0gMSAtIG8uY3VydmVGaXR0aW5nO1xuICAgIHJ4ICs9IF9vZmZzZXRPcHQocnggKiBjdXJ2ZUZpdFJhbmRvbW5lc3MsIG8pO1xuICAgIHJ5ICs9IF9vZmZzZXRPcHQocnkgKiBjdXJ2ZUZpdFJhbmRvbW5lc3MsIG8pO1xuICAgIHJldHVybiB7IGluY3JlbWVudCwgcngsIHJ5IH07XG59XG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgZWxsaXBzZVBhcmFtcykge1xuICAgIGNvbnN0IFthcDEsIGNwMV0gPSBfY29tcHV0ZUVsbGlwc2VQb2ludHMoZWxsaXBzZVBhcmFtcy5pbmNyZW1lbnQsIHgsIHksIGVsbGlwc2VQYXJhbXMucngsIGVsbGlwc2VQYXJhbXMucnksIDEsIGVsbGlwc2VQYXJhbXMuaW5jcmVtZW50ICogX29mZnNldCgwLjEsIF9vZmZzZXQoMC40LCAxLCBvKSwgbyksIG8pO1xuICAgIGxldCBvMSA9IF9jdXJ2ZShhcDEsIG51bGwsIG8pO1xuICAgIGlmICgoIW8uZGlzYWJsZU11bHRpU3Ryb2tlKSAmJiAoby5yb3VnaG5lc3MgIT09IDApKSB7XG4gICAgICAgIGNvbnN0IFthcDJdID0gX2NvbXB1dGVFbGxpcHNlUG9pbnRzKGVsbGlwc2VQYXJhbXMuaW5jcmVtZW50LCB4LCB5LCBlbGxpcHNlUGFyYW1zLnJ4LCBlbGxpcHNlUGFyYW1zLnJ5LCAxLjUsIDAsIG8pO1xuICAgICAgICBjb25zdCBvMiA9IF9jdXJ2ZShhcDIsIG51bGwsIG8pO1xuICAgICAgICBvMSA9IG8xLmNvbmNhdChvMik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVzdGltYXRlZFBvaW50czogY3AxLFxuICAgICAgICBvcHNldDogeyB0eXBlOiAncGF0aCcsIG9wczogbzEgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgY2xvc2VkLCByb3VnaENsb3N1cmUsIG8pIHtcbiAgICBjb25zdCBjeCA9IHg7XG4gICAgY29uc3QgY3kgPSB5O1xuICAgIGxldCByeCA9IE1hdGguYWJzKHdpZHRoIC8gMik7XG4gICAgbGV0IHJ5ID0gTWF0aC5hYnMoaGVpZ2h0IC8gMik7XG4gICAgcnggKz0gX29mZnNldE9wdChyeCAqIDAuMDEsIG8pO1xuICAgIHJ5ICs9IF9vZmZzZXRPcHQocnkgKiAwLjAxLCBvKTtcbiAgICBsZXQgc3RydCA9IHN0YXJ0O1xuICAgIGxldCBzdHAgPSBzdG9wO1xuICAgIHdoaWxlIChzdHJ0IDwgMCkge1xuICAgICAgICBzdHJ0ICs9IE1hdGguUEkgKiAyO1xuICAgICAgICBzdHAgKz0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGlmICgoc3RwIC0gc3RydCkgPiAoTWF0aC5QSSAqIDIpKSB7XG4gICAgICAgIHN0cnQgPSAwO1xuICAgICAgICBzdHAgPSBNYXRoLlBJICogMjtcbiAgICB9XG4gICAgY29uc3QgZWxsaXBzZUluYyA9IChNYXRoLlBJICogMikgLyBvLmN1cnZlU3RlcENvdW50O1xuICAgIGNvbnN0IGFyY0luYyA9IE1hdGgubWluKGVsbGlwc2VJbmMgLyAyLCAoc3RwIC0gc3RydCkgLyAyKTtcbiAgICBjb25zdCBvcHMgPSBfYXJjKGFyY0luYywgY3gsIGN5LCByeCwgcnksIHN0cnQsIHN0cCwgMSwgbyk7XG4gICAgaWYgKCFvLmRpc2FibGVNdWx0aVN0cm9rZSkge1xuICAgICAgICBjb25zdCBvMiA9IF9hcmMoYXJjSW5jLCBjeCwgY3ksIHJ4LCByeSwgc3RydCwgc3RwLCAxLjUsIG8pO1xuICAgICAgICBvcHMucHVzaCguLi5vMik7XG4gICAgfVxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgaWYgKHJvdWdoQ2xvc3VyZSkge1xuICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUoY3gsIGN5LCBjeCArIHJ4ICogTWF0aC5jb3Moc3RydCksIGN5ICsgcnkgKiBNYXRoLnNpbihzdHJ0KSwgbyksIC4uLl9kb3VibGVMaW5lKGN4LCBjeSwgY3ggKyByeCAqIE1hdGguY29zKHN0cCksIGN5ICsgcnkgKiBNYXRoLnNpbihzdHApLCBvKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbGluZVRvJywgZGF0YTogW2N4LCBjeV0gfSwgeyBvcDogJ2xpbmVUbycsIGRhdGE6IFtjeCArIHJ4ICogTWF0aC5jb3Moc3RydCksIGN5ICsgcnkgKiBNYXRoLnNpbihzdHJ0KV0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3BhdGgnLCBvcHMgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdmdQYXRoKHBhdGgsIG8pIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IG5vcm1hbGl6ZShhYnNvbHV0aXplKHBhcnNlUGF0aChwYXRoKSkpO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IFswLCAwXTtcbiAgICBsZXQgY3VycmVudCA9IFswLCAwXTtcbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkYXRhIH0gb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFtkYXRhWzBdLCBkYXRhWzFdXTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IFtkYXRhWzBdLCBkYXRhWzFdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIG9wcy5wdXNoKC4uLl9kb3VibGVMaW5lKGN1cnJlbnRbMF0sIGN1cnJlbnRbMV0sIGRhdGFbMF0sIGRhdGFbMV0sIG8pKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gW2RhdGFbMF0sIGRhdGFbMV1dO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTIsIHgsIHldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCguLi5fYmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgsIHksIGN1cnJlbnQsIG8pKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gW3gsIHldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUoY3VycmVudFswXSwgY3VycmVudFsxXSwgZmlyc3RbMF0sIGZpcnN0WzFdLCBvKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFtmaXJzdFswXSwgZmlyc3RbMV1dO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzIH07XG59XG4vLyBGaWxsc1xuZXhwb3J0IGZ1bmN0aW9uIHNvbGlkRmlsbFBvbHlnb24ocG9seWdvbkxpc3QsIG8pIHtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBwb2x5Z29uTGlzdCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gby5tYXhSYW5kb21uZXNzT2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtwb2ludHNbMF1bMF0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksIHBvaW50c1swXVsxXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKV0gfSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbGluZVRvJywgZGF0YTogW3BvaW50c1tpXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSwgcG9pbnRzW2ldWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxQYXRoJywgb3BzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0dGVybkZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgIHJldHVybiBnZXRGaWxsZXIobywgaGVscGVyKS5maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm5GaWxsQXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBvKSB7XG4gICAgY29uc3QgY3ggPSB4O1xuICAgIGNvbnN0IGN5ID0geTtcbiAgICBsZXQgcnggPSBNYXRoLmFicyh3aWR0aCAvIDIpO1xuICAgIGxldCByeSA9IE1hdGguYWJzKGhlaWdodCAvIDIpO1xuICAgIHJ4ICs9IF9vZmZzZXRPcHQocnggKiAwLjAxLCBvKTtcbiAgICByeSArPSBfb2Zmc2V0T3B0KHJ5ICogMC4wMSwgbyk7XG4gICAgbGV0IHN0cnQgPSBzdGFydDtcbiAgICBsZXQgc3RwID0gc3RvcDtcbiAgICB3aGlsZSAoc3RydCA8IDApIHtcbiAgICAgICAgc3RydCArPSBNYXRoLlBJICogMjtcbiAgICAgICAgc3RwICs9IE1hdGguUEkgKiAyO1xuICAgIH1cbiAgICBpZiAoKHN0cCAtIHN0cnQpID4gKE1hdGguUEkgKiAyKSkge1xuICAgICAgICBzdHJ0ID0gMDtcbiAgICAgICAgc3RwID0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGNvbnN0IGluY3JlbWVudCA9IChzdHAgLSBzdHJ0KSAvIG8uY3VydmVTdGVwQ291bnQ7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgYW5nbGUgPSBzdHJ0OyBhbmdsZSA8PSBzdHA7IGFuZ2xlID0gYW5nbGUgKyBpbmNyZW1lbnQpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goW2N4ICsgcnggKiBNYXRoLmNvcyhhbmdsZSksIGN5ICsgcnkgKiBNYXRoLnNpbihhbmdsZSldKTtcbiAgICB9XG4gICAgcG9pbnRzLnB1c2goW2N4ICsgcnggKiBNYXRoLmNvcyhzdHApLCBjeSArIHJ5ICogTWF0aC5zaW4oc3RwKV0pO1xuICAgIHBvaW50cy5wdXNoKFtjeCwgY3ldKTtcbiAgICByZXR1cm4gcGF0dGVybkZpbGxQb2x5Z29ucyhbcG9pbnRzXSwgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZE9mZnNldCh4LCBvKSB7XG4gICAgcmV0dXJuIF9vZmZzZXRPcHQoeCwgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZE9mZnNldFdpdGhSYW5nZShtaW4sIG1heCwgbykge1xuICAgIHJldHVybiBfb2Zmc2V0KG1pbiwgbWF4LCBvKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkb3VibGVMaW5lRmlsbE9wcyh4MSwgeTEsIHgyLCB5Miwgbykge1xuICAgIHJldHVybiBfZG91YmxlTGluZSh4MSwgeTEsIHgyLCB5MiwgbywgdHJ1ZSk7XG59XG4vLyBQcml2YXRlIGhlbHBlcnNcbmZ1bmN0aW9uIGNsb25lT3B0aW9uc0FsdGVyU2VlZChvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHMpO1xuICAgIHJlc3VsdC5yYW5kb21pemVyID0gdW5kZWZpbmVkO1xuICAgIGlmIChvcHMuc2VlZCkge1xuICAgICAgICByZXN1bHQuc2VlZCA9IG9wcy5zZWVkICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJhbmRvbShvcHMpIHtcbiAgICBpZiAoIW9wcy5yYW5kb21pemVyKSB7XG4gICAgICAgIG9wcy5yYW5kb21pemVyID0gbmV3IFJhbmRvbShvcHMuc2VlZCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcy5yYW5kb21pemVyLm5leHQoKTtcbn1cbmZ1bmN0aW9uIF9vZmZzZXQobWluLCBtYXgsIG9wcywgcm91Z2huZXNzR2FpbiA9IDEpIHtcbiAgICByZXR1cm4gb3BzLnJvdWdobmVzcyAqIHJvdWdobmVzc0dhaW4gKiAoKHJhbmRvbShvcHMpICogKG1heCAtIG1pbikpICsgbWluKTtcbn1cbmZ1bmN0aW9uIF9vZmZzZXRPcHQoeCwgb3BzLCByb3VnaG5lc3NHYWluID0gMSkge1xuICAgIHJldHVybiBfb2Zmc2V0KC14LCB4LCBvcHMsIHJvdWdobmVzc0dhaW4pO1xufVxuZnVuY3Rpb24gX2RvdWJsZUxpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIGZpbGxpbmcgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNpbmdsZVN0cm9rZSA9IGZpbGxpbmcgPyBvLmRpc2FibGVNdWx0aVN0cm9rZUZpbGwgOiBvLmRpc2FibGVNdWx0aVN0cm9rZTtcbiAgICBjb25zdCBvMSA9IF9saW5lKHgxLCB5MSwgeDIsIHkyLCBvLCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKHNpbmdsZVN0cm9rZSkge1xuICAgICAgICByZXR1cm4gbzE7XG4gICAgfVxuICAgIGNvbnN0IG8yID0gX2xpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBvMS5jb25jYXQobzIpO1xufVxuZnVuY3Rpb24gX2xpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIG1vdmUsIG92ZXJsYXkpIHtcbiAgICBjb25zdCBsZW5ndGhTcSA9IE1hdGgucG93KCh4MSAtIHgyKSwgMikgKyBNYXRoLnBvdygoeTEgLSB5MiksIDIpO1xuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChsZW5ndGhTcSk7XG4gICAgbGV0IHJvdWdobmVzc0dhaW4gPSAxO1xuICAgIGlmIChsZW5ndGggPCAyMDApIHtcbiAgICAgICAgcm91Z2huZXNzR2FpbiA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbmd0aCA+IDUwMCkge1xuICAgICAgICByb3VnaG5lc3NHYWluID0gMC40O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm91Z2huZXNzR2FpbiA9ICgtMC4wMDE2NjY4KSAqIGxlbmd0aCArIDEuMjMzMzM0O1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gby5tYXhSYW5kb21uZXNzT2Zmc2V0IHx8IDA7XG4gICAgaWYgKChvZmZzZXQgKiBvZmZzZXQgKiAxMDApID4gbGVuZ3RoU3EpIHtcbiAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoIC8gMTA7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgIGNvbnN0IGRpdmVyZ2VQb2ludCA9IDAuMiArIHJhbmRvbShvKSAqIDAuMjtcbiAgICBsZXQgbWlkRGlzcFggPSBvLmJvd2luZyAqIG8ubWF4UmFuZG9tbmVzc09mZnNldCAqICh5MiAtIHkxKSAvIDIwMDtcbiAgICBsZXQgbWlkRGlzcFkgPSBvLmJvd2luZyAqIG8ubWF4UmFuZG9tbmVzc09mZnNldCAqICh4MSAtIHgyKSAvIDIwMDtcbiAgICBtaWREaXNwWCA9IF9vZmZzZXRPcHQobWlkRGlzcFgsIG8sIHJvdWdobmVzc0dhaW4pO1xuICAgIG1pZERpc3BZID0gX29mZnNldE9wdChtaWREaXNwWSwgbywgcm91Z2huZXNzR2Fpbik7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgcmFuZG9tSGFsZiA9ICgpID0+IF9vZmZzZXRPcHQoaGFsZk9mZnNldCwgbywgcm91Z2huZXNzR2Fpbik7XG4gICAgY29uc3QgcmFuZG9tRnVsbCA9ICgpID0+IF9vZmZzZXRPcHQob2Zmc2V0LCBvLCByb3VnaG5lc3NHYWluKTtcbiAgICBjb25zdCBwcmVzZXJ2ZVZlcnRpY2VzID0gby5wcmVzZXJ2ZVZlcnRpY2VzO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdtb3ZlJywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB4MSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUhhbGYoKSksXG4gICAgICAgICAgICAgICAgICAgIHkxICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogcmFuZG9tSGFsZigpKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdtb3ZlJywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB4MSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IF9vZmZzZXRPcHQob2Zmc2V0LCBvLCByb3VnaG5lc3NHYWluKSksXG4gICAgICAgICAgICAgICAgICAgIHkxICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogX29mZnNldE9wdChvZmZzZXQsIG8sIHJvdWdobmVzc0dhaW4pKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgb3A6ICdiY3VydmVUbycsXG4gICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgbWlkRGlzcFggKyB4MSArICh4MiAtIHgxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUhhbGYoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWSArIHkxICsgKHkyIC0geTEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tSGFsZigpLFxuICAgICAgICAgICAgICAgIG1pZERpc3BYICsgeDEgKyAyICogKHgyIC0geDEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tSGFsZigpLFxuICAgICAgICAgICAgICAgIG1pZERpc3BZICsgeTEgKyAyICogKHkyIC0geTEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tSGFsZigpLFxuICAgICAgICAgICAgICAgIHgyICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogcmFuZG9tSGFsZigpKSxcbiAgICAgICAgICAgICAgICB5MiArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUhhbGYoKSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIG1pZERpc3BYICsgeDEgKyAoeDIgLSB4MSkgKiBkaXZlcmdlUG9pbnQgKyByYW5kb21GdWxsKCksXG4gICAgICAgICAgICAgICAgbWlkRGlzcFkgKyB5MSArICh5MiAtIHkxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUZ1bGwoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWCArIHgxICsgMiAqICh4MiAtIHgxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUZ1bGwoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWSArIHkxICsgMiAqICh5MiAtIHkxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUZ1bGwoKSxcbiAgICAgICAgICAgICAgICB4MiArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUZ1bGwoKSksXG4gICAgICAgICAgICAgICAgeTIgKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiByYW5kb21GdWxsKCkpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBfY3VydmVXaXRoT2Zmc2V0KHBvaW50cywgb2Zmc2V0LCBvKSB7XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcHMgPSBbXTtcbiAgICBwcy5wdXNoKFtcbiAgICAgICAgcG9pbnRzWzBdWzBdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICBwb2ludHNbMF1bMV0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksXG4gICAgXSk7XG4gICAgcHMucHVzaChbXG4gICAgICAgIHBvaW50c1swXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgcG9pbnRzWzBdWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgIF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBzLnB1c2goW1xuICAgICAgICAgICAgcG9pbnRzW2ldWzBdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICAgICAgcG9pbnRzW2ldWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGkgPT09IChwb2ludHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHBzLnB1c2goW1xuICAgICAgICAgICAgICAgIHBvaW50c1tpXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgICAgICAgICBwb2ludHNbaV1bMV0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2N1cnZlKHBzLCBudWxsLCBvKTtcbn1cbmZ1bmN0aW9uIF9jdXJ2ZShwb2ludHMsIGNsb3NlUG9pbnQsIG8pIHtcbiAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGlmIChsZW4gPiAzKSB7XG4gICAgICAgIGNvbnN0IGIgPSBbXTtcbiAgICAgICAgY29uc3QgcyA9IDEgLSBvLmN1cnZlVGlnaHRuZXNzO1xuICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXV0gfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyAoaSArIDIpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZlcnRBcnJheSA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGJbMF0gPSBbY2FjaGVkVmVydEFycmF5WzBdLCBjYWNoZWRWZXJ0QXJyYXlbMV1dO1xuICAgICAgICAgICAgYlsxXSA9IFtjYWNoZWRWZXJ0QXJyYXlbMF0gKyAocyAqIHBvaW50c1tpICsgMV1bMF0gLSBzICogcG9pbnRzW2kgLSAxXVswXSkgLyA2LCBjYWNoZWRWZXJ0QXJyYXlbMV0gKyAocyAqIHBvaW50c1tpICsgMV1bMV0gLSBzICogcG9pbnRzW2kgLSAxXVsxXSkgLyA2XTtcbiAgICAgICAgICAgIGJbMl0gPSBbcG9pbnRzW2kgKyAxXVswXSArIChzICogcG9pbnRzW2ldWzBdIC0gcyAqIHBvaW50c1tpICsgMl1bMF0pIC8gNiwgcG9pbnRzW2kgKyAxXVsxXSArIChzICogcG9pbnRzW2ldWzFdIC0gcyAqIHBvaW50c1tpICsgMl1bMV0pIC8gNl07XG4gICAgICAgICAgICBiWzNdID0gW3BvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV1dO1xuICAgICAgICAgICAgb3BzLnB1c2goeyBvcDogJ2JjdXJ2ZVRvJywgZGF0YTogW2JbMV1bMF0sIGJbMV1bMV0sIGJbMl1bMF0sIGJbMl1bMV0sIGJbM11bMF0sIGJbM11bMV1dIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zZVBvaW50ICYmIGNsb3NlUG9pbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBybyA9IG8ubWF4UmFuZG9tbmVzc09mZnNldDtcbiAgICAgICAgICAgIG9wcy5wdXNoKHsgb3A6ICdsaW5lVG8nLCBkYXRhOiBbY2xvc2VQb2ludFswXSArIF9vZmZzZXRPcHQocm8sIG8pLCBjbG9zZVBvaW50WzFdICsgX29mZnNldE9wdChybywgbyldIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMykge1xuICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXV0gfSk7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXVswXSwgcG9pbnRzWzFdWzFdLFxuICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSwgcG9pbnRzWzJdWzFdLFxuICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSwgcG9pbnRzWzJdWzFdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICBvcHMucHVzaCguLi5fbGluZShwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzBdLCBwb2ludHNbMV1bMV0sIG8sIHRydWUsIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIF9jb21wdXRlRWxsaXBzZVBvaW50cyhpbmNyZW1lbnQsIGN4LCBjeSwgcngsIHJ5LCBvZmZzZXQsIG92ZXJsYXAsIG8pIHtcbiAgICBjb25zdCBjb3JlT25seSA9IG8ucm91Z2huZXNzID09PSAwO1xuICAgIGNvbnN0IGNvcmVQb2ludHMgPSBbXTtcbiAgICBjb25zdCBhbGxQb2ludHMgPSBbXTtcbiAgICBpZiAoY29yZU9ubHkpIHtcbiAgICAgICAgaW5jcmVtZW50ID0gaW5jcmVtZW50IC8gNDtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKC1pbmNyZW1lbnQpLFxuICAgICAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKC1pbmNyZW1lbnQpLFxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChsZXQgYW5nbGUgPSAwOyBhbmdsZSA8PSBNYXRoLlBJICogMjsgYW5nbGUgPSBhbmdsZSArIGluY3JlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IFtcbiAgICAgICAgICAgICAgICBjeCArIHJ4ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIGN5ICsgcnkgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29yZVBvaW50cy5wdXNoKHApO1xuICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKDApLFxuICAgICAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKDApLFxuICAgICAgICBdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKGluY3JlbWVudCksXG4gICAgICAgICAgICBjeSArIHJ5ICogTWF0aC5zaW4oaW5jcmVtZW50KSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByYWRPZmZzZXQgPSBfb2Zmc2V0T3B0KDAuNSwgbykgLSAoTWF0aC5QSSAvIDIpO1xuICAgICAgICBhbGxQb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIDAuOSAqIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0IC0gaW5jcmVtZW50KSxcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgMC45ICogcnkgKiBNYXRoLnNpbihyYWRPZmZzZXQgLSBpbmNyZW1lbnQpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBNYXRoLlBJICogMiArIHJhZE9mZnNldCAtIDAuMDE7XG4gICAgICAgIGZvciAobGV0IGFuZ2xlID0gcmFkT2Zmc2V0OyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSA9IGFuZ2xlICsgaW5jcmVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwID0gW1xuICAgICAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgcnggKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3kgKyByeSAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb3JlUG9pbnRzLnB1c2gocCk7XG4gICAgICAgICAgICBhbGxQb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxQb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0ICsgTWF0aC5QSSAqIDIgKyBvdmVybGFwICogMC41KSxcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgcnkgKiBNYXRoLnNpbihyYWRPZmZzZXQgKyBNYXRoLlBJICogMiArIG92ZXJsYXAgKiAwLjUpLFxuICAgICAgICBdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3ggKyAwLjk4ICogcnggKiBNYXRoLmNvcyhyYWRPZmZzZXQgKyBvdmVybGFwKSxcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgMC45OCAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0ICsgb3ZlcmxhcCksXG4gICAgICAgIF0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIDAuOSAqIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0ICsgb3ZlcmxhcCAqIDAuNSksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIDAuOSAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0ICsgb3ZlcmxhcCAqIDAuNSksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gW2FsbFBvaW50cywgY29yZVBvaW50c107XG59XG5mdW5jdGlvbiBfYXJjKGluY3JlbWVudCwgY3gsIGN5LCByeCwgcnksIHN0cnQsIHN0cCwgb2Zmc2V0LCBvKSB7XG4gICAgY29uc3QgcmFkT2Zmc2V0ID0gc3RydCArIF9vZmZzZXRPcHQoMC4xLCBvKTtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBwb2ludHMucHVzaChbXG4gICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgMC45ICogcnggKiBNYXRoLmNvcyhyYWRPZmZzZXQgLSBpbmNyZW1lbnQpLFxuICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIDAuOSAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0IC0gaW5jcmVtZW50KSxcbiAgICBdKTtcbiAgICBmb3IgKGxldCBhbmdsZSA9IHJhZE9mZnNldDsgYW5nbGUgPD0gc3RwOyBhbmdsZSA9IGFuZ2xlICsgaW5jcmVtZW50KSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFtcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgcnggKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIHJ5ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcG9pbnRzLnB1c2goW1xuICAgICAgICBjeCArIHJ4ICogTWF0aC5jb3Moc3RwKSxcbiAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKHN0cCksXG4gICAgXSk7XG4gICAgcG9pbnRzLnB1c2goW1xuICAgICAgICBjeCArIHJ4ICogTWF0aC5jb3Moc3RwKSxcbiAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKHN0cCksXG4gICAgXSk7XG4gICAgcmV0dXJuIF9jdXJ2ZShwb2ludHMsIG51bGwsIG8pO1xufVxuZnVuY3Rpb24gX2JlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBjdXJyZW50LCBvKSB7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgcm9zID0gW28ubWF4UmFuZG9tbmVzc09mZnNldCB8fCAxLCAoby5tYXhSYW5kb21uZXNzT2Zmc2V0IHx8IDEpICsgMC4zXTtcbiAgICBsZXQgZiA9IFswLCAwXTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gby5kaXNhYmxlTXVsdGlTdHJva2UgPyAxIDogMjtcbiAgICBjb25zdCBwcmVzZXJ2ZVZlcnRpY2VzID0gby5wcmVzZXJ2ZVZlcnRpY2VzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtjdXJyZW50WzBdLCBjdXJyZW50WzFdXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wcy5wdXNoKHsgb3A6ICdtb3ZlJywgZGF0YTogW2N1cnJlbnRbMF0gKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiBfb2Zmc2V0T3B0KHJvc1swXSwgbykpLCBjdXJyZW50WzFdICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogX29mZnNldE9wdChyb3NbMF0sIG8pKV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZiA9IHByZXNlcnZlVmVydGljZXMgPyBbeCwgeV0gOiBbeCArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSwgeSArIF9vZmZzZXRPcHQocm9zW2ldLCBvKV07XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIHgxICsgX29mZnNldE9wdChyb3NbaV0sIG8pLCB5MSArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSxcbiAgICAgICAgICAgICAgICB4MiArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSwgeTIgKyBfb2Zmc2V0T3B0KHJvc1tpXSwgbyksXG4gICAgICAgICAgICAgICAgZlswXSwgZlsxXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/renderer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/rough.js":
/*!*******************************************!*\
  !*** ./node_modules/roughjs/bin/rough.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas */ \"(ssr)/./node_modules/roughjs/bin/canvas.js\");\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generator */ \"(ssr)/./node_modules/roughjs/bin/generator.js\");\n/* harmony import */ var _svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svg */ \"(ssr)/./node_modules/roughjs/bin/svg.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    canvas(canvas, config) {\n        return new _canvas__WEBPACK_IMPORTED_MODULE_0__.RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new _svg__WEBPACK_IMPORTED_MODULE_2__.RoughSVG(svg, config);\n    },\n    generator(config) {\n        return new _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator(config);\n    },\n    newSeed() {\n        return _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator.newSeed();\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vcm91Z2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1QztBQUNNO0FBQ1o7QUFDakMsaUVBQWU7QUFDZjtBQUNBLG1CQUFtQixnREFBVztBQUM5QixLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsMENBQVE7QUFDM0IsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLHNEQUFjO0FBQ2pDLEtBQUs7QUFDTDtBQUNBLGVBQWUsc0RBQWM7QUFDN0IsS0FBSztBQUNMLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL3JvdWdoLmpzPzMyNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm91Z2hDYW52YXMgfSBmcm9tICcuL2NhbnZhcyc7XG5pbXBvcnQgeyBSb3VnaEdlbmVyYXRvciB9IGZyb20gJy4vZ2VuZXJhdG9yJztcbmltcG9ydCB7IFJvdWdoU1ZHIH0gZnJvbSAnLi9zdmcnO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNhbnZhcyhjYW52YXMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IFJvdWdoQ2FudmFzKGNhbnZhcywgY29uZmlnKTtcbiAgICB9LFxuICAgIHN2ZyhzdmcsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IFJvdWdoU1ZHKHN2ZywgY29uZmlnKTtcbiAgICB9LFxuICAgIGdlbmVyYXRvcihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VnaEdlbmVyYXRvcihjb25maWcpO1xuICAgIH0sXG4gICAgbmV3U2VlZCgpIHtcbiAgICAgICAgcmV0dXJuIFJvdWdoR2VuZXJhdG9yLm5ld1NlZWQoKTtcbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/rough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/svg.js":
/*!*****************************************!*\
  !*** ./node_modules/roughjs/bin/svg.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughSVG: () => (/* binding */ RoughSVG)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/roughjs/bin/core.js\");\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generator */ \"(ssr)/./node_modules/roughjs/bin/generator.js\");\n\n\nclass RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'g');\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', o.stroke);\n                    path.setAttribute('stroke-width', o.strokeWidth + '');\n                    path.setAttribute('fill', 'none');\n                    if (o.strokeLineDash) {\n                        path.setAttribute('stroke-dasharray', o.strokeLineDash.join(' ').trim());\n                    }\n                    if (o.strokeLineDashOffset) {\n                        path.setAttribute('stroke-dashoffset', `${o.strokeLineDashOffset}`);\n                    }\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', 'none');\n                    path.setAttribute('stroke-width', '0');\n                    path.setAttribute('fill', o.fill || '');\n                    if (drawable.shape === 'curve' || drawable.shape === 'polygon') {\n                        path.setAttribute('fill-rule', 'evenodd');\n                    }\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing, o.fixedDecimalPlaceDigits));\n        path.setAttribute('stroke', o.fill || '');\n        path.setAttribute('stroke-width', fweight + '');\n        path.setAttribute('fill', 'none');\n        if (o.fillLineDash) {\n            path.setAttribute('stroke-dasharray', o.fillLineDash.join(' ').trim());\n        }\n        if (o.fillLineDashOffset) {\n            path.setAttribute('stroke-dashoffset', `${o.fillLineDashOffset}`);\n        }\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing, fixedDecimalPlaceDigits) {\n        return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vc3ZnLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNjO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixzREFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdDQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0NBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx1QkFBdUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0NBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0NBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9zdmcuanM/NmM1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTVkdOUyB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgeyBSb3VnaEdlbmVyYXRvciB9IGZyb20gJy4vZ2VuZXJhdG9yJztcbmV4cG9ydCBjbGFzcyBSb3VnaFNWRyB7XG4gICAgY29uc3RydWN0b3Ioc3ZnLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMuZ2VuID0gbmV3IFJvdWdoR2VuZXJhdG9yKGNvbmZpZyk7XG4gICAgfVxuICAgIGRyYXcoZHJhd2FibGUpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IGRyYXdhYmxlLnNldHMgfHwgW107XG4gICAgICAgIGNvbnN0IG8gPSBkcmF3YWJsZS5vcHRpb25zIHx8IHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5zdmcub3duZXJEb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGcgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR05TLCAnZycpO1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBkcmF3YWJsZS5vcHRpb25zLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzO1xuICAgICAgICBmb3IgKGNvbnN0IGRyYXdpbmcgb2Ygc2V0cykge1xuICAgICAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChkcmF3aW5nLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdOUywgJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLm9wc1RvUGF0aChkcmF3aW5nLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG8uc3Ryb2tlKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG8uc3Ryb2tlV2lkdGggKyAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3Ryb2tlTGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgby5zdHJva2VMaW5lRGFzaC5qb2luKCcgJykudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoby5zdHJva2VMaW5lRGFzaE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgYCR7by5zdHJva2VMaW5lRGFzaE9mZnNldH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbFBhdGgnOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR05TLCAncGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMub3BzVG9QYXRoKGRyYXdpbmcsIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgby5maWxsIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdhYmxlLnNoYXBlID09PSAnY3VydmUnIHx8IGRyYXdhYmxlLnNoYXBlID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsU2tldGNoJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5maWxsU2tldGNoKGRvYywgZHJhd2luZywgbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZztcbiAgICB9XG4gICAgZmlsbFNrZXRjaChkb2MsIGRyYXdpbmcsIG8pIHtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR05TLCAncGF0aCcpO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMub3BzVG9QYXRoKGRyYXdpbmcsIG8uZml4ZWREZWNpbWFsUGxhY2VEaWdpdHMpKTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG8uZmlsbCB8fCAnJyk7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBmd2VpZ2h0ICsgJycpO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgICAgIGlmIChvLmZpbGxMaW5lRGFzaCkge1xuICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvLmZpbGxMaW5lRGFzaC5qb2luKCcgJykudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5maWxsTGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIGAke28uZmlsbExpbmVEYXNoT2Zmc2V0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBnZXQgZ2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW47XG4gICAgfVxuICAgIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW4uZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuICAgIG9wc1RvUGF0aChkcmF3aW5nLCBmaXhlZERlY2ltYWxQbGFjZURpZ2l0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW4ub3BzVG9QYXRoKGRyYXdpbmcsIGZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzKTtcbiAgICB9XG4gICAgbGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uZWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5jaXJjbGUoeCwgeSwgZGlhbWV0ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBsaW5lYXJQYXRoKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBwb2x5Z29uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ucG9seWdvbihwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCA9IGZhbHNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5hcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIGN1cnZlKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uY3VydmUocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgcGF0aChkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRyYXdpbmcgPSB0aGlzLmdlbi5wYXRoKGQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGRyYXdpbmcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/svg.js\n");

/***/ })

};
;
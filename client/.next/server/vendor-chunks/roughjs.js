"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/roughjs";
exports.ids = ["vendor-chunks/roughjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/roughjs/bin/canvas.js":
/*!********************************************!*\
  !*** ./node_modules/roughjs/bin/canvas.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughCanvas: () => (/* binding */ RoughCanvas)\n/* harmony export */ });\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generator */ \"(ssr)/./node_modules/roughjs/bin/generator.js\");\n\nclass RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new _generator__WEBPACK_IMPORTED_MODULE_0__.RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    if (o.strokeLineDash) {\n                        ctx.setLineDash(o.strokeLineDash);\n                    }\n                    if (o.strokeLineDashOffset) {\n                        ctx.lineDashOffset = o.strokeLineDashOffset;\n                    }\n                    this._drawToContext(ctx, drawing, precision);\n                    ctx.restore();\n                    break;\n                case 'fillPath': {\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    const fillRule = (drawable.shape === 'curve' || drawable.shape === 'polygon' || drawable.shape === 'path') ? 'evenodd' : 'nonzero';\n                    this._drawToContext(ctx, drawing, precision, fillRule);\n                    ctx.restore();\n                    break;\n                }\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n            }\n        }\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        if (o.fillLineDash) {\n            ctx.setLineDash(o.fillLineDash);\n        }\n        if (o.fillLineDashOffset) {\n            ctx.lineDashOffset = o.fillLineDashOffset;\n        }\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing, o.fixedDecimalPlaceDigits);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing, fixedDecimals, rule = 'nonzero') {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill(rule);\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY2FudmFzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY2FudmFzLmpzPzViNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm91Z2hHZW5lcmF0b3IgfSBmcm9tICcuL2dlbmVyYXRvcic7XG5leHBvcnQgY2xhc3MgUm91Z2hDYW52YXMge1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhcywgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuZ2VuID0gbmV3IFJvdWdoR2VuZXJhdG9yKGNvbmZpZyk7XG4gICAgfVxuICAgIGRyYXcoZHJhd2FibGUpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IGRyYXdhYmxlLnNldHMgfHwgW107XG4gICAgICAgIGNvbnN0IG8gPSBkcmF3YWJsZS5vcHRpb25zIHx8IHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IHByZWNpc2lvbiA9IGRyYXdhYmxlLm9wdGlvbnMuZml4ZWREZWNpbWFsUGxhY2VEaWdpdHM7XG4gICAgICAgIGZvciAoY29uc3QgZHJhd2luZyBvZiBzZXRzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGRyYXdpbmcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvLnN0cm9rZSA9PT0gJ25vbmUnID8gJ3RyYW5zcGFyZW50JyA6IG8uc3Ryb2tlO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gby5zdHJva2VXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3Ryb2tlTGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChvLnN0cm9rZUxpbmVEYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoby5zdHJva2VMaW5lRGFzaE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gby5zdHJva2VMaW5lRGFzaE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kcmF3VG9Db250ZXh0KGN0eCwgZHJhd2luZywgcHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbFBhdGgnOiB7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvLmZpbGwgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxSdWxlID0gKGRyYXdhYmxlLnNoYXBlID09PSAnY3VydmUnIHx8IGRyYXdhYmxlLnNoYXBlID09PSAncG9seWdvbicgfHwgZHJhd2FibGUuc2hhcGUgPT09ICdwYXRoJykgPyAnZXZlbm9kZCcgOiAnbm9uemVybyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdUb0NvbnRleHQoY3R4LCBkcmF3aW5nLCBwcmVjaXNpb24sIGZpbGxSdWxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxTa2V0Y2gnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxTa2V0Y2goY3R4LCBkcmF3aW5nLCBvKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmlsbFNrZXRjaChjdHgsIGRyYXdpbmcsIG8pIHtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGlmIChvLmZpbGxMaW5lRGFzaCkge1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKG8uZmlsbExpbmVEYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5maWxsTGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG8uZmlsbExpbmVEYXNoT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG8uZmlsbCB8fCAnJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGZ3ZWlnaHQ7XG4gICAgICAgIHRoaXMuX2RyYXdUb0NvbnRleHQoY3R4LCBkcmF3aW5nLCBvLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgX2RyYXdUb0NvbnRleHQoY3R4LCBkcmF3aW5nLCBmaXhlZERlY2ltYWxzLCBydWxlID0gJ25vbnplcm8nKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRyYXdpbmcub3BzKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gKCh0eXBlb2YgZml4ZWREZWNpbWFscyA9PT0gJ251bWJlcicpICYmIGZpeGVkRGVjaW1hbHMgPj0gMCkgPyAoaXRlbS5kYXRhLm1hcCgoZCkgPT4gK2QudG9GaXhlZChmaXhlZERlY2ltYWxzKSkpIDogaXRlbS5kYXRhO1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLm9wKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JjdXJ2ZVRvJzpcbiAgICAgICAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZGF0YVswXSwgZGF0YVsxXSwgZGF0YVsyXSwgZGF0YVszXSwgZGF0YVs0XSwgZGF0YVs1XSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmVUbyc6XG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZGF0YVswXSwgZGF0YVsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcmF3aW5nLnR5cGUgPT09ICdmaWxsUGF0aCcpIHtcbiAgICAgICAgICAgIGN0eC5maWxsKHJ1bGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBnZW5lcmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbjtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9ucztcbiAgICB9XG4gICAgbGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uZWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5jaXJjbGUoeCwgeSwgZGlhbWV0ZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBsaW5lYXJQYXRoKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBwb2x5Z29uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ucG9seWdvbihwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCA9IGZhbHNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5hcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZHJhdyhkKTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGN1cnZlKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uY3VydmUocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5kcmF3KGQpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgcGF0aChkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRyYXdpbmcgPSB0aGlzLmdlbi5wYXRoKGQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRyYXcoZHJhd2luZyk7XG4gICAgICAgIHJldHVybiBkcmF3aW5nO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/canvas.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/core.js":
/*!******************************************!*\
  !*** ./node_modules/roughjs/bin/core.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SVGNS: () => (/* binding */ SVGNS)\n/* harmony export */ });\nconst SVGNS = 'http://www.w3.org/2000/svg';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vY29yZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9jb3JlLmpzP2Q5MmYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFNWR05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/dashed-filler.js":
/*!***********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/dashed-filler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DashedFiller: () => (/* binding */ DashedFiller)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        const ops = [];\n        lines.forEach((line) => {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kYXNoZWQtZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNpQjtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVFQUFtQjtBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2Rhc2hlZC1maWxsZXIuanM/NmI0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaW5lTGVuZ3RoIH0gZnJvbSAnLi4vZ2VvbWV0cnknO1xuaW1wb3J0IHsgcG9seWdvbkhhY2h1cmVMaW5lcyB9IGZyb20gJy4vc2Nhbi1saW5lLWhhY2h1cmUnO1xuZXhwb3J0IGNsYXNzIERhc2hlZEZpbGxlciB7XG4gICAgY29uc3RydWN0b3IoaGVscGVyKSB7XG4gICAgICAgIHRoaXMuaGVscGVyID0gaGVscGVyO1xuICAgIH1cbiAgICBmaWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxTa2V0Y2gnLCBvcHM6IHRoaXMuZGFzaGVkTGluZShsaW5lcywgbykgfTtcbiAgICB9XG4gICAgZGFzaGVkTGluZShsaW5lcywgbykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBvLmRhc2hPZmZzZXQgPCAwID8gKG8uaGFjaHVyZUdhcCA8IDAgPyAoby5zdHJva2VXaWR0aCAqIDQpIDogby5oYWNodXJlR2FwKSA6IG8uZGFzaE9mZnNldDtcbiAgICAgICAgY29uc3QgZ2FwID0gby5kYXNoR2FwIDwgMCA/IChvLmhhY2h1cmVHYXAgPCAwID8gKG8uc3Ryb2tlV2lkdGggKiA0KSA6IG8uaGFjaHVyZUdhcCkgOiBvLmRhc2hHYXA7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIChvZmZzZXQgKyBnYXApKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gKGxlbmd0aCArIGdhcCAtIChjb3VudCAqIChvZmZzZXQgKyBnYXApKSkgLyAyO1xuICAgICAgICAgICAgbGV0IHAxID0gbGluZVswXTtcbiAgICAgICAgICAgIGxldCBwMiA9IGxpbmVbMV07XG4gICAgICAgICAgICBpZiAocDFbMF0gPiBwMlswXSkge1xuICAgICAgICAgICAgICAgIHAxID0gbGluZVsxXTtcbiAgICAgICAgICAgICAgICBwMiA9IGxpbmVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbHBoYSA9IE1hdGguYXRhbigocDJbMV0gLSBwMVsxXSkgLyAocDJbMF0gLSBwMVswXSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbHN0YXJ0ID0gaSAqIChvZmZzZXQgKyBnYXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmQgPSBsc3RhcnQgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBbcDFbMF0gKyAobHN0YXJ0ICogTWF0aC5jb3MoYWxwaGEpKSArIChzdGFydE9mZnNldCAqIE1hdGguY29zKGFscGhhKSksIHAxWzFdICsgbHN0YXJ0ICogTWF0aC5zaW4oYWxwaGEpICsgKHN0YXJ0T2Zmc2V0ICogTWF0aC5zaW4oYWxwaGEpKV07XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gW3AxWzBdICsgKGxlbmQgKiBNYXRoLmNvcyhhbHBoYSkpICsgKHN0YXJ0T2Zmc2V0ICogTWF0aC5jb3MoYWxwaGEpKSwgcDFbMV0gKyAobGVuZCAqIE1hdGguc2luKGFscGhhKSkgKyAoc3RhcnRPZmZzZXQgKiBNYXRoLnNpbihhbHBoYSkpXTtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKHN0YXJ0WzBdLCBzdGFydFsxXSwgZW5kWzBdLCBlbmRbMV0sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/dashed-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/dot-filler.js":
/*!********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/dot-filler.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DotFiller: () => (/* binding */ DotFiller)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        o = Object.assign({}, o, { hachureAngle: 0 });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        const ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const ro = gap / 4;\n        for (const line of lines) {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const offset = length - (count * gap);\n            const x = ((line[0][0] + line[1][0]) / 2) - (gap / 4);\n            const minY = Math.min(line[0][1], line[1][1]);\n            for (let i = 0; i < count; i++) {\n                const y = minY + offset + (i * gap);\n                const cx = (x - ro) + Math.random() * 2 * ro;\n                const cy = (y - ro) + Math.random() * 2 * ro;\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops.push(...el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kb3QtZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QztBQUNpQjtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8saUJBQWlCO0FBQ3BELHNCQUFzQix1RUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9kb3QtZmlsbGVyLmpzP2Y0YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmV4cG9ydCBjbGFzcyBEb3RGaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlbHBlcikge1xuICAgICAgICB0aGlzLmhlbHBlciA9IGhlbHBlcjtcbiAgICB9XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIG8gPSBPYmplY3QuYXNzaWduKHt9LCBvLCB7IGhhY2h1cmVBbmdsZTogMCB9KTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG90c09uTGluZXMobGluZXMsIG8pO1xuICAgIH1cbiAgICBkb3RzT25MaW5lcyhsaW5lcywgbykge1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgbGV0IGdhcCA9IG8uaGFjaHVyZUdhcDtcbiAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgIGdhcCA9IG8uc3Ryb2tlV2lkdGggKiA0O1xuICAgICAgICB9XG4gICAgICAgIGdhcCA9IE1hdGgubWF4KGdhcCwgMC4xKTtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvID0gZ2FwIC8gNDtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgZGwgPSBsZW5ndGggLyBnYXA7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGguY2VpbChkbCkgLSAxO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbGVuZ3RoIC0gKGNvdW50ICogZ2FwKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSAoKGxpbmVbMF1bMF0gKyBsaW5lWzFdWzBdKSAvIDIpIC0gKGdhcCAvIDQpO1xuICAgICAgICAgICAgY29uc3QgbWluWSA9IE1hdGgubWluKGxpbmVbMF1bMV0sIGxpbmVbMV1bMV0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IG1pblkgKyBvZmZzZXQgKyAoaSAqIGdhcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3ggPSAoeCAtIHJvKSArIE1hdGgucmFuZG9tKCkgKiAyICogcm87XG4gICAgICAgICAgICAgICAgY29uc3QgY3kgPSAoeSAtIHJvKSArIE1hdGgucmFuZG9tKCkgKiAyICogcm87XG4gICAgICAgICAgICAgICAgY29uc3QgZWwgPSB0aGlzLmhlbHBlci5lbGxpcHNlKGN4LCBjeSwgZndlaWdodCwgZndlaWdodCwgbyk7XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4uZWwub3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiAnZmlsbFNrZXRjaCcsIG9wcyB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/dot-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/filler.js":
/*!****************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/filler.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFiller: () => (/* binding */ getFiller)\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n/* harmony import */ var _zigzag_filler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./zigzag-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/zigzag-filler.js\");\n/* harmony import */ var _hatch_filler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hatch-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hatch-filler.js\");\n/* harmony import */ var _dot_filler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dot-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/dot-filler.js\");\n/* harmony import */ var _dashed_filler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dashed-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/dashed-filler.js\");\n/* harmony import */ var _zigzag_line_filler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./zigzag-line-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js\");\n\n\n\n\n\n\nconst fillers = {};\nfunction getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _zigzag_filler__WEBPACK_IMPORTED_MODULE_1__.ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _hatch_filler__WEBPACK_IMPORTED_MODULE_2__.HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _dot_filler__WEBPACK_IMPORTED_MODULE_3__.DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _dashed_filler__WEBPACK_IMPORTED_MODULE_4__.DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _zigzag_line_filler__WEBPACK_IMPORTED_MODULE_5__.ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFpRDtBQUNGO0FBQ0Y7QUFDSjtBQUNNO0FBQ1M7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0RBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUVBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwREFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2ZpbGxlci5qcz80OTMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhY2h1cmVGaWxsZXIgfSBmcm9tICcuL2hhY2h1cmUtZmlsbGVyJztcbmltcG9ydCB7IFppZ1phZ0ZpbGxlciB9IGZyb20gJy4vemlnemFnLWZpbGxlcic7XG5pbXBvcnQgeyBIYXRjaEZpbGxlciB9IGZyb20gJy4vaGF0Y2gtZmlsbGVyJztcbmltcG9ydCB7IERvdEZpbGxlciB9IGZyb20gJy4vZG90LWZpbGxlcic7XG5pbXBvcnQgeyBEYXNoZWRGaWxsZXIgfSBmcm9tICcuL2Rhc2hlZC1maWxsZXInO1xuaW1wb3J0IHsgWmlnWmFnTGluZUZpbGxlciB9IGZyb20gJy4vemlnemFnLWxpbmUtZmlsbGVyJztcbmNvbnN0IGZpbGxlcnMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxsZXIobywgaGVscGVyKSB7XG4gICAgbGV0IGZpbGxlck5hbWUgPSBvLmZpbGxTdHlsZSB8fCAnaGFjaHVyZSc7XG4gICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgIHN3aXRjaCAoZmlsbGVyTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnemlnemFnJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBaaWdaYWdGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcm9zcy1oYXRjaCc6XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgSGF0Y2hGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3RzJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBEb3RGaWxsZXIoaGVscGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICAgIGlmICghZmlsbGVyc1tmaWxsZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBmaWxsZXJzW2ZpbGxlck5hbWVdID0gbmV3IERhc2hlZEZpbGxlcihoZWxwZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ppZ3phZy1saW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoIWZpbGxlcnNbZmlsbGVyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbGVyc1tmaWxsZXJOYW1lXSA9IG5ldyBaaWdaYWdMaW5lRmlsbGVyKGhlbHBlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGFjaHVyZSc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGZpbGxlck5hbWUgPSAnaGFjaHVyZSc7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWxsZXJzW2ZpbGxlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxlcnNbZmlsbGVyTmFtZV0gPSBuZXcgSGFjaHVyZUZpbGxlcihoZWxwZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsbGVyc1tmaWxsZXJOYW1lXTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js":
/*!************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/hachure-filler.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HachureFiller: () => (/* binding */ HachureFiller)\n/* harmony export */ });\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\nclass HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        return this._fillPolygons(polygonList, o);\n    }\n    _fillPolygons(polygonList, o) {\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_0__.polygonHachureLines)(polygonList, o);\n        const ops = this.renderLines(lines, o);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o) {\n        const ops = [];\n        for (const line of lines) {\n            ops.push(...this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n        }\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9oYWNodXJlLWZpbGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwRDtBQUNuRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVFQUFtQjtBQUN6QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9maWxsZXJzL2hhY2h1cmUtZmlsbGVyLmpzP2YzYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcG9seWdvbkhhY2h1cmVMaW5lcyB9IGZyb20gJy4vc2Nhbi1saW5lLWhhY2h1cmUnO1xuZXhwb3J0IGNsYXNzIEhhY2h1cmVGaWxsZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlbHBlcikge1xuICAgICAgICB0aGlzLmhlbHBlciA9IGhlbHBlcjtcbiAgICB9XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pO1xuICAgIH1cbiAgICBfZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIGNvbnN0IG9wcyA9IHRoaXMucmVuZGVyTGluZXMobGluZXMsIG8pO1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnZmlsbFNrZXRjaCcsIG9wcyB9O1xuICAgIH1cbiAgICByZW5kZXJMaW5lcyhsaW5lcywgbykge1xuICAgICAgICBjb25zdCBvcHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBvcHMucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKGxpbmVbMF1bMF0sIGxpbmVbMF1bMV0sIGxpbmVbMV1bMF0sIGxpbmVbMV1bMV0sIG8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BzO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/hatch-filler.js":
/*!**********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/hatch-filler.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HatchFiller: () => (/* binding */ HatchFiller)\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n\nclass HatchFiller extends _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller {\n    fillPolygons(polygonList, o) {\n        const set = this._fillPolygons(polygonList, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygons(polygonList, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9oYXRjaC1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDMUMsMEJBQTBCLDBEQUFhO0FBQzlDO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTyxtQ0FBbUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvaGF0Y2gtZmlsbGVyLmpzPzYwZWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFjaHVyZUZpbGxlciB9IGZyb20gJy4vaGFjaHVyZS1maWxsZXInO1xuZXhwb3J0IGNsYXNzIEhhdGNoRmlsbGVyIGV4dGVuZHMgSGFjaHVyZUZpbGxlciB7XG4gICAgZmlsbFBvbHlnb25zKHBvbHlnb25MaXN0LCBvKSB7XG4gICAgICAgIGNvbnN0IHNldCA9IHRoaXMuX2ZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIGNvbnN0IG8yID0gT2JqZWN0LmFzc2lnbih7fSwgbywgeyBoYWNodXJlQW5nbGU6IG8uaGFjaHVyZUFuZ2xlICsgOTAgfSk7XG4gICAgICAgIGNvbnN0IHNldDIgPSB0aGlzLl9maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8yKTtcbiAgICAgICAgc2V0Lm9wcyA9IHNldC5vcHMuY29uY2F0KHNldDIub3BzKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/hatch-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js":
/*!***************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/scan-line-hachure.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polygonHachureLines: () => (/* binding */ polygonHachureLines)\n/* harmony export */ });\n/* harmony import */ var hachure_fill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hachure-fill */ \"(ssr)/./node_modules/hachure-fill/bin/hachure.js\");\n\nfunction polygonHachureLines(polygonList, o) {\n    var _a;\n    const angle = o.hachureAngle + 90;\n    let gap = o.hachureGap;\n    if (gap < 0) {\n        gap = o.strokeWidth * 4;\n    }\n    gap = Math.round(Math.max(gap, 0.1));\n    let skipOffset = 1;\n    if (o.roughness >= 1) {\n        if ((((_a = o.randomizer) === null || _a === void 0 ? void 0 : _a.next()) || Math.random()) > 0.7) {\n            skipOffset = gap;\n        }\n    }\n    return (0,hachure_fill__WEBPACK_IMPORTED_MODULE_0__.hachureLines)(polygonList, gap, angle, skipOffset || 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy9zY2FuLWxpbmUtaGFjaHVyZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUNyQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwREFBWTtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvc2Nhbi1saW5lLWhhY2h1cmUuanM/MjYwZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBoYWNodXJlTGluZXMgfSBmcm9tICdoYWNodXJlLWZpbGwnO1xuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb25IYWNodXJlTGluZXMocG9seWdvbkxpc3QsIG8pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYW5nbGUgPSBvLmhhY2h1cmVBbmdsZSArIDkwO1xuICAgIGxldCBnYXAgPSBvLmhhY2h1cmVHYXA7XG4gICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgZ2FwID0gby5zdHJva2VXaWR0aCAqIDQ7XG4gICAgfVxuICAgIGdhcCA9IE1hdGgucm91bmQoTWF0aC5tYXgoZ2FwLCAwLjEpKTtcbiAgICBsZXQgc2tpcE9mZnNldCA9IDE7XG4gICAgaWYgKG8ucm91Z2huZXNzID49IDEpIHtcbiAgICAgICAgaWYgKCgoKF9hID0gby5yYW5kb21pemVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dCgpKSB8fCBNYXRoLnJhbmRvbSgpKSA+IDAuNykge1xuICAgICAgICAgICAgc2tpcE9mZnNldCA9IGdhcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBnYXAsIGFuZ2xlLCBza2lwT2Zmc2V0IHx8IDEpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/zigzag-filler.js":
/*!***********************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/zigzag-filler.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZigZagFiller: () => (/* binding */ ZigZagFiller)\n/* harmony export */ });\n/* harmony import */ var _hachure_filler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hachure-filler */ \"(ssr)/./node_modules/roughjs/bin/fillers/hachure-filler.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n\n\n\nclass ZigZagFiller extends _hachure_filler__WEBPACK_IMPORTED_MODULE_0__.HachureFiller {\n    fillPolygons(polygonList, o) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        const o2 = Object.assign({}, o, { hachureGap: gap });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o2);\n        const zigZagAngle = (Math.PI / 180) * o.hachureAngle;\n        const zigzagLines = [];\n        const dgx = gap * 0.5 * Math.cos(zigZagAngle);\n        const dgy = gap * 0.5 * Math.sin(zigZagAngle);\n        for (const [p1, p2] of lines) {\n            if ((0,_geometry__WEBPACK_IMPORTED_MODULE_2__.lineLength)([p1, p2])) {\n                zigzagLines.push([\n                    [p1[0] - dgx, p1[1] + dgy],\n                    [...p2],\n                ], [\n                    [p1[0] + dgx, p1[1] - dgy],\n                    [...p2],\n                ]);\n            }\n        }\n        const ops = this.renderLines(zigzagLines, o);\n        return { type: 'fillSketch', ops };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy96aWd6YWctZmlsbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBaUQ7QUFDUztBQUNqQjtBQUNsQywyQkFBMkIsMERBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU8saUJBQWlCO0FBQzNELHNCQUFzQix1RUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy96aWd6YWctZmlsbGVyLmpzPzhhNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFjaHVyZUZpbGxlciB9IGZyb20gJy4vaGFjaHVyZS1maWxsZXInO1xuaW1wb3J0IHsgcG9seWdvbkhhY2h1cmVMaW5lcyB9IGZyb20gJy4vc2Nhbi1saW5lLWhhY2h1cmUnO1xuaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmV4cG9ydCBjbGFzcyBaaWdaYWdGaWxsZXIgZXh0ZW5kcyBIYWNodXJlRmlsbGVyIHtcbiAgICBmaWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pIHtcbiAgICAgICAgbGV0IGdhcCA9IG8uaGFjaHVyZUdhcDtcbiAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgIGdhcCA9IG8uc3Ryb2tlV2lkdGggKiA0O1xuICAgICAgICB9XG4gICAgICAgIGdhcCA9IE1hdGgubWF4KGdhcCwgMC4xKTtcbiAgICAgICAgY29uc3QgbzIgPSBPYmplY3QuYXNzaWduKHt9LCBvLCB7IGhhY2h1cmVHYXA6IGdhcCB9KTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBwb2x5Z29uSGFjaHVyZUxpbmVzKHBvbHlnb25MaXN0LCBvMik7XG4gICAgICAgIGNvbnN0IHppZ1phZ0FuZ2xlID0gKE1hdGguUEkgLyAxODApICogby5oYWNodXJlQW5nbGU7XG4gICAgICAgIGNvbnN0IHppZ3phZ0xpbmVzID0gW107XG4gICAgICAgIGNvbnN0IGRneCA9IGdhcCAqIDAuNSAqIE1hdGguY29zKHppZ1phZ0FuZ2xlKTtcbiAgICAgICAgY29uc3QgZGd5ID0gZ2FwICogMC41ICogTWF0aC5zaW4oemlnWmFnQW5nbGUpO1xuICAgICAgICBmb3IgKGNvbnN0IFtwMSwgcDJdIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICBpZiAobGluZUxlbmd0aChbcDEsIHAyXSkpIHtcbiAgICAgICAgICAgICAgICB6aWd6YWdMaW5lcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgW3AxWzBdIC0gZGd4LCBwMVsxXSArIGRneV0sXG4gICAgICAgICAgICAgICAgICAgIFsuLi5wMl0sXG4gICAgICAgICAgICAgICAgXSwgW1xuICAgICAgICAgICAgICAgICAgICBbcDFbMF0gKyBkZ3gsIHAxWzFdIC0gZGd5XSxcbiAgICAgICAgICAgICAgICAgICAgWy4uLnAyXSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHMgPSB0aGlzLnJlbmRlckxpbmVzKHppZ3phZ0xpbmVzLCBvKTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxTa2V0Y2gnLCBvcHMgfTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/zigzag-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js":
/*!****************************************************************!*\
  !*** ./node_modules/roughjs/bin/fillers/zigzag-line-filler.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ZigZagLineFiller: () => (/* binding */ ZigZagLineFiller)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry */ \"(ssr)/./node_modules/roughjs/bin/geometry.js\");\n/* harmony import */ var _scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scan-line-hachure */ \"(ssr)/./node_modules/roughjs/bin/fillers/scan-line-hachure.js\");\n\n\nclass ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygons(polygonList, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = (0,_scan_line_hachure__WEBPACK_IMPORTED_MODULE_1__.polygonHachureLines)(polygonList, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        const ops = [];\n        lines.forEach((line) => {\n            const length = (0,_geometry__WEBPACK_IMPORTED_MODULE_0__.lineLength)(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZmlsbGVycy96aWd6YWctbGluZS1maWxsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXlDO0FBQ2lCO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU8sc0JBQXNCO0FBQ3pELHNCQUFzQix1RUFBbUI7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFEQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2ZpbGxlcnMvemlnemFnLWxpbmUtZmlsbGVyLmpzP2NjMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZUxlbmd0aCB9IGZyb20gJy4uL2dlb21ldHJ5JztcbmltcG9ydCB7IHBvbHlnb25IYWNodXJlTGluZXMgfSBmcm9tICcuL3NjYW4tbGluZS1oYWNodXJlJztcbmV4cG9ydCBjbGFzcyBaaWdaYWdMaW5lRmlsbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihoZWxwZXIpIHtcbiAgICAgICAgdGhpcy5oZWxwZXIgPSBoZWxwZXI7XG4gICAgfVxuICAgIGZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgICAgICBjb25zdCBnYXAgPSBvLmhhY2h1cmVHYXAgPCAwID8gKG8uc3Ryb2tlV2lkdGggKiA0KSA6IG8uaGFjaHVyZUdhcDtcbiAgICAgICAgY29uc3Qgem8gPSBvLnppZ3phZ09mZnNldCA8IDAgPyBnYXAgOiBvLnppZ3phZ09mZnNldDtcbiAgICAgICAgbyA9IE9iamVjdC5hc3NpZ24oe30sIG8sIHsgaGFjaHVyZUdhcDogZ2FwICsgem8gfSk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcG9seWdvbkhhY2h1cmVMaW5lcyhwb2x5Z29uTGlzdCwgbyk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdmaWxsU2tldGNoJywgb3BzOiB0aGlzLnppZ3phZ0xpbmVzKGxpbmVzLCB6bywgbykgfTtcbiAgICB9XG4gICAgemlnemFnTGluZXMobGluZXMsIHpvLCBvKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBsaW5lTGVuZ3RoKGxpbmUpO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLnJvdW5kKGxlbmd0aCAvICgyICogem8pKTtcbiAgICAgICAgICAgIGxldCBwMSA9IGxpbmVbMF07XG4gICAgICAgICAgICBsZXQgcDIgPSBsaW5lWzFdO1xuICAgICAgICAgICAgaWYgKHAxWzBdID4gcDJbMF0pIHtcbiAgICAgICAgICAgICAgICBwMSA9IGxpbmVbMV07XG4gICAgICAgICAgICAgICAgcDIgPSBsaW5lWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWxwaGEgPSBNYXRoLmF0YW4oKHAyWzFdIC0gcDFbMV0pIC8gKHAyWzBdIC0gcDFbMF0pKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxzdGFydCA9IGkgKiAyICogem87XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZCA9IChpICsgMSkgKiAyICogem87XG4gICAgICAgICAgICAgICAgY29uc3QgZHogPSBNYXRoLnNxcnQoMiAqIE1hdGgucG93KHpvLCAyKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBbcDFbMF0gKyAobHN0YXJ0ICogTWF0aC5jb3MoYWxwaGEpKSwgcDFbMV0gKyBsc3RhcnQgKiBNYXRoLnNpbihhbHBoYSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IFtwMVswXSArIChsZW5kICogTWF0aC5jb3MoYWxwaGEpKSwgcDFbMV0gKyAobGVuZCAqIE1hdGguc2luKGFscGhhKSldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZGRsZSA9IFtzdGFydFswXSArIGR6ICogTWF0aC5jb3MoYWxwaGEgKyBNYXRoLlBJIC8gNCksIHN0YXJ0WzFdICsgZHogKiBNYXRoLnNpbihhbHBoYSArIE1hdGguUEkgLyA0KV07XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhzdGFydFswXSwgc3RhcnRbMV0sIG1pZGRsZVswXSwgbWlkZGxlWzFdLCBvKSwgLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyhtaWRkbGVbMF0sIG1pZGRsZVsxXSwgZW5kWzBdLCBlbmRbMV0sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcHM7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/fillers/zigzag-line-filler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/generator.js":
/*!***********************************************!*\
  !*** ./node_modules/roughjs/bin/generator.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughGenerator: () => (/* binding */ RoughGenerator)\n/* harmony export */ });\n/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer.js */ \"(ssr)/./node_modules/roughjs/bin/renderer.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/roughjs/bin/math.js\");\n/* harmony import */ var points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! points-on-curve/lib/curve-to-bezier.js */ \"(ssr)/./node_modules/points-on-curve/lib/curve-to-bezier.js\");\n/* harmony import */ var points_on_curve__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! points-on-curve */ \"(ssr)/./node_modules/points-on-curve/lib/index.js\");\n/* harmony import */ var points_on_path__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! points-on-path */ \"(ssr)/./node_modules/points-on-path/lib/index.js\");\n\n\n\n\n\nconst NOS = 'none';\nclass RoughGenerator {\n    constructor(config) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            disableMultiStroke: false,\n            disableMultiStrokeFill: false,\n            preserveVertices: false,\n            fillShapeRoughnessGain: 0.8,\n        };\n        this.config = config || {};\n        if (this.config.options) {\n            this.defaultOptions = this._o(this.config.options);\n        }\n    }\n    static newSeed() {\n        return (0,_math_js__WEBPACK_IMPORTED_MODULE_1__.randomSeed)();\n    }\n    _o(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _d(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._o(options);\n        return this._d('line', [(0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.line)(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.rectangle)(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)([points], o));\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._o(options);\n        const paths = [];\n        const ellipseParams = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.generateEllipseParams)(width, height, o);\n        const ellipseResponse = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.ellipseWithParams)(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.ellipseWithParams)(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([ellipseResponse.estimatedPoints], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._d('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._o(options);\n        return this._d('linearPath', [(0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.arc)(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const fillOptions = Object.assign({}, o);\n                fillOptions.disableMultiStroke = true;\n                const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.arc)(x, y, width, height, start, stop, true, false, fillOptions);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillArc)(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.curve)(points, o);\n        if (o.fill && o.fill !== NOS) {\n            if (o.fillStyle === 'solid') {\n                const fillShape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.curve)(points, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                paths.push({\n                    type: 'fillPath',\n                    ops: this._mergedShape(fillShape.ops),\n                });\n            }\n            else {\n                const polyPoints = [];\n                const inputPoints = points;\n                if (inputPoints.length) {\n                    const p1 = inputPoints[0];\n                    const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n                    for (const points of pointsList) {\n                        if (points.length < 3) {\n                            polyPoints.push(...points);\n                        }\n                        else if (points.length === 3) {\n                            polyPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_3__.pointsOnBezierCurves)((0,points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__.curveToBezier)([\n                                points[0],\n                                points[0],\n                                points[1],\n                                points[2],\n                            ]), 10, (1 + o.roughness) / 2));\n                        }\n                        else {\n                            polyPoints.push(...(0,points_on_curve__WEBPACK_IMPORTED_MODULE_3__.pointsOnBezierCurves)((0,points_on_curve_lib_curve_to_bezier_js__WEBPACK_IMPORTED_MODULE_2__.curveToBezier)(points), 10, (1 + o.roughness) / 2));\n                        }\n                    }\n                }\n                if (polyPoints.length) {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([polyPoints], o));\n                }\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('curve', paths, o);\n    }\n    polygon(points, options) {\n        const o = this._o(options);\n        const paths = [];\n        const outline = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)([points], o));\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)([points], o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._d('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._o(options);\n        const paths = [];\n        if (!d) {\n            return this._d('path', paths, o);\n        }\n        d = (d || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n        const hasFill = o.fill && o.fill !== 'transparent' && o.fill !== NOS;\n        const hasStroke = o.stroke !== NOS;\n        const simplified = !!(o.simplification && (o.simplification < 1));\n        const distance = simplified ? (4 - 4 * (o.simplification || 1)) : ((1 + o.roughness) / 2);\n        const sets = (0,points_on_path__WEBPACK_IMPORTED_MODULE_4__.pointsOnPath)(d, 1, distance);\n        const shape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.svgPath)(d, o);\n        if (hasFill) {\n            if (o.fillStyle === 'solid') {\n                if (sets.length === 1) {\n                    const fillShape = (0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.svgPath)(d, Object.assign(Object.assign({}, o), { disableMultiStroke: true, roughness: o.roughness ? (o.roughness + o.fillShapeRoughnessGain) : 0 }));\n                    paths.push({\n                        type: 'fillPath',\n                        ops: this._mergedShape(fillShape.ops),\n                    });\n                }\n                else {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.solidFillPolygon)(sets, o));\n                }\n            }\n            else {\n                paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.patternFillPolygons)(sets, o));\n            }\n        }\n        if (hasStroke) {\n            if (simplified) {\n                sets.forEach((set) => {\n                    paths.push((0,_renderer_js__WEBPACK_IMPORTED_MODULE_0__.linearPath)(set, false, o));\n                });\n            }\n            else {\n                paths.push(shape);\n            }\n        }\n        return this._d('path', paths, o);\n    }\n    opsToPath(drawing, fixedDecimals) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = ((typeof fixedDecimals === 'number') && fixedDecimals >= 0) ? (item.data.map((d) => +d.toFixed(fixedDecimals))) : item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS,\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS,\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS,\n        };\n    }\n    _mergedShape(input) {\n        return input.filter((d, i) => {\n            if (i === 0) {\n                return true;\n            }\n            if (d.op === 'move') {\n                return false;\n            }\n            return true;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZ2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrTDtBQUMzSTtBQUNnQztBQUNoQjtBQUNUO0FBQzlDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvREFBVTtBQUN6QjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtEQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBZ0I7QUFDM0M7QUFDQTtBQUNBLDJCQUEyQixpRUFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQXFCO0FBQ25ELGdDQUFnQywrREFBaUI7QUFDakQ7QUFDQTtBQUNBLDhCQUE4QiwrREFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0RBQVU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQUc7QUFDM0I7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLDhCQUE4QixpREFBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtREFBSztBQUM3QjtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFLLHVDQUF1QyxRQUFRLGlHQUFpRztBQUN2TDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFFQUFvQixDQUFDLHFGQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHFFQUFvQixDQUFDLHFGQUFhO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlFQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdEQUFVO0FBQ2xDO0FBQ0E7QUFDQSwyQkFBMkIsOERBQWdCO0FBQzNDO0FBQ0E7QUFDQSwyQkFBMkIsaUVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBWTtBQUNqQyxzQkFBc0IscURBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFEQUFPLGtDQUFrQyxRQUFRLGlHQUFpRztBQUN4TDtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLCtCQUErQiw4REFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlFQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdEQUFVO0FBQ3pDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTLEVBQUUsU0FBUztBQUNwRDtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxRQUFRLElBQUksU0FBUyxFQUFFLFFBQVEsSUFBSSxTQUFTLEVBQUUsU0FBUztBQUNsRztBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL2dlbmVyYXRvci5qcz9kZWVkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGxpbmUsIHNvbGlkRmlsbFBvbHlnb24sIHBhdHRlcm5GaWxsUG9seWdvbnMsIHJlY3RhbmdsZSwgZWxsaXBzZVdpdGhQYXJhbXMsIGdlbmVyYXRlRWxsaXBzZVBhcmFtcywgbGluZWFyUGF0aCwgYXJjLCBwYXR0ZXJuRmlsbEFyYywgY3VydmUsIHN2Z1BhdGggfSBmcm9tICcuL3JlbmRlcmVyLmpzJztcbmltcG9ydCB7IHJhbmRvbVNlZWQgfSBmcm9tICcuL21hdGguanMnO1xuaW1wb3J0IHsgY3VydmVUb0JlemllciB9IGZyb20gJ3BvaW50cy1vbi1jdXJ2ZS9saWIvY3VydmUtdG8tYmV6aWVyLmpzJztcbmltcG9ydCB7IHBvaW50c09uQmV6aWVyQ3VydmVzIH0gZnJvbSAncG9pbnRzLW9uLWN1cnZlJztcbmltcG9ydCB7IHBvaW50c09uUGF0aCB9IGZyb20gJ3BvaW50cy1vbi1wYXRoJztcbmNvbnN0IE5PUyA9ICdub25lJztcbmV4cG9ydCBjbGFzcyBSb3VnaEdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXhSYW5kb21uZXNzT2Zmc2V0OiAyLFxuICAgICAgICAgICAgcm91Z2huZXNzOiAxLFxuICAgICAgICAgICAgYm93aW5nOiAxLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgICAgIGN1cnZlVGlnaHRuZXNzOiAwLFxuICAgICAgICAgICAgY3VydmVGaXR0aW5nOiAwLjk1LFxuICAgICAgICAgICAgY3VydmVTdGVwQ291bnQ6IDksXG4gICAgICAgICAgICBmaWxsU3R5bGU6ICdoYWNodXJlJyxcbiAgICAgICAgICAgIGZpbGxXZWlnaHQ6IC0xLFxuICAgICAgICAgICAgaGFjaHVyZUFuZ2xlOiAtNDEsXG4gICAgICAgICAgICBoYWNodXJlR2FwOiAtMSxcbiAgICAgICAgICAgIGRhc2hPZmZzZXQ6IC0xLFxuICAgICAgICAgICAgZGFzaEdhcDogLTEsXG4gICAgICAgICAgICB6aWd6YWdPZmZzZXQ6IC0xLFxuICAgICAgICAgICAgc2VlZDogMCxcbiAgICAgICAgICAgIGRpc2FibGVNdWx0aVN0cm9rZTogZmFsc2UsXG4gICAgICAgICAgICBkaXNhYmxlTXVsdGlTdHJva2VGaWxsOiBmYWxzZSxcbiAgICAgICAgICAgIHByZXNlcnZlVmVydGljZXM6IGZhbHNlLFxuICAgICAgICAgICAgZmlsbFNoYXBlUm91Z2huZXNzR2FpbjogMC44LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB0aGlzLl9vKHRoaXMuY29uZmlnLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBuZXdTZWVkKCkge1xuICAgICAgICByZXR1cm4gcmFuZG9tU2VlZCgpO1xuICAgIH1cbiAgICBfbyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucykgOiB0aGlzLmRlZmF1bHRPcHRpb25zO1xuICAgIH1cbiAgICBfZChzaGFwZSwgc2V0cywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4geyBzaGFwZSwgc2V0czogc2V0cyB8fCBbXSwgb3B0aW9uczogb3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRPcHRpb25zIH07XG4gICAgfVxuICAgIGxpbmUoeDEsIHkxLCB4MiwgeTIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdsaW5lJywgW2xpbmUoeDEsIHkxLCB4MiwgeTIsIG8pXSwgbyk7XG4gICAgfVxuICAgIHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gcmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG8pO1xuICAgICAgICBpZiAoby5maWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbW3gsIHldLCBbeCArIHdpZHRoLCB5XSwgW3ggKyB3aWR0aCwgeSArIGhlaWdodF0sIFt4LCB5ICsgaGVpZ2h0XV07XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNvbGlkRmlsbFBvbHlnb24oW3BvaW50c10sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhbcG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvLnN0cm9rZSAhPT0gTk9TKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKG91dGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdyZWN0YW5nbGUnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fbyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgY29uc3QgZWxsaXBzZVBhcmFtcyA9IGdlbmVyYXRlRWxsaXBzZVBhcmFtcyh3aWR0aCwgaGVpZ2h0LCBvKTtcbiAgICAgICAgY29uc3QgZWxsaXBzZVJlc3BvbnNlID0gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgZWxsaXBzZVBhcmFtcyk7XG4gICAgICAgIGlmIChvLmZpbGwpIHtcbiAgICAgICAgICAgIGlmIChvLmZpbGxTdHlsZSA9PT0gJ3NvbGlkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgZWxsaXBzZVBhcmFtcykub3BzZXQ7XG4gICAgICAgICAgICAgICAgc2hhcGUudHlwZSA9ICdmaWxsUGF0aCc7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHBhdHRlcm5GaWxsUG9seWdvbnMoW2VsbGlwc2VSZXNwb25zZS5lc3RpbWF0ZWRQb2ludHNdLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG8uc3Ryb2tlICE9PSBOT1MpIHtcbiAgICAgICAgICAgIHBhdGhzLnB1c2goZWxsaXBzZVJlc3BvbnNlLm9wc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgnZWxsaXBzZScsIHBhdGhzLCBvKTtcbiAgICB9XG4gICAgY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuZWxsaXBzZSh4LCB5LCBkaWFtZXRlciwgZGlhbWV0ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXQuc2hhcGUgPSAnY2lyY2xlJztcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgbGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdsaW5lYXJQYXRoJywgW2xpbmVhclBhdGgocG9pbnRzLCBmYWxzZSwgbyldLCBvKTtcbiAgICB9XG4gICAgYXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBjbG9zZWQgPSBmYWxzZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5fbyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICAgICAgY29uc3Qgb3V0bGluZSA9IGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgY2xvc2VkLCB0cnVlLCBvKTtcbiAgICAgICAgaWYgKGNsb3NlZCAmJiBvLmZpbGwpIHtcbiAgICAgICAgICAgIGlmIChvLmZpbGxTdHlsZSA9PT0gJ3NvbGlkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGxPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbyk7XG4gICAgICAgICAgICAgICAgZmlsbE9wdGlvbnMuZGlzYWJsZU11bHRpU3Ryb2tlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFwZSA9IGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgdHJ1ZSwgZmFsc2UsIGZpbGxPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBzaGFwZS50eXBlID0gJ2ZpbGxQYXRoJztcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxBcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5zdHJva2UgIT09IE5PUykge1xuICAgICAgICAgICAgcGF0aHMucHVzaChvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgnYXJjJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBjdXJ2ZShwb2ludHMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGNvbnN0IG91dGxpbmUgPSBjdXJ2ZShwb2ludHMsIG8pO1xuICAgICAgICBpZiAoby5maWxsICYmIG8uZmlsbCAhPT0gTk9TKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsU2hhcGUgPSBjdXJ2ZShwb2ludHMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbyksIHsgZGlzYWJsZU11bHRpU3Ryb2tlOiB0cnVlLCByb3VnaG5lc3M6IG8ucm91Z2huZXNzID8gKG8ucm91Z2huZXNzICsgby5maWxsU2hhcGVSb3VnaG5lc3NHYWluKSA6IDAgfSkpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmlsbFBhdGgnLFxuICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMuX21lcmdlZFNoYXBlKGZpbGxTaGFwZS5vcHMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9seVBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0UG9pbnRzID0gcG9pbnRzO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcDEgPSBpbnB1dFBvaW50c1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9pbnRzTGlzdCA9ICh0eXBlb2YgcDFbMF0gPT09ICdudW1iZXInKSA/IFtpbnB1dFBvaW50c10gOiBpbnB1dFBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludHMgb2YgcG9pbnRzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seVBvaW50cy5wdXNoKC4uLnBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwb2ludHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9seVBvaW50cy5wdXNoKC4uLnBvaW50c09uQmV6aWVyQ3VydmVzKGN1cnZlVG9CZXppZXIoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSksIDEwLCAoMSArIG8ucm91Z2huZXNzKSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlQb2ludHMucHVzaCguLi5wb2ludHNPbkJlemllckN1cnZlcyhjdXJ2ZVRvQmV6aWVyKHBvaW50cyksIDEwLCAoMSArIG8ucm91Z2huZXNzKSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9seVBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXR0ZXJuRmlsbFBvbHlnb25zKFtwb2x5UG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoby5zdHJva2UgIT09IE5PUykge1xuICAgICAgICAgICAgcGF0aHMucHVzaChvdXRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZCgnY3VydmUnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIHBvbHlnb24ocG9pbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9vKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBwYXRocyA9IFtdO1xuICAgICAgICBjb25zdCBvdXRsaW5lID0gbGluZWFyUGF0aChwb2ludHMsIHRydWUsIG8pO1xuICAgICAgICBpZiAoby5maWxsKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNvbGlkRmlsbFBvbHlnb24oW3BvaW50c10sIG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhbcG9pbnRzXSwgbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvLnN0cm9rZSAhPT0gTk9TKSB7XG4gICAgICAgICAgICBwYXRocy5wdXNoKG91dGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kKCdwb2x5Z29uJywgcGF0aHMsIG8pO1xuICAgIH1cbiAgICBwYXRoKGQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbyA9IHRoaXMuX28ob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ3BhdGgnLCBwYXRocywgbyk7XG4gICAgICAgIH1cbiAgICAgICAgZCA9IChkIHx8ICcnKS5yZXBsYWNlKC9cXG4vZywgJyAnKS5yZXBsYWNlKC8oLVxccykvZywgJy0nKS5yZXBsYWNlKCcvKFxcc1xccykvZycsICcgJyk7XG4gICAgICAgIGNvbnN0IGhhc0ZpbGwgPSBvLmZpbGwgJiYgby5maWxsICE9PSAndHJhbnNwYXJlbnQnICYmIG8uZmlsbCAhPT0gTk9TO1xuICAgICAgICBjb25zdCBoYXNTdHJva2UgPSBvLnN0cm9rZSAhPT0gTk9TO1xuICAgICAgICBjb25zdCBzaW1wbGlmaWVkID0gISEoby5zaW1wbGlmaWNhdGlvbiAmJiAoby5zaW1wbGlmaWNhdGlvbiA8IDEpKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBzaW1wbGlmaWVkID8gKDQgLSA0ICogKG8uc2ltcGxpZmljYXRpb24gfHwgMSkpIDogKCgxICsgby5yb3VnaG5lc3MpIC8gMik7XG4gICAgICAgIGNvbnN0IHNldHMgPSBwb2ludHNPblBhdGgoZCwgMSwgZGlzdGFuY2UpO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHN2Z1BhdGgoZCwgbyk7XG4gICAgICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICAgICAgICBpZiAoby5maWxsU3R5bGUgPT09ICdzb2xpZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsbFNoYXBlID0gc3ZnUGF0aChkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG8pLCB7IGRpc2FibGVNdWx0aVN0cm9rZTogdHJ1ZSwgcm91Z2huZXNzOiBvLnJvdWdobmVzcyA/IChvLnJvdWdobmVzcyArIG8uZmlsbFNoYXBlUm91Z2huZXNzR2FpbikgOiAwIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmlsbFBhdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0aGlzLl9tZXJnZWRTaGFwZShmaWxsU2hhcGUub3BzKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKHNvbGlkRmlsbFBvbHlnb24oc2V0cywgbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhzLnB1c2gocGF0dGVybkZpbGxQb2x5Z29ucyhzZXRzLCBvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1N0cm9rZSkge1xuICAgICAgICAgICAgaWYgKHNpbXBsaWZpZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRzLmZvckVhY2goKHNldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYXRocy5wdXNoKGxpbmVhclBhdGgoc2V0LCBmYWxzZSwgbykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChzaGFwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2QoJ3BhdGgnLCBwYXRocywgbyk7XG4gICAgfVxuICAgIG9wc1RvUGF0aChkcmF3aW5nLCBmaXhlZERlY2ltYWxzKSB7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkcmF3aW5nLm9wcykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIGZpeGVkRGVjaW1hbHMgPT09ICdudW1iZXInKSAmJiBmaXhlZERlY2ltYWxzID49IDApID8gKGl0ZW0uZGF0YS5tYXAoKGQpID0+ICtkLnRvRml4ZWQoZml4ZWREZWNpbWFscykpKSA6IGl0ZW0uZGF0YTtcbiAgICAgICAgICAgIHN3aXRjaCAoaXRlbS5vcCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoICs9IGBNJHtkYXRhWzBdfSAke2RhdGFbMV19IGA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JjdXJ2ZVRvJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBgQyR7ZGF0YVswXX0gJHtkYXRhWzFdfSwgJHtkYXRhWzJdfSAke2RhdGFbM119LCAke2RhdGFbNF19ICR7ZGF0YVs1XX0gYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGluZVRvJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArPSBgTCR7ZGF0YVswXX0gJHtkYXRhWzFdfSBgO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC50cmltKCk7XG4gICAgfVxuICAgIHRvUGF0aHMoZHJhd2FibGUpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IGRyYXdhYmxlLnNldHMgfHwgW107XG4gICAgICAgIGNvbnN0IG8gPSBkcmF3YWJsZS5vcHRpb25zIHx8IHRoaXMuZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgZHJhd2luZyBvZiBzZXRzKSB7XG4gICAgICAgICAgICBsZXQgcGF0aCA9IG51bGw7XG4gICAgICAgICAgICBzd2l0Y2ggKGRyYXdpbmcudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZDogdGhpcy5vcHNUb1BhdGgoZHJhd2luZyksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IG8uc3Ryb2tlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG8uc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBOT1MsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxQYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQ6IHRoaXMub3BzVG9QYXRoKGRyYXdpbmcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiBOT1MsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6IG8uZmlsbCB8fCBOT1MsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGxTa2V0Y2gnOlxuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5maWxsU2tldGNoKGRyYXdpbmcsIG8pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aHM7XG4gICAgfVxuICAgIGZpbGxTa2V0Y2goZHJhd2luZywgbykge1xuICAgICAgICBsZXQgZndlaWdodCA9IG8uZmlsbFdlaWdodDtcbiAgICAgICAgaWYgKGZ3ZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBmd2VpZ2h0ID0gby5zdHJva2VXaWR0aCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGQ6IHRoaXMub3BzVG9QYXRoKGRyYXdpbmcpLFxuICAgICAgICAgICAgc3Ryb2tlOiBvLmZpbGwgfHwgTk9TLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IGZ3ZWlnaHQsXG4gICAgICAgICAgICBmaWxsOiBOT1MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9tZXJnZWRTaGFwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKChkLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGQub3AgPT09ICdtb3ZlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/generator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/geometry.js":
/*!**********************************************!*\
  !*** ./node_modules/roughjs/bin/geometry.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   lineLength: () => (/* binding */ lineLength)\n/* harmony export */ });\nfunction lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vZ2VvbWV0cnkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9nZW9tZXRyeS5qcz9iZGM4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBsaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBjb25zdCBwMSA9IGxpbmVbMF07XG4gICAgY29uc3QgcDIgPSBsaW5lWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocDFbMF0gLSBwMlswXSwgMikgKyBNYXRoLnBvdyhwMVsxXSAtIHAyWzFdLCAyKSk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/geometry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/math.js":
/*!******************************************!*\
  !*** ./node_modules/roughjs/bin/math.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Random: () => (/* binding */ Random),\n/* harmony export */   randomSeed: () => (/* binding */ randomSeed)\n/* harmony export */ });\nfunction randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nclass Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vbWF0aC5qcz9mN2FiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiByYW5kb21TZWVkKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyICoqIDMxKTtcbn1cbmV4cG9ydCBjbGFzcyBSYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VlZCkge1xuICAgICAgICAgICAgcmV0dXJuICgoMiAqKiAzMSAtIDEpICYgKHRoaXMuc2VlZCA9IE1hdGguaW11bCg0ODI3MSwgdGhpcy5zZWVkKSkpIC8gMiAqKiAzMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/renderer.js":
/*!**********************************************!*\
  !*** ./node_modules/roughjs/bin/renderer.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arc: () => (/* binding */ arc),\n/* harmony export */   curve: () => (/* binding */ curve),\n/* harmony export */   doubleLineFillOps: () => (/* binding */ doubleLineFillOps),\n/* harmony export */   ellipse: () => (/* binding */ ellipse),\n/* harmony export */   ellipseWithParams: () => (/* binding */ ellipseWithParams),\n/* harmony export */   generateEllipseParams: () => (/* binding */ generateEllipseParams),\n/* harmony export */   line: () => (/* binding */ line),\n/* harmony export */   linearPath: () => (/* binding */ linearPath),\n/* harmony export */   patternFillArc: () => (/* binding */ patternFillArc),\n/* harmony export */   patternFillPolygons: () => (/* binding */ patternFillPolygons),\n/* harmony export */   polygon: () => (/* binding */ polygon),\n/* harmony export */   randOffset: () => (/* binding */ randOffset),\n/* harmony export */   randOffsetWithRange: () => (/* binding */ randOffsetWithRange),\n/* harmony export */   rectangle: () => (/* binding */ rectangle),\n/* harmony export */   solidFillPolygon: () => (/* binding */ solidFillPolygon),\n/* harmony export */   svgPath: () => (/* binding */ svgPath)\n/* harmony export */ });\n/* harmony import */ var _fillers_filler_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fillers/filler.js */ \"(ssr)/./node_modules/roughjs/bin/fillers/filler.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/roughjs/bin/math.js\");\n/* harmony import */ var path_data_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path-data-parser */ \"(ssr)/./node_modules/path-data-parser/lib/index.js\");\n\n\n\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps: doubleLineFillOps,\n};\nfunction line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nfunction linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        const ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops.push(..._doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nfunction polygon(points, o) {\n    return linearPath(points, true, o);\n}\nfunction rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y],\n        [x + width, y],\n        [x + width, y + height],\n        [x, y + height],\n    ];\n    return polygon(points, o);\n}\nfunction curve(inputPoints, o) {\n    if (inputPoints.length) {\n        const p1 = inputPoints[0];\n        const pointsList = (typeof p1[0] === 'number') ? [inputPoints] : inputPoints;\n        const o1 = _curveWithOffset(pointsList[0], 1 * (1 + o.roughness * 0.2), o);\n        const o2 = o.disableMultiStroke ? [] : _curveWithOffset(pointsList[0], 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n        for (let i = 1; i < pointsList.length; i++) {\n            const points = pointsList[i];\n            if (points.length) {\n                const underlay = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n                const overlay = o.disableMultiStroke ? [] : _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), cloneOptionsAlterSeed(o));\n                for (const item of underlay) {\n                    if (item.op !== 'move') {\n                        o1.push(item);\n                    }\n                }\n                for (const item of overlay) {\n                    if (item.op !== 'move') {\n                        o2.push(item);\n                    }\n                }\n            }\n        }\n        return { type: 'path', ops: o1.concat(o2) };\n    }\n    return { type: 'path', ops: [] };\n}\nfunction ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nfunction generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.ceil(Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq));\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nfunction ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    let o1 = _curve(ap1, null, o);\n    if ((!o.disableMultiStroke) && (o.roughness !== 0)) {\n        const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n        const o2 = _curve(ap2, null, o);\n        o1 = o1.concat(o2);\n    }\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1 },\n    };\n}\nfunction arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    if (!o.disableMultiStroke) {\n        const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n        ops.push(...o2);\n    }\n    if (closed) {\n        if (roughClosure) {\n            ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] }, { op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nfunction svgPath(path, o) {\n    const segments = (0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.normalize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.absolutize)((0,path_data_parser__WEBPACK_IMPORTED_MODULE_2__.parsePath)(path)));\n    const ops = [];\n    let first = [0, 0];\n    let current = [0, 0];\n    for (const { key, data } of segments) {\n        switch (key) {\n            case 'M': {\n                current = [data[0], data[1]];\n                first = [data[0], data[1]];\n                break;\n            }\n            case 'L':\n                ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o));\n                current = [data[0], data[1]];\n                break;\n            case 'C': {\n                const [x1, y1, x2, y2, x, y] = data;\n                ops.push(..._bezierTo(x1, y1, x2, y2, x, y, current, o));\n                current = [x, y];\n                break;\n            }\n            case 'Z':\n                ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o));\n                current = [first[0], first[1]];\n                break;\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nfunction solidFillPolygon(polygonList, o) {\n    const ops = [];\n    for (const points of polygonList) {\n        if (points.length) {\n            const offset = o.maxRandomnessOffset || 0;\n            const len = points.length;\n            if (len > 2) {\n                ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n                for (let i = 1; i < len; i++) {\n                    ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n                }\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nfunction patternFillPolygons(polygonList, o) {\n    return (0,_fillers_filler_js__WEBPACK_IMPORTED_MODULE_0__.getFiller)(o, helper).fillPolygons(polygonList, o);\n}\nfunction patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygons([points], o);\n}\nfunction randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nfunction randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nfunction doubleLineFillOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o, true);\n}\n// Private helpers\nfunction cloneOptionsAlterSeed(ops) {\n    const result = Object.assign({}, ops);\n    result.randomizer = undefined;\n    if (ops.seed) {\n        result.seed = ops.seed + 1;\n    }\n    return result;\n}\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new _math_js__WEBPACK_IMPORTED_MODULE_1__.Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops, roughnessGain = 1) {\n    return ops.roughness * roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops, roughnessGain = 1) {\n    return _offset(-x, x, ops, roughnessGain);\n}\nfunction _doubleLine(x1, y1, x2, y2, o, filling = false) {\n    const singleStroke = filling ? o.disableMultiStrokeFill : o.disableMultiStroke;\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    if (singleStroke) {\n        return o1;\n    }\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    let roughnessGain = 1;\n    if (length < 200) {\n        roughnessGain = 1;\n    }\n    else if (length > 500) {\n        roughnessGain = 0.4;\n    }\n    else {\n        roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o, roughnessGain);\n    midDispY = _offsetOpt(midDispY, o, roughnessGain);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o, roughnessGain);\n    const randomFull = () => _offsetOpt(offset, o, roughnessGain);\n    const preserveVertices = o.preserveVertices;\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : randomHalf()),\n                    y1 + (preserveVertices ? 0 : randomHalf()),\n                ],\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                    y1 + (preserveVertices ? 0 : _offsetOpt(offset, o, roughnessGain)),\n                ],\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + (preserveVertices ? 0 : randomHalf()),\n                y2 + (preserveVertices ? 0 : randomHalf()),\n            ],\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + (preserveVertices ? 0 : randomFull()),\n                y2 + (preserveVertices ? 0 : randomFull()),\n            ],\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    if (!points.length) {\n        return [];\n    }\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    const ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1],\n            ],\n        });\n    }\n    else if (len === 2) {\n        ops.push(..._line(points[0][0], points[0][1], points[1][0], points[1][1], o, true, true));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const coreOnly = o.roughness === 0;\n    const corePoints = [];\n    const allPoints = [];\n    if (coreOnly) {\n        increment = increment / 4;\n        allPoints.push([\n            cx + rx * Math.cos(-increment),\n            cy + ry * Math.sin(-increment),\n        ]);\n        for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {\n            const p = [\n                cx + rx * Math.cos(angle),\n                cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            cx + rx * Math.cos(0),\n            cy + ry * Math.sin(0),\n        ]);\n        allPoints.push([\n            cx + rx * Math.cos(increment),\n            cy + ry * Math.sin(increment),\n        ]);\n    }\n    else {\n        const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n        ]);\n        const endAngle = Math.PI * 2 + radOffset - 0.01;\n        for (let angle = radOffset; angle < endAngle; angle = angle + increment) {\n            const p = [\n                _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n                _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n            ];\n            corePoints.push(p);\n            allPoints.push(p);\n        }\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n            _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap),\n        ]);\n        allPoints.push([\n            _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n            _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5),\n        ]);\n    }\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment),\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle),\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp),\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, current, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.3];\n    let f = [0, 0];\n    const iterations = o.disableMultiStroke ? 1 : 2;\n    const preserveVertices = o.preserveVertices;\n    for (let i = 0; i < iterations; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [current[0], current[1]] });\n        }\n        else {\n            ops.push({ op: 'move', data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o))] });\n        }\n        f = preserveVertices ? [x, y] : [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo',\n            data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1],\n            ],\n        });\n    }\n    return ops;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vcmVuZGVyZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNiO0FBQ2lDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhCQUE4QixJQUFJLDBFQUEwRTtBQUNuSTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ087QUFDUCxxQkFBcUIsMkRBQVMsQ0FBQyw0REFBVSxD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsOElBQThJO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9yZW5kZXJlci5qcz9iZmJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldEZpbGxlciB9IGZyb20gJy4vZmlsbGVycy9maWxsZXIuanMnO1xuaW1wb3J0IHsgUmFuZG9tIH0gZnJvbSAnLi9tYXRoLmpzJztcbmltcG9ydCB7IHBhcnNlUGF0aCwgbm9ybWFsaXplLCBhYnNvbHV0aXplIH0gZnJvbSAncGF0aC1kYXRhLXBhcnNlcic7XG5jb25zdCBoZWxwZXIgPSB7XG4gICAgcmFuZE9mZnNldCxcbiAgICByYW5kT2Zmc2V0V2l0aFJhbmdlLFxuICAgIGVsbGlwc2UsXG4gICAgZG91YmxlTGluZU9wczogZG91YmxlTGluZUZpbGxPcHMsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmUoeDEsIHkxLCB4MiwgeTIsIG8pIHtcbiAgICByZXR1cm4geyB0eXBlOiAncGF0aCcsIG9wczogX2RvdWJsZUxpbmUoeDEsIHkxLCB4MiwgeTIsIG8pIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbGluZWFyUGF0aChwb2ludHMsIGNsb3NlLCBvKSB7XG4gICAgY29uc3QgbGVuID0gKHBvaW50cyB8fCBbXSkubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAyKSB7XG4gICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBvcHMucHVzaCguLi5fZG91YmxlTGluZShwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSwgcG9pbnRzW2kgKyAxXVswXSwgcG9pbnRzW2kgKyAxXVsxXSwgbykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUocG9pbnRzW2xlbiAtIDFdWzBdLCBwb2ludHNbbGVuIC0gMV1bMV0sIHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdLCBvKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3BhdGgnLCBvcHMgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICAgIHJldHVybiBsaW5lKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdLCBwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXSwgbyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzOiBbXSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvbHlnb24ocG9pbnRzLCBvKSB7XG4gICAgcmV0dXJuIGxpbmVhclBhdGgocG9pbnRzLCB0cnVlLCBvKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgbykge1xuICAgIGNvbnN0IHBvaW50cyA9IFtcbiAgICAgICAgW3gsIHldLFxuICAgICAgICBbeCArIHdpZHRoLCB5XSxcbiAgICAgICAgW3ggKyB3aWR0aCwgeSArIGhlaWdodF0sXG4gICAgICAgIFt4LCB5ICsgaGVpZ2h0XSxcbiAgICBdO1xuICAgIHJldHVybiBwb2x5Z29uKHBvaW50cywgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VydmUoaW5wdXRQb2ludHMsIG8pIHtcbiAgICBpZiAoaW5wdXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHAxID0gaW5wdXRQb2ludHNbMF07XG4gICAgICAgIGNvbnN0IHBvaW50c0xpc3QgPSAodHlwZW9mIHAxWzBdID09PSAnbnVtYmVyJykgPyBbaW5wdXRQb2ludHNdIDogaW5wdXRQb2ludHM7XG4gICAgICAgIGNvbnN0IG8xID0gX2N1cnZlV2l0aE9mZnNldChwb2ludHNMaXN0WzBdLCAxICogKDEgKyBvLnJvdWdobmVzcyAqIDAuMiksIG8pO1xuICAgICAgICBjb25zdCBvMiA9IG8uZGlzYWJsZU11bHRpU3Ryb2tlID8gW10gOiBfY3VydmVXaXRoT2Zmc2V0KHBvaW50c0xpc3RbMF0sIDEuNSAqICgxICsgby5yb3VnaG5lc3MgKiAwLjIyKSwgY2xvbmVPcHRpb25zQWx0ZXJTZWVkKG8pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBwb2ludHNMaXN0W2ldO1xuICAgICAgICAgICAgaWYgKHBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmRlcmxheSA9IF9jdXJ2ZVdpdGhPZmZzZXQocG9pbnRzLCAxICogKDEgKyBvLnJvdWdobmVzcyAqIDAuMiksIG8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXkgPSBvLmRpc2FibGVNdWx0aVN0cm9rZSA/IFtdIDogX2N1cnZlV2l0aE9mZnNldChwb2ludHMsIDEuNSAqICgxICsgby5yb3VnaG5lc3MgKiAwLjIyKSwgY2xvbmVPcHRpb25zQWx0ZXJTZWVkKG8pKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdW5kZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3AgIT09ICdtb3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbzEucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcCAhPT0gJ21vdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvMi5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzOiBvMS5jb25jYXQobzIpIH07XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzOiBbXSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgbykge1xuICAgIGNvbnN0IHBhcmFtcyA9IGdlbmVyYXRlRWxsaXBzZVBhcmFtcyh3aWR0aCwgaGVpZ2h0LCBvKTtcbiAgICByZXR1cm4gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgcGFyYW1zKS5vcHNldDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUVsbGlwc2VQYXJhbXMod2lkdGgsIGhlaWdodCwgbykge1xuICAgIGNvbnN0IHBzcSA9IE1hdGguc3FydChNYXRoLlBJICogMiAqIE1hdGguc3FydCgoTWF0aC5wb3cod2lkdGggLyAyLCAyKSArIE1hdGgucG93KGhlaWdodCAvIDIsIDIpKSAvIDIpKTtcbiAgICBjb25zdCBzdGVwQ291bnQgPSBNYXRoLmNlaWwoTWF0aC5tYXgoby5jdXJ2ZVN0ZXBDb3VudCwgKG8uY3VydmVTdGVwQ291bnQgLyBNYXRoLnNxcnQoMjAwKSkgKiBwc3EpKTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSAoTWF0aC5QSSAqIDIpIC8gc3RlcENvdW50O1xuICAgIGxldCByeCA9IE1hdGguYWJzKHdpZHRoIC8gMik7XG4gICAgbGV0IHJ5ID0gTWF0aC5hYnMoaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgY3VydmVGaXRSYW5kb21uZXNzID0gMSAtIG8uY3VydmVGaXR0aW5nO1xuICAgIHJ4ICs9IF9vZmZzZXRPcHQocnggKiBjdXJ2ZUZpdFJhbmRvbW5lc3MsIG8pO1xuICAgIHJ5ICs9IF9vZmZzZXRPcHQocnkgKiBjdXJ2ZUZpdFJhbmRvbW5lc3MsIG8pO1xuICAgIHJldHVybiB7IGluY3JlbWVudCwgcngsIHJ5IH07XG59XG5leHBvcnQgZnVuY3Rpb24gZWxsaXBzZVdpdGhQYXJhbXMoeCwgeSwgbywgZWxsaXBzZVBhcmFtcykge1xuICAgIGNvbnN0IFthcDEsIGNwMV0gPSBfY29tcHV0ZUVsbGlwc2VQb2ludHMoZWxsaXBzZVBhcmFtcy5pbmNyZW1lbnQsIHgsIHksIGVsbGlwc2VQYXJhbXMucngsIGVsbGlwc2VQYXJhbXMucnksIDEsIGVsbGlwc2VQYXJhbXMuaW5jcmVtZW50ICogX29mZnNldCgwLjEsIF9vZmZzZXQoMC40LCAxLCBvKSwgbyksIG8pO1xuICAgIGxldCBvMSA9IF9jdXJ2ZShhcDEsIG51bGwsIG8pO1xuICAgIGlmICgoIW8uZGlzYWJsZU11bHRpU3Ryb2tlKSAmJiAoby5yb3VnaG5lc3MgIT09IDApKSB7XG4gICAgICAgIGNvbnN0IFthcDJdID0gX2NvbXB1dGVFbGxpcHNlUG9pbnRzKGVsbGlwc2VQYXJhbXMuaW5jcmVtZW50LCB4LCB5LCBlbGxpcHNlUGFyYW1zLnJ4LCBlbGxpcHNlUGFyYW1zLnJ5LCAxLjUsIDAsIG8pO1xuICAgICAgICBjb25zdCBvMiA9IF9jdXJ2ZShhcDIsIG51bGwsIG8pO1xuICAgICAgICBvMSA9IG8xLmNvbmNhdChvMik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVzdGltYXRlZFBvaW50czogY3AxLFxuICAgICAgICBvcHNldDogeyB0eXBlOiAncGF0aCcsIG9wczogbzEgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFyYyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgc3RvcCwgY2xvc2VkLCByb3VnaENsb3N1cmUsIG8pIHtcbiAgICBjb25zdCBjeCA9IHg7XG4gICAgY29uc3QgY3kgPSB5O1xuICAgIGxldCByeCA9IE1hdGguYWJzKHdpZHRoIC8gMik7XG4gICAgbGV0IHJ5ID0gTWF0aC5hYnMoaGVpZ2h0IC8gMik7XG4gICAgcnggKz0gX29mZnNldE9wdChyeCAqIDAuMDEsIG8pO1xuICAgIHJ5ICs9IF9vZmZzZXRPcHQocnkgKiAwLjAxLCBvKTtcbiAgICBsZXQgc3RydCA9IHN0YXJ0O1xuICAgIGxldCBzdHAgPSBzdG9wO1xuICAgIHdoaWxlIChzdHJ0IDwgMCkge1xuICAgICAgICBzdHJ0ICs9IE1hdGguUEkgKiAyO1xuICAgICAgICBzdHAgKz0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGlmICgoc3RwIC0gc3RydCkgPiAoTWF0aC5QSSAqIDIpKSB7XG4gICAgICAgIHN0cnQgPSAwO1xuICAgICAgICBzdHAgPSBNYXRoLlBJICogMjtcbiAgICB9XG4gICAgY29uc3QgZWxsaXBzZUluYyA9IChNYXRoLlBJICogMikgLyBvLmN1cnZlU3RlcENvdW50O1xuICAgIGNvbnN0IGFyY0luYyA9IE1hdGgubWluKGVsbGlwc2VJbmMgLyAyLCAoc3RwIC0gc3RydCkgLyAyKTtcbiAgICBjb25zdCBvcHMgPSBfYXJjKGFyY0luYywgY3gsIGN5LCByeCwgcnksIHN0cnQsIHN0cCwgMSwgbyk7XG4gICAgaWYgKCFvLmRpc2FibGVNdWx0aVN0cm9rZSkge1xuICAgICAgICBjb25zdCBvMiA9IF9hcmMoYXJjSW5jLCBjeCwgY3ksIHJ4LCByeSwgc3RydCwgc3RwLCAxLjUsIG8pO1xuICAgICAgICBvcHMucHVzaCguLi5vMik7XG4gICAgfVxuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgaWYgKHJvdWdoQ2xvc3VyZSkge1xuICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUoY3gsIGN5LCBjeCArIHJ4ICogTWF0aC5jb3Moc3RydCksIGN5ICsgcnkgKiBNYXRoLnNpbihzdHJ0KSwgbyksIC4uLl9kb3VibGVMaW5lKGN4LCBjeSwgY3ggKyByeCAqIE1hdGguY29zKHN0cCksIGN5ICsgcnkgKiBNYXRoLnNpbihzdHApLCBvKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbGluZVRvJywgZGF0YTogW2N4LCBjeV0gfSwgeyBvcDogJ2xpbmVUbycsIGRhdGE6IFtjeCArIHJ4ICogTWF0aC5jb3Moc3RydCksIGN5ICsgcnkgKiBNYXRoLnNpbihzdHJ0KV0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ3BhdGgnLCBvcHMgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdmdQYXRoKHBhdGgsIG8pIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IG5vcm1hbGl6ZShhYnNvbHV0aXplKHBhcnNlUGF0aChwYXRoKSkpO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IFswLCAwXTtcbiAgICBsZXQgY3VycmVudCA9IFswLCAwXTtcbiAgICBmb3IgKGNvbnN0IHsga2V5LCBkYXRhIH0gb2Ygc2VnbWVudHMpIHtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ00nOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFtkYXRhWzBdLCBkYXRhWzFdXTtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IFtkYXRhWzBdLCBkYXRhWzFdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgICAgICAgIG9wcy5wdXNoKC4uLl9kb3VibGVMaW5lKGN1cnJlbnRbMF0sIGN1cnJlbnRbMV0sIGRhdGFbMF0sIGRhdGFbMV0sIG8pKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gW2RhdGFbMF0sIGRhdGFbMV1dO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTIsIHgsIHldID0gZGF0YTtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCguLi5fYmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgsIHksIGN1cnJlbnQsIG8pKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gW3gsIHldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgb3BzLnB1c2goLi4uX2RvdWJsZUxpbmUoY3VycmVudFswXSwgY3VycmVudFsxXSwgZmlyc3RbMF0sIGZpcnN0WzFdLCBvKSk7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IFtmaXJzdFswXSwgZmlyc3RbMV1dO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6ICdwYXRoJywgb3BzIH07XG59XG4vLyBGaWxsc1xuZXhwb3J0IGZ1bmN0aW9uIHNvbGlkRmlsbFBvbHlnb24ocG9seWdvbkxpc3QsIG8pIHtcbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBvaW50cyBvZiBwb2x5Z29uTGlzdCkge1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gby5tYXhSYW5kb21uZXNzT2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtwb2ludHNbMF1bMF0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksIHBvaW50c1swXVsxXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKV0gfSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbGluZVRvJywgZGF0YTogW3BvaW50c1tpXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSwgcG9pbnRzW2ldWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2ZpbGxQYXRoJywgb3BzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcGF0dGVybkZpbGxQb2x5Z29ucyhwb2x5Z29uTGlzdCwgbykge1xuICAgIHJldHVybiBnZXRGaWxsZXIobywgaGVscGVyKS5maWxsUG9seWdvbnMocG9seWdvbkxpc3QsIG8pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhdHRlcm5GaWxsQXJjKHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0YXJ0LCBzdG9wLCBvKSB7XG4gICAgY29uc3QgY3ggPSB4O1xuICAgIGNvbnN0IGN5ID0geTtcbiAgICBsZXQgcnggPSBNYXRoLmFicyh3aWR0aCAvIDIpO1xuICAgIGxldCByeSA9IE1hdGguYWJzKGhlaWdodCAvIDIpO1xuICAgIHJ4ICs9IF9vZmZzZXRPcHQocnggKiAwLjAxLCBvKTtcbiAgICByeSArPSBfb2Zmc2V0T3B0KHJ5ICogMC4wMSwgbyk7XG4gICAgbGV0IHN0cnQgPSBzdGFydDtcbiAgICBsZXQgc3RwID0gc3RvcDtcbiAgICB3aGlsZSAoc3RydCA8IDApIHtcbiAgICAgICAgc3RydCArPSBNYXRoLlBJICogMjtcbiAgICAgICAgc3RwICs9IE1hdGguUEkgKiAyO1xuICAgIH1cbiAgICBpZiAoKHN0cCAtIHN0cnQpID4gKE1hdGguUEkgKiAyKSkge1xuICAgICAgICBzdHJ0ID0gMDtcbiAgICAgICAgc3RwID0gTWF0aC5QSSAqIDI7XG4gICAgfVxuICAgIGNvbnN0IGluY3JlbWVudCA9IChzdHAgLSBzdHJ0KSAvIG8uY3VydmVTdGVwQ291bnQ7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgZm9yIChsZXQgYW5nbGUgPSBzdHJ0OyBhbmdsZSA8PSBzdHA7IGFuZ2xlID0gYW5nbGUgKyBpbmNyZW1lbnQpIHtcbiAgICAgICAgcG9pbnRzLnB1c2goW2N4ICsgcnggKiBNYXRoLmNvcyhhbmdsZSksIGN5ICsgcnkgKiBNYXRoLnNpbihhbmdsZSldKTtcbiAgICB9XG4gICAgcG9pbnRzLnB1c2goW2N4ICsgcnggKiBNYXRoLmNvcyhzdHApLCBjeSArIHJ5ICogTWF0aC5zaW4oc3RwKV0pO1xuICAgIHBvaW50cy5wdXNoKFtjeCwgY3ldKTtcbiAgICByZXR1cm4gcGF0dGVybkZpbGxQb2x5Z29ucyhbcG9pbnRzXSwgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZE9mZnNldCh4LCBvKSB7XG4gICAgcmV0dXJuIF9vZmZzZXRPcHQoeCwgbyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZE9mZnNldFdpdGhSYW5nZShtaW4sIG1heCwgbykge1xuICAgIHJldHVybiBfb2Zmc2V0KG1pbiwgbWF4LCBvKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkb3VibGVMaW5lRmlsbE9wcyh4MSwgeTEsIHgyLCB5Miwgbykge1xuICAgIHJldHVybiBfZG91YmxlTGluZSh4MSwgeTEsIHgyLCB5MiwgbywgdHJ1ZSk7XG59XG4vLyBQcml2YXRlIGhlbHBlcnNcbmZ1bmN0aW9uIGNsb25lT3B0aW9uc0FsdGVyU2VlZChvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBvcHMpO1xuICAgIHJlc3VsdC5yYW5kb21pemVyID0gdW5kZWZpbmVkO1xuICAgIGlmIChvcHMuc2VlZCkge1xuICAgICAgICByZXN1bHQuc2VlZCA9IG9wcy5zZWVkICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJhbmRvbShvcHMpIHtcbiAgICBpZiAoIW9wcy5yYW5kb21pemVyKSB7XG4gICAgICAgIG9wcy5yYW5kb21pemVyID0gbmV3IFJhbmRvbShvcHMuc2VlZCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcy5yYW5kb21pemVyLm5leHQoKTtcbn1cbmZ1bmN0aW9uIF9vZmZzZXQobWluLCBtYXgsIG9wcywgcm91Z2huZXNzR2FpbiA9IDEpIHtcbiAgICByZXR1cm4gb3BzLnJvdWdobmVzcyAqIHJvdWdobmVzc0dhaW4gKiAoKHJhbmRvbShvcHMpICogKG1heCAtIG1pbikpICsgbWluKTtcbn1cbmZ1bmN0aW9uIF9vZmZzZXRPcHQoeCwgb3BzLCByb3VnaG5lc3NHYWluID0gMSkge1xuICAgIHJldHVybiBfb2Zmc2V0KC14LCB4LCBvcHMsIHJvdWdobmVzc0dhaW4pO1xufVxuZnVuY3Rpb24gX2RvdWJsZUxpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIGZpbGxpbmcgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNpbmdsZVN0cm9rZSA9IGZpbGxpbmcgPyBvLmRpc2FibGVNdWx0aVN0cm9rZUZpbGwgOiBvLmRpc2FibGVNdWx0aVN0cm9rZTtcbiAgICBjb25zdCBvMSA9IF9saW5lKHgxLCB5MSwgeDIsIHkyLCBvLCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKHNpbmdsZVN0cm9rZSkge1xuICAgICAgICByZXR1cm4gbzE7XG4gICAgfVxuICAgIGNvbnN0IG8yID0gX2xpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBvMS5jb25jYXQobzIpO1xufVxuZnVuY3Rpb24gX2xpbmUoeDEsIHkxLCB4MiwgeTIsIG8sIG1vdmUsIG92ZXJsYXkpIHtcbiAgICBjb25zdCBsZW5ndGhTcSA9IE1hdGgucG93KCh4MSAtIHgyKSwgMikgKyBNYXRoLnBvdygoeTEgLSB5MiksIDIpO1xuICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydChsZW5ndGhTcSk7XG4gICAgbGV0IHJvdWdobmVzc0dhaW4gPSAxO1xuICAgIGlmIChsZW5ndGggPCAyMDApIHtcbiAgICAgICAgcm91Z2huZXNzR2FpbiA9IDE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbmd0aCA+IDUwMCkge1xuICAgICAgICByb3VnaG5lc3NHYWluID0gMC40O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcm91Z2huZXNzR2FpbiA9ICgtMC4wMDE2NjY4KSAqIGxlbmd0aCArIDEuMjMzMzM0O1xuICAgIH1cbiAgICBsZXQgb2Zmc2V0ID0gby5tYXhSYW5kb21uZXNzT2Zmc2V0IHx8IDA7XG4gICAgaWYgKChvZmZzZXQgKiBvZmZzZXQgKiAxMDApID4gbGVuZ3RoU3EpIHtcbiAgICAgICAgb2Zmc2V0ID0gbGVuZ3RoIC8gMTA7XG4gICAgfVxuICAgIGNvbnN0IGhhbGZPZmZzZXQgPSBvZmZzZXQgLyAyO1xuICAgIGNvbnN0IGRpdmVyZ2VQb2ludCA9IDAuMiArIHJhbmRvbShvKSAqIDAuMjtcbiAgICBsZXQgbWlkRGlzcFggPSBvLmJvd2luZyAqIG8ubWF4UmFuZG9tbmVzc09mZnNldCAqICh5MiAtIHkxKSAvIDIwMDtcbiAgICBsZXQgbWlkRGlzcFkgPSBvLmJvd2luZyAqIG8ubWF4UmFuZG9tbmVzc09mZnNldCAqICh4MSAtIHgyKSAvIDIwMDtcbiAgICBtaWREaXNwWCA9IF9vZmZzZXRPcHQobWlkRGlzcFgsIG8sIHJvdWdobmVzc0dhaW4pO1xuICAgIG1pZERpc3BZID0gX29mZnNldE9wdChtaWREaXNwWSwgbywgcm91Z2huZXNzR2Fpbik7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3QgcmFuZG9tSGFsZiA9ICgpID0+IF9vZmZzZXRPcHQoaGFsZk9mZnNldCwgbywgcm91Z2huZXNzR2Fpbik7XG4gICAgY29uc3QgcmFuZG9tRnVsbCA9ICgpID0+IF9vZmZzZXRPcHQob2Zmc2V0LCBvLCByb3VnaG5lc3NHYWluKTtcbiAgICBjb25zdCBwcmVzZXJ2ZVZlcnRpY2VzID0gby5wcmVzZXJ2ZVZlcnRpY2VzO1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIGlmIChvdmVybGF5KSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdtb3ZlJywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB4MSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUhhbGYoKSksXG4gICAgICAgICAgICAgICAgICAgIHkxICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogcmFuZG9tSGFsZigpKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6ICdtb3ZlJywgZGF0YTogW1xuICAgICAgICAgICAgICAgICAgICB4MSArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IF9vZmZzZXRPcHQob2Zmc2V0LCBvLCByb3VnaG5lc3NHYWluKSksXG4gICAgICAgICAgICAgICAgICAgIHkxICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogX29mZnNldE9wdChvZmZzZXQsIG8sIHJvdWdobmVzc0dhaW4pKSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgICAgb3BzLnB1c2goe1xuICAgICAgICAgICAgb3A6ICdiY3VydmVUbycsXG4gICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgbWlkRGlzcFggKyB4MSArICh4MiAtIHgxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUhhbGYoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWSArIHkxICsgKHkyIC0geTEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tSGFsZigpLFxuICAgICAgICAgICAgICAgIG1pZERpc3BYICsgeDEgKyAyICogKHgyIC0geDEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tSGFsZigpLFxuICAgICAgICAgICAgICAgIG1pZERpc3BZICsgeTEgKyAyICogKHkyIC0geTEpICogZGl2ZXJnZVBvaW50ICsgcmFuZG9tSGFsZigpLFxuICAgICAgICAgICAgICAgIHgyICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogcmFuZG9tSGFsZigpKSxcbiAgICAgICAgICAgICAgICB5MiArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUhhbGYoKSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIG1pZERpc3BYICsgeDEgKyAoeDIgLSB4MSkgKiBkaXZlcmdlUG9pbnQgKyByYW5kb21GdWxsKCksXG4gICAgICAgICAgICAgICAgbWlkRGlzcFkgKyB5MSArICh5MiAtIHkxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUZ1bGwoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWCArIHgxICsgMiAqICh4MiAtIHgxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUZ1bGwoKSxcbiAgICAgICAgICAgICAgICBtaWREaXNwWSArIHkxICsgMiAqICh5MiAtIHkxKSAqIGRpdmVyZ2VQb2ludCArIHJhbmRvbUZ1bGwoKSxcbiAgICAgICAgICAgICAgICB4MiArIChwcmVzZXJ2ZVZlcnRpY2VzID8gMCA6IHJhbmRvbUZ1bGwoKSksXG4gICAgICAgICAgICAgICAgeTIgKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiByYW5kb21GdWxsKCkpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHM7XG59XG5mdW5jdGlvbiBfY3VydmVXaXRoT2Zmc2V0KHBvaW50cywgb2Zmc2V0LCBvKSB7XG4gICAgaWYgKCFwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgcHMgPSBbXTtcbiAgICBwcy5wdXNoKFtcbiAgICAgICAgcG9pbnRzWzBdWzBdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICBwb2ludHNbMF1bMV0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksXG4gICAgXSk7XG4gICAgcHMucHVzaChbXG4gICAgICAgIHBvaW50c1swXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgcG9pbnRzWzBdWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgIF0pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBzLnB1c2goW1xuICAgICAgICAgICAgcG9pbnRzW2ldWzBdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICAgICAgcG9pbnRzW2ldWzFdICsgX29mZnNldE9wdChvZmZzZXQsIG8pLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGkgPT09IChwb2ludHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHBzLnB1c2goW1xuICAgICAgICAgICAgICAgIHBvaW50c1tpXVswXSArIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSxcbiAgICAgICAgICAgICAgICBwb2ludHNbaV1bMV0gKyBfb2Zmc2V0T3B0KG9mZnNldCwgbyksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2N1cnZlKHBzLCBudWxsLCBvKTtcbn1cbmZ1bmN0aW9uIF9jdXJ2ZShwb2ludHMsIGNsb3NlUG9pbnQsIG8pIHtcbiAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgIGlmIChsZW4gPiAzKSB7XG4gICAgICAgIGNvbnN0IGIgPSBbXTtcbiAgICAgICAgY29uc3QgcyA9IDEgLSBvLmN1cnZlVGlnaHRuZXNzO1xuICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXV0gfSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyAoaSArIDIpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZlcnRBcnJheSA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGJbMF0gPSBbY2FjaGVkVmVydEFycmF5WzBdLCBjYWNoZWRWZXJ0QXJyYXlbMV1dO1xuICAgICAgICAgICAgYlsxXSA9IFtjYWNoZWRWZXJ0QXJyYXlbMF0gKyAocyAqIHBvaW50c1tpICsgMV1bMF0gLSBzICogcG9pbnRzW2kgLSAxXVswXSkgLyA2LCBjYWNoZWRWZXJ0QXJyYXlbMV0gKyAocyAqIHBvaW50c1tpICsgMV1bMV0gLSBzICogcG9pbnRzW2kgLSAxXVsxXSkgLyA2XTtcbiAgICAgICAgICAgIGJbMl0gPSBbcG9pbnRzW2kgKyAxXVswXSArIChzICogcG9pbnRzW2ldWzBdIC0gcyAqIHBvaW50c1tpICsgMl1bMF0pIC8gNiwgcG9pbnRzW2kgKyAxXVsxXSArIChzICogcG9pbnRzW2ldWzFdIC0gcyAqIHBvaW50c1tpICsgMl1bMV0pIC8gNl07XG4gICAgICAgICAgICBiWzNdID0gW3BvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV1dO1xuICAgICAgICAgICAgb3BzLnB1c2goeyBvcDogJ2JjdXJ2ZVRvJywgZGF0YTogW2JbMV1bMF0sIGJbMV1bMV0sIGJbMl1bMF0sIGJbMl1bMV0sIGJbM11bMF0sIGJbM11bMV1dIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbG9zZVBvaW50ICYmIGNsb3NlUG9pbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBjb25zdCBybyA9IG8ubWF4UmFuZG9tbmVzc09mZnNldDtcbiAgICAgICAgICAgIG9wcy5wdXNoKHsgb3A6ICdsaW5lVG8nLCBkYXRhOiBbY2xvc2VQb2ludFswXSArIF9vZmZzZXRPcHQocm8sIG8pLCBjbG9zZVBvaW50WzFdICsgX29mZnNldE9wdChybywgbyldIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMykge1xuICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtwb2ludHNbMV1bMF0sIHBvaW50c1sxXVsxXV0gfSk7XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIHBvaW50c1sxXVswXSwgcG9pbnRzWzFdWzFdLFxuICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSwgcG9pbnRzWzJdWzFdLFxuICAgICAgICAgICAgICAgIHBvaW50c1syXVswXSwgcG9pbnRzWzJdWzFdLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgICBvcHMucHVzaCguLi5fbGluZShwb2ludHNbMF1bMF0sIHBvaW50c1swXVsxXSwgcG9pbnRzWzFdWzBdLCBwb2ludHNbMV1bMV0sIG8sIHRydWUsIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wcztcbn1cbmZ1bmN0aW9uIF9jb21wdXRlRWxsaXBzZVBvaW50cyhpbmNyZW1lbnQsIGN4LCBjeSwgcngsIHJ5LCBvZmZzZXQsIG92ZXJsYXAsIG8pIHtcbiAgICBjb25zdCBjb3JlT25seSA9IG8ucm91Z2huZXNzID09PSAwO1xuICAgIGNvbnN0IGNvcmVQb2ludHMgPSBbXTtcbiAgICBjb25zdCBhbGxQb2ludHMgPSBbXTtcbiAgICBpZiAoY29yZU9ubHkpIHtcbiAgICAgICAgaW5jcmVtZW50ID0gaW5jcmVtZW50IC8gNDtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKC1pbmNyZW1lbnQpLFxuICAgICAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKC1pbmNyZW1lbnQpLFxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChsZXQgYW5nbGUgPSAwOyBhbmdsZSA8PSBNYXRoLlBJICogMjsgYW5nbGUgPSBhbmdsZSArIGluY3JlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IFtcbiAgICAgICAgICAgICAgICBjeCArIHJ4ICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgICAgICAgIGN5ICsgcnkgKiBNYXRoLnNpbihhbmdsZSksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29yZVBvaW50cy5wdXNoKHApO1xuICAgICAgICAgICAgYWxsUG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKDApLFxuICAgICAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKDApLFxuICAgICAgICBdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgY3ggKyByeCAqIE1hdGguY29zKGluY3JlbWVudCksXG4gICAgICAgICAgICBjeSArIHJ5ICogTWF0aC5zaW4oaW5jcmVtZW50KSxcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByYWRPZmZzZXQgPSBfb2Zmc2V0T3B0KDAuNSwgbykgLSAoTWF0aC5QSSAvIDIpO1xuICAgICAgICBhbGxQb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIDAuOSAqIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0IC0gaW5jcmVtZW50KSxcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgMC45ICogcnkgKiBNYXRoLnNpbihyYWRPZmZzZXQgLSBpbmNyZW1lbnQpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBNYXRoLlBJICogMiArIHJhZE9mZnNldCAtIDAuMDE7XG4gICAgICAgIGZvciAobGV0IGFuZ2xlID0gcmFkT2Zmc2V0OyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSA9IGFuZ2xlICsgaW5jcmVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwID0gW1xuICAgICAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgcnggKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3kgKyByeSAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb3JlUG9pbnRzLnB1c2gocCk7XG4gICAgICAgICAgICBhbGxQb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxQb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0ICsgTWF0aC5QSSAqIDIgKyBvdmVybGFwICogMC41KSxcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgcnkgKiBNYXRoLnNpbihyYWRPZmZzZXQgKyBNYXRoLlBJICogMiArIG92ZXJsYXAgKiAwLjUpLFxuICAgICAgICBdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goW1xuICAgICAgICAgICAgX29mZnNldE9wdChvZmZzZXQsIG8pICsgY3ggKyAwLjk4ICogcnggKiBNYXRoLmNvcyhyYWRPZmZzZXQgKyBvdmVybGFwKSxcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN5ICsgMC45OCAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0ICsgb3ZlcmxhcCksXG4gICAgICAgIF0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChbXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeCArIDAuOSAqIHJ4ICogTWF0aC5jb3MocmFkT2Zmc2V0ICsgb3ZlcmxhcCAqIDAuNSksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIDAuOSAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0ICsgb3ZlcmxhcCAqIDAuNSksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gW2FsbFBvaW50cywgY29yZVBvaW50c107XG59XG5mdW5jdGlvbiBfYXJjKGluY3JlbWVudCwgY3gsIGN5LCByeCwgcnksIHN0cnQsIHN0cCwgb2Zmc2V0LCBvKSB7XG4gICAgY29uc3QgcmFkT2Zmc2V0ID0gc3RydCArIF9vZmZzZXRPcHQoMC4xLCBvKTtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBwb2ludHMucHVzaChbXG4gICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgMC45ICogcnggKiBNYXRoLmNvcyhyYWRPZmZzZXQgLSBpbmNyZW1lbnQpLFxuICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIDAuOSAqIHJ5ICogTWF0aC5zaW4ocmFkT2Zmc2V0IC0gaW5jcmVtZW50KSxcbiAgICBdKTtcbiAgICBmb3IgKGxldCBhbmdsZSA9IHJhZE9mZnNldDsgYW5nbGUgPD0gc3RwOyBhbmdsZSA9IGFuZ2xlICsgaW5jcmVtZW50KSB7XG4gICAgICAgIHBvaW50cy5wdXNoKFtcbiAgICAgICAgICAgIF9vZmZzZXRPcHQob2Zmc2V0LCBvKSArIGN4ICsgcnggKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICBfb2Zmc2V0T3B0KG9mZnNldCwgbykgKyBjeSArIHJ5ICogTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgcG9pbnRzLnB1c2goW1xuICAgICAgICBjeCArIHJ4ICogTWF0aC5jb3Moc3RwKSxcbiAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKHN0cCksXG4gICAgXSk7XG4gICAgcG9pbnRzLnB1c2goW1xuICAgICAgICBjeCArIHJ4ICogTWF0aC5jb3Moc3RwKSxcbiAgICAgICAgY3kgKyByeSAqIE1hdGguc2luKHN0cCksXG4gICAgXSk7XG4gICAgcmV0dXJuIF9jdXJ2ZShwb2ludHMsIG51bGwsIG8pO1xufVxuZnVuY3Rpb24gX2JlemllclRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5LCBjdXJyZW50LCBvKSB7XG4gICAgY29uc3Qgb3BzID0gW107XG4gICAgY29uc3Qgcm9zID0gW28ubWF4UmFuZG9tbmVzc09mZnNldCB8fCAxLCAoby5tYXhSYW5kb21uZXNzT2Zmc2V0IHx8IDEpICsgMC4zXTtcbiAgICBsZXQgZiA9IFswLCAwXTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gby5kaXNhYmxlTXVsdGlTdHJva2UgPyAxIDogMjtcbiAgICBjb25zdCBwcmVzZXJ2ZVZlcnRpY2VzID0gby5wcmVzZXJ2ZVZlcnRpY2VzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBvcHMucHVzaCh7IG9wOiAnbW92ZScsIGRhdGE6IFtjdXJyZW50WzBdLCBjdXJyZW50WzFdXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wcy5wdXNoKHsgb3A6ICdtb3ZlJywgZGF0YTogW2N1cnJlbnRbMF0gKyAocHJlc2VydmVWZXJ0aWNlcyA/IDAgOiBfb2Zmc2V0T3B0KHJvc1swXSwgbykpLCBjdXJyZW50WzFdICsgKHByZXNlcnZlVmVydGljZXMgPyAwIDogX29mZnNldE9wdChyb3NbMF0sIG8pKV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZiA9IHByZXNlcnZlVmVydGljZXMgPyBbeCwgeV0gOiBbeCArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSwgeSArIF9vZmZzZXRPcHQocm9zW2ldLCBvKV07XG4gICAgICAgIG9wcy5wdXNoKHtcbiAgICAgICAgICAgIG9wOiAnYmN1cnZlVG8nLFxuICAgICAgICAgICAgZGF0YTogW1xuICAgICAgICAgICAgICAgIHgxICsgX29mZnNldE9wdChyb3NbaV0sIG8pLCB5MSArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSxcbiAgICAgICAgICAgICAgICB4MiArIF9vZmZzZXRPcHQocm9zW2ldLCBvKSwgeTIgKyBfb2Zmc2V0T3B0KHJvc1tpXSwgbyksXG4gICAgICAgICAgICAgICAgZlswXSwgZlsxXSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3BzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/renderer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/rough.js":
/*!*******************************************!*\
  !*** ./node_modules/roughjs/bin/rough.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./canvas */ \"(ssr)/./node_modules/roughjs/bin/canvas.js\");\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generator */ \"(ssr)/./node_modules/roughjs/bin/generator.js\");\n/* harmony import */ var _svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./svg */ \"(ssr)/./node_modules/roughjs/bin/svg.js\");\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    canvas(canvas, config) {\n        return new _canvas__WEBPACK_IMPORTED_MODULE_0__.RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new _svg__WEBPACK_IMPORTED_MODULE_2__.RoughSVG(svg, config);\n    },\n    generator(config) {\n        return new _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator(config);\n    },\n    newSeed() {\n        return _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator.newSeed();\n    },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vcm91Z2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1QztBQUNNO0FBQ1o7QUFDakMsaUVBQWU7QUFDZjtBQUNBLG1CQUFtQixnREFBVztBQUM5QixLQUFLO0FBQ0w7QUFDQSxtQkFBbUIsMENBQVE7QUFDM0IsS0FBSztBQUNMO0FBQ0EsbUJBQW1CLHNEQUFjO0FBQ2pDLEtBQUs7QUFDTDtBQUNBLGVBQWUsc0RBQWM7QUFDN0IsS0FBSztBQUNMLENBQUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2lkZWFmbG93Ly4vbm9kZV9tb2R1bGVzL3JvdWdoanMvYmluL3JvdWdoLmpzPzMyNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUm91Z2hDYW52YXMgfSBmcm9tICcuL2NhbnZhcyc7XG5pbXBvcnQgeyBSb3VnaEdlbmVyYXRvciB9IGZyb20gJy4vZ2VuZXJhdG9yJztcbmltcG9ydCB7IFJvdWdoU1ZHIH0gZnJvbSAnLi9zdmcnO1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNhbnZhcyhjYW52YXMsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IFJvdWdoQ2FudmFzKGNhbnZhcywgY29uZmlnKTtcbiAgICB9LFxuICAgIHN2ZyhzdmcsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gbmV3IFJvdWdoU1ZHKHN2ZywgY29uZmlnKTtcbiAgICB9LFxuICAgIGdlbmVyYXRvcihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VnaEdlbmVyYXRvcihjb25maWcpO1xuICAgIH0sXG4gICAgbmV3U2VlZCgpIHtcbiAgICAgICAgcmV0dXJuIFJvdWdoR2VuZXJhdG9yLm5ld1NlZWQoKTtcbiAgICB9LFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/rough.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bin/svg.js":
/*!*****************************************!*\
  !*** ./node_modules/roughjs/bin/svg.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RoughSVG: () => (/* binding */ RoughSVG)\n/* harmony export */ });\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core */ \"(ssr)/./node_modules/roughjs/bin/core.js\");\n/* harmony import */ var _generator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generator */ \"(ssr)/./node_modules/roughjs/bin/generator.js\");\n\n\nclass RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new _generator__WEBPACK_IMPORTED_MODULE_1__.RoughGenerator(config);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'g');\n        const precision = drawable.options.fixedDecimalPlaceDigits;\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', o.stroke);\n                    path.setAttribute('stroke-width', o.strokeWidth + '');\n                    path.setAttribute('fill', 'none');\n                    if (o.strokeLineDash) {\n                        path.setAttribute('stroke-dasharray', o.strokeLineDash.join(' ').trim());\n                    }\n                    if (o.strokeLineDashOffset) {\n                        path.setAttribute('stroke-dashoffset', `${o.strokeLineDashOffset}`);\n                    }\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing, precision));\n                    path.setAttribute('stroke', 'none');\n                    path.setAttribute('stroke-width', '0');\n                    path.setAttribute('fill', o.fill || '');\n                    if (drawable.shape === 'curve' || drawable.shape === 'polygon') {\n                        path.setAttribute('fill-rule', 'evenodd');\n                    }\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(_core__WEBPACK_IMPORTED_MODULE_0__.SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing, o.fixedDecimalPlaceDigits));\n        path.setAttribute('stroke', o.fill || '');\n        path.setAttribute('stroke-width', fweight + '');\n        path.setAttribute('fill', 'none');\n        if (o.fillLineDash) {\n            path.setAttribute('stroke-dasharray', o.fillLineDash.join(' ').trim());\n        }\n        if (o.fillLineDashOffset) {\n            path.setAttribute('stroke-dashoffset', `${o.fillLineDashOffset}`);\n        }\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing, fixedDecimalPlaceDigits) {\n        return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9iaW4vc3ZnLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUErQjtBQUNjO0FBQ3RDO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixzREFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHdDQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0NBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx1QkFBdUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msd0NBQUs7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0NBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9yb3VnaGpzL2Jpbi9zdmcuanM/NmM1MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTVkdOUyB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQgeyBSb3VnaEdlbmVyYXRvciB9IGZyb20gJy4vZ2VuZXJhdG9yJztcbmV4cG9ydCBjbGFzcyBSb3VnaFNWRyB7XG4gICAgY29uc3RydWN0b3Ioc3ZnLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMuZ2VuID0gbmV3IFJvdWdoR2VuZXJhdG9yKGNvbmZpZyk7XG4gICAgfVxuICAgIGRyYXcoZHJhd2FibGUpIHtcbiAgICAgICAgY29uc3Qgc2V0cyA9IGRyYXdhYmxlLnNldHMgfHwgW107XG4gICAgICAgIGNvbnN0IG8gPSBkcmF3YWJsZS5vcHRpb25zIHx8IHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5zdmcub3duZXJEb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG4gICAgICAgIGNvbnN0IGcgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR05TLCAnZycpO1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBkcmF3YWJsZS5vcHRpb25zLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzO1xuICAgICAgICBmb3IgKGNvbnN0IGRyYXdpbmcgb2Ygc2V0cykge1xuICAgICAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICAgICAgc3dpdGNoIChkcmF3aW5nLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gZG9jLmNyZWF0ZUVsZW1lbnROUyhTVkdOUywgJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLm9wc1RvUGF0aChkcmF3aW5nLCBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG8uc3Ryb2tlKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIG8uc3Ryb2tlV2lkdGggKyAnJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8uc3Ryb2tlTGluZURhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5Jywgby5zdHJva2VMaW5lRGFzaC5qb2luKCcgJykudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoby5zdHJva2VMaW5lRGFzaE9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgYCR7by5zdHJva2VMaW5lRGFzaE9mZnNldH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlsbFBhdGgnOiB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR05TLCAncGF0aCcpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMub3BzVG9QYXRoKGRyYXdpbmcsIHByZWNpc2lvbikpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ25vbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgby5maWxsIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYXdhYmxlLnNoYXBlID09PSAnY3VydmUnIHx8IGRyYXdhYmxlLnNoYXBlID09PSAncG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmaWxsU2tldGNoJzoge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gdGhpcy5maWxsU2tldGNoKGRvYywgZHJhd2luZywgbyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZztcbiAgICB9XG4gICAgZmlsbFNrZXRjaChkb2MsIGRyYXdpbmcsIG8pIHtcbiAgICAgICAgbGV0IGZ3ZWlnaHQgPSBvLmZpbGxXZWlnaHQ7XG4gICAgICAgIGlmIChmd2VpZ2h0IDwgMCkge1xuICAgICAgICAgICAgZndlaWdodCA9IG8uc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGggPSBkb2MuY3JlYXRlRWxlbWVudE5TKFNWR05TLCAncGF0aCcpO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRoaXMub3BzVG9QYXRoKGRyYXdpbmcsIG8uZml4ZWREZWNpbWFsUGxhY2VEaWdpdHMpKTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG8uZmlsbCB8fCAnJyk7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBmd2VpZ2h0ICsgJycpO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgICAgIGlmIChvLmZpbGxMaW5lRGFzaCkge1xuICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBvLmZpbGxMaW5lRGFzaC5qb2luKCcgJykudHJpbSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoby5maWxsTGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIGAke28uZmlsbExpbmVEYXNoT2Zmc2V0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBnZXQgZ2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW47XG4gICAgfVxuICAgIGdldERlZmF1bHRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW4uZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuICAgIG9wc1RvUGF0aChkcmF3aW5nLCBmaXhlZERlY2ltYWxQbGFjZURpZ2l0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW4ub3BzVG9QYXRoKGRyYXdpbmcsIGZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzKTtcbiAgICB9XG4gICAgbGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZSh4MSwgeTEsIHgyLCB5Miwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIHJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5yZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIGVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uZWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgY2lyY2xlKHgsIHksIGRpYW1ldGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5jaXJjbGUoeCwgeSwgZGlhbWV0ZXIsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBsaW5lYXJQYXRoKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ubGluZWFyUGF0aChwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBwb2x5Z29uKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4ucG9seWdvbihwb2ludHMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGQpO1xuICAgIH1cbiAgICBhcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCA9IGZhbHNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmdlbi5hcmMoeCwgeSwgd2lkdGgsIGhlaWdodCwgc3RhcnQsIHN0b3AsIGNsb3NlZCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXcoZCk7XG4gICAgfVxuICAgIGN1cnZlKHBvaW50cywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkID0gdGhpcy5nZW4uY3VydmUocG9pbnRzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhdyhkKTtcbiAgICB9XG4gICAgcGF0aChkLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRyYXdpbmcgPSB0aGlzLmdlbi5wYXRoKGQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3KGRyYXdpbmcpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bin/svg.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/roughjs/bundled/rough.esm.js":
/*!***************************************************!*\
  !*** ./node_modules/roughjs/bundled/rough.esm.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ at)\n/* harmony export */ });\nfunction t(t,e,s){if(t&&t.length){const[n,o]=e,a=Math.PI/180*s,h=Math.cos(a),r=Math.sin(a);for(const e of t){const[t,s]=e;e[0]=(t-n)*h-(s-o)*r+n,e[1]=(t-n)*r+(s-o)*h+o}}}function e(t,e){return t[0]===e[0]&&t[1]===e[1]}function s(s,n,o,a=1){const h=o,r=Math.max(n,.1),i=s[0]&&s[0][0]&&\"number\"==typeof s[0][0]?[s]:s,c=[0,0];if(h)for(const e of i)t(e,c,h);const l=function(t,s,n){const o=[];for(const s of t){const t=[...s];e(t[0],t[t.length-1])||t.push([t[0][0],t[0][1]]),t.length>2&&o.push(t)}const a=[];s=Math.max(s,.1);const h=[];for(const t of o)for(let e=0;e<t.length-1;e++){const s=t[e],n=t[e+1];if(s[1]!==n[1]){const t=Math.min(s[1],n[1]);h.push({ymin:t,ymax:Math.max(s[1],n[1]),x:t===s[1]?s[0]:n[0],islope:(n[0]-s[0])/(n[1]-s[1])})}}if(h.sort(((t,e)=>t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax))),!h.length)return a;let r=[],i=h[0].ymin,c=0;for(;r.length||h.length;){if(h.length){let t=-1;for(let e=0;e<h.length&&!(h[e].ymin>i);e++)t=e;h.splice(0,t+1).forEach((t=>{r.push({s:i,edge:t})}))}if(r=r.filter((t=>!(t.edge.ymax<=i))),r.sort(((t,e)=>t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x))),(1!==n||c%s==0)&&r.length>1)for(let t=0;t<r.length;t+=2){const e=t+1;if(e>=r.length)break;const s=r[t].edge,n=r[e].edge;a.push([[Math.round(s.x),i],[Math.round(n.x),i]])}i+=n,r.forEach((t=>{t.edge.x=t.edge.x+n*t.edge.islope})),c++}return a}(i,r,a);if(h){for(const e of i)t(e,c,-h);!function(e,s,n){const o=[];e.forEach((t=>o.push(...t))),t(o,s,n)}(l,c,-h)}return l}function n(t,e){var n;const o=e.hachureAngle+90;let a=e.hachureGap;a<0&&(a=4*e.strokeWidth),a=Math.round(Math.max(a,.1));let h=1;return e.roughness>=1&&((null===(n=e.randomizer)||void 0===n?void 0:n.next())||Math.random())>.7&&(h=a),s(t,a,o,h||1)}class o{constructor(t){this.helper=t}fillPolygons(t,e){return this._fillPolygons(t,e)}_fillPolygons(t,e){const s=n(t,e);return{type:\"fillSketch\",ops:this.renderLines(s,e)}}renderLines(t,e){const s=[];for(const n of t)s.push(...this.helper.doubleLineOps(n[0][0],n[0][1],n[1][0],n[1][1],e));return s}}function a(t){const e=t[0],s=t[1];return Math.sqrt(Math.pow(e[0]-s[0],2)+Math.pow(e[1]-s[1],2))}class h extends o{fillPolygons(t,e){let s=e.hachureGap;s<0&&(s=4*e.strokeWidth),s=Math.max(s,.1);const o=n(t,Object.assign({},e,{hachureGap:s})),h=Math.PI/180*e.hachureAngle,r=[],i=.5*s*Math.cos(h),c=.5*s*Math.sin(h);for(const[t,e]of o)a([t,e])&&r.push([[t[0]-i,t[1]+c],[...e]],[[t[0]+i,t[1]-c],[...e]]);return{type:\"fillSketch\",ops:this.renderLines(r,e)}}}class r extends o{fillPolygons(t,e){const s=this._fillPolygons(t,e),n=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),o=this._fillPolygons(t,n);return s.ops=s.ops.concat(o.ops),s}}class i{constructor(t){this.helper=t}fillPolygons(t,e){const s=n(t,e=Object.assign({},e,{hachureAngle:0}));return this.dotsOnLines(s,e)}dotsOnLines(t,e){const s=[];let n=e.hachureGap;n<0&&(n=4*e.strokeWidth),n=Math.max(n,.1);let o=e.fillWeight;o<0&&(o=e.strokeWidth/2);const h=n/4;for(const r of t){const t=a(r),i=t/n,c=Math.ceil(i)-1,l=t-c*n,u=(r[0][0]+r[1][0])/2-n/4,p=Math.min(r[0][1],r[1][1]);for(let t=0;t<c;t++){const a=p+l+t*n,r=u-h+2*Math.random()*h,i=a-h+2*Math.random()*h,c=this.helper.ellipse(r,i,o,o,e);s.push(...c.ops)}}return{type:\"fillSketch\",ops:s}}}class c{constructor(t){this.helper=t}fillPolygons(t,e){const s=n(t,e);return{type:\"fillSketch\",ops:this.dashedLine(s,e)}}dashedLine(t,e){const s=e.dashOffset<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashOffset,n=e.dashGap<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashGap,o=[];return t.forEach((t=>{const h=a(t),r=Math.floor(h/(s+n)),i=(h+n-r*(s+n))/2;let c=t[0],l=t[1];c[0]>l[0]&&(c=t[1],l=t[0]);const u=Math.atan((l[1]-c[1])/(l[0]-c[0]));for(let t=0;t<r;t++){const a=t*(s+n),h=a+s,r=[c[0]+a*Math.cos(u)+i*Math.cos(u),c[1]+a*Math.sin(u)+i*Math.sin(u)],l=[c[0]+h*Math.cos(u)+i*Math.cos(u),c[1]+h*Math.sin(u)+i*Math.sin(u)];o.push(...this.helper.doubleLineOps(r[0],r[1],l[0],l[1],e))}})),o}}class l{constructor(t){this.helper=t}fillPolygons(t,e){const s=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,o=e.zigzagOffset<0?s:e.zigzagOffset,a=n(t,e=Object.assign({},e,{hachureGap:s+o}));return{type:\"fillSketch\",ops:this.zigzagLines(a,o,e)}}zigzagLines(t,e,s){const n=[];return t.forEach((t=>{const o=a(t),h=Math.round(o/(2*e));let r=t[0],i=t[1];r[0]>i[0]&&(r=t[1],i=t[0]);const c=Math.atan((i[1]-r[1])/(i[0]-r[0]));for(let t=0;t<h;t++){const o=2*t*e,a=2*(t+1)*e,h=Math.sqrt(2*Math.pow(e,2)),i=[r[0]+o*Math.cos(c),r[1]+o*Math.sin(c)],l=[r[0]+a*Math.cos(c),r[1]+a*Math.sin(c)],u=[i[0]+h*Math.cos(c+Math.PI/4),i[1]+h*Math.sin(c+Math.PI/4)];n.push(...this.helper.doubleLineOps(i[0],i[1],u[0],u[1],s),...this.helper.doubleLineOps(u[0],u[1],l[0],l[1],s))}})),n}}const u={};class p{constructor(t){this.seed=t}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}const f=0,d=1,g=2,M={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function k(t,e){return t.type===e}function b(t){const e=[],s=function(t){const e=new Array;for(;\"\"!==t;)if(t.match(/^([ \\t\\r\\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:f,text:RegExp.$1},t=t.substr(RegExp.$1.length);else{if(!t.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/))return[];e[e.length]={type:d,text:`${parseFloat(RegExp.$1)}`},t=t.substr(RegExp.$1.length)}return e[e.length]={type:g,text:\"\"},e}(t);let n=\"BOD\",o=0,a=s[o];for(;!k(a,g);){let h=0;const r=[];if(\"BOD\"===n){if(\"M\"!==a.text&&\"m\"!==a.text)return b(\"M0,0\"+t);o++,h=M[a.text],n=a.text}else k(a,d)?h=M[n]:(o++,h=M[a.text],n=a.text);if(!(o+h<s.length))throw new Error(\"Path data ended short\");for(let t=o;t<o+h;t++){const e=s[t];if(!k(e,d))throw new Error(\"Param not a number: \"+n+\",\"+e.text);r[r.length]=+e.text}if(\"number\"!=typeof M[n])throw new Error(\"Bad segment: \"+n);{const t={key:n,data:r};e.push(t),o+=h,a=s[o],\"M\"===n&&(n=\"L\"),\"m\"===n&&(n=\"l\")}}return e}function y(t){let e=0,s=0,n=0,o=0;const a=[];for(const{key:h,data:r}of t)switch(h){case\"M\":a.push({key:\"M\",data:[...r]}),[e,s]=r,[n,o]=r;break;case\"m\":e+=r[0],s+=r[1],a.push({key:\"M\",data:[e,s]}),n=e,o=s;break;case\"L\":a.push({key:\"L\",data:[...r]}),[e,s]=r;break;case\"l\":e+=r[0],s+=r[1],a.push({key:\"L\",data:[e,s]});break;case\"C\":a.push({key:\"C\",data:[...r]}),e=r[4],s=r[5];break;case\"c\":{const t=r.map(((t,n)=>n%2?t+s:t+e));a.push({key:\"C\",data:t}),e=t[4],s=t[5];break}case\"Q\":a.push({key:\"Q\",data:[...r]}),e=r[2],s=r[3];break;case\"q\":{const t=r.map(((t,n)=>n%2?t+s:t+e));a.push({key:\"Q\",data:t}),e=t[2],s=t[3];break}case\"A\":a.push({key:\"A\",data:[...r]}),e=r[5],s=r[6];break;case\"a\":e+=r[5],s+=r[6],a.push({key:\"A\",data:[r[0],r[1],r[2],r[3],r[4],e,s]});break;case\"H\":a.push({key:\"H\",data:[...r]}),e=r[0];break;case\"h\":e+=r[0],a.push({key:\"H\",data:[e]});break;case\"V\":a.push({key:\"V\",data:[...r]}),s=r[0];break;case\"v\":s+=r[0],a.push({key:\"V\",data:[s]});break;case\"S\":a.push({key:\"S\",data:[...r]}),e=r[2],s=r[3];break;case\"s\":{const t=r.map(((t,n)=>n%2?t+s:t+e));a.push({key:\"S\",data:t}),e=t[2],s=t[3];break}case\"T\":a.push({key:\"T\",data:[...r]}),e=r[0],s=r[1];break;case\"t\":e+=r[0],s+=r[1],a.push({key:\"T\",data:[e,s]});break;case\"Z\":case\"z\":a.push({key:\"Z\",data:[]}),e=n,s=o}return a}function m(t){const e=[];let s=\"\",n=0,o=0,a=0,h=0,r=0,i=0;for(const{key:c,data:l}of t){switch(c){case\"M\":e.push({key:\"M\",data:[...l]}),[n,o]=l,[a,h]=l;break;case\"C\":e.push({key:\"C\",data:[...l]}),n=l[4],o=l[5],r=l[2],i=l[3];break;case\"L\":e.push({key:\"L\",data:[...l]}),[n,o]=l;break;case\"H\":n=l[0],e.push({key:\"L\",data:[n,o]});break;case\"V\":o=l[0],e.push({key:\"L\",data:[n,o]});break;case\"S\":{let t=0,a=0;\"C\"===s||\"S\"===s?(t=n+(n-r),a=o+(o-i)):(t=n,a=o),e.push({key:\"C\",data:[t,a,...l]}),r=l[0],i=l[1],n=l[2],o=l[3];break}case\"T\":{const[t,a]=l;let h=0,c=0;\"Q\"===s||\"T\"===s?(h=n+(n-r),c=o+(o-i)):(h=n,c=o);const u=n+2*(h-n)/3,p=o+2*(c-o)/3,f=t+2*(h-t)/3,d=a+2*(c-a)/3;e.push({key:\"C\",data:[u,p,f,d,t,a]}),r=h,i=c,n=t,o=a;break}case\"Q\":{const[t,s,a,h]=l,c=n+2*(t-n)/3,u=o+2*(s-o)/3,p=a+2*(t-a)/3,f=h+2*(s-h)/3;e.push({key:\"C\",data:[c,u,p,f,a,h]}),r=t,i=s,n=a,o=h;break}case\"A\":{const t=Math.abs(l[0]),s=Math.abs(l[1]),a=l[2],h=l[3],r=l[4],i=l[5],c=l[6];if(0===t||0===s)e.push({key:\"C\",data:[n,o,i,c,i,c]}),n=i,o=c;else if(n!==i||o!==c){x(n,o,i,c,t,s,a,h,r).forEach((function(t){e.push({key:\"C\",data:t})})),n=i,o=c}break}case\"Z\":e.push({key:\"Z\",data:[]}),n=a,o=h}s=c}return e}function w(t,e,s){return[t*Math.cos(s)-e*Math.sin(s),t*Math.sin(s)+e*Math.cos(s)]}function x(t,e,s,n,o,a,h,r,i,c){const l=(u=h,Math.PI*u/180);var u;let p=[],f=0,d=0,g=0,M=0;if(c)[f,d,g,M]=c;else{[t,e]=w(t,e,-l),[s,n]=w(s,n,-l);const h=(t-s)/2,c=(e-n)/2;let u=h*h/(o*o)+c*c/(a*a);u>1&&(u=Math.sqrt(u),o*=u,a*=u);const p=o*o,k=a*a,b=p*k-p*c*c-k*h*h,y=p*c*c+k*h*h,m=(r===i?-1:1)*Math.sqrt(Math.abs(b/y));g=m*o*c/a+(t+s)/2,M=m*-a*h/o+(e+n)/2,f=Math.asin(parseFloat(((e-M)/a).toFixed(9))),d=Math.asin(parseFloat(((n-M)/a).toFixed(9))),t<g&&(f=Math.PI-f),s<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),i&&f>d&&(f-=2*Math.PI),!i&&d>f&&(d-=2*Math.PI)}let k=d-f;if(Math.abs(k)>120*Math.PI/180){const t=d,e=s,r=n;d=i&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,p=x(s=g+o*Math.cos(d),n=M+a*Math.sin(d),e,r,o,a,h,0,i,[d,t,g,M])}k=d-f;const b=Math.cos(f),y=Math.sin(f),m=Math.cos(d),P=Math.sin(d),v=Math.tan(k/4),S=4/3*o*v,O=4/3*a*v,L=[t,e],T=[t+S*y,e-O*b],D=[s+S*P,n-O*m],A=[s,n];if(T[0]=2*L[0]-T[0],T[1]=2*L[1]-T[1],c)return[T,D,A].concat(p);{p=[T,D,A].concat(p);const t=[];for(let e=0;e<p.length;e+=3){const s=w(p[e][0],p[e][1],l),n=w(p[e+1][0],p[e+1][1],l),o=w(p[e+2][0],p[e+2][1],l);t.push([s[0],s[1],n[0],n[1],o[0],o[1]])}return t}}const P={randOffset:function(t,e){return G(t,e)},randOffsetWithRange:function(t,e,s){return E(t,e,s)},ellipse:function(t,e,s,n,o){const a=T(s,n,o);return D(t,e,o,a).opset},doubleLineOps:function(t,e,s,n,o){return $(t,e,s,n,o,!0)}};function v(t,e,s,n,o){return{type:\"path\",ops:$(t,e,s,n,o)}}function S(t,e,s){const n=(t||[]).length;if(n>2){const o=[];for(let e=0;e<n-1;e++)o.push(...$(t[e][0],t[e][1],t[e+1][0],t[e+1][1],s));return e&&o.push(...$(t[n-1][0],t[n-1][1],t[0][0],t[0][1],s)),{type:\"path\",ops:o}}return 2===n?v(t[0][0],t[0][1],t[1][0],t[1][1],s):{type:\"path\",ops:[]}}function O(t,e,s,n,o){return function(t,e){return S(t,!0,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function L(t,e){if(t.length){const s=\"number\"==typeof t[0][0]?[t]:t,n=j(s[0],1*(1+.2*e.roughness),e),o=e.disableMultiStroke?[]:j(s[0],1.5*(1+.22*e.roughness),z(e));for(let t=1;t<s.length;t++){const a=s[t];if(a.length){const t=j(a,1*(1+.2*e.roughness),e),s=e.disableMultiStroke?[]:j(a,1.5*(1+.22*e.roughness),z(e));for(const e of t)\"move\"!==e.op&&n.push(e);for(const t of s)\"move\"!==t.op&&o.push(t)}}return{type:\"path\",ops:n.concat(o)}}return{type:\"path\",ops:[]}}function T(t,e,s){const n=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),o=Math.ceil(Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*n)),a=2*Math.PI/o;let h=Math.abs(t/2),r=Math.abs(e/2);const i=1-s.curveFitting;return h+=G(h*i,s),r+=G(r*i,s),{increment:a,rx:h,ry:r}}function D(t,e,s,n){const[o,a]=F(n.increment,t,e,n.rx,n.ry,1,n.increment*E(.1,E(.4,1,s),s),s);let h=q(o,null,s);if(!s.disableMultiStroke&&0!==s.roughness){const[o]=F(n.increment,t,e,n.rx,n.ry,1.5,0,s),a=q(o,null,s);h=h.concat(a)}return{estimatedPoints:a,opset:{type:\"path\",ops:h}}}function A(t,e,s,n,o,a,h,r,i){const c=t,l=e;let u=Math.abs(s/2),p=Math.abs(n/2);u+=G(.01*u,i),p+=G(.01*p,i);let f=o,d=a;for(;f<0;)f+=2*Math.PI,d+=2*Math.PI;d-f>2*Math.PI&&(f=0,d=2*Math.PI);const g=2*Math.PI/i.curveStepCount,M=Math.min(g/2,(d-f)/2),k=V(M,c,l,u,p,f,d,1,i);if(!i.disableMultiStroke){const t=V(M,c,l,u,p,f,d,1.5,i);k.push(...t)}return h&&(r?k.push(...$(c,l,c+u*Math.cos(f),l+p*Math.sin(f),i),...$(c,l,c+u*Math.cos(d),l+p*Math.sin(d),i)):k.push({op:\"lineTo\",data:[c,l]},{op:\"lineTo\",data:[c+u*Math.cos(f),l+p*Math.sin(f)]})),{type:\"path\",ops:k}}function _(t,e){const s=m(y(b(t))),n=[];let o=[0,0],a=[0,0];for(const{key:t,data:h}of s)switch(t){case\"M\":a=[h[0],h[1]],o=[h[0],h[1]];break;case\"L\":n.push(...$(a[0],a[1],h[0],h[1],e)),a=[h[0],h[1]];break;case\"C\":{const[t,s,o,r,i,c]=h;n.push(...Z(t,s,o,r,i,c,a,e)),a=[i,c];break}case\"Z\":n.push(...$(a[0],a[1],o[0],o[1],e)),a=[o[0],o[1]]}return{type:\"path\",ops:n}}function I(t,e){const s=[];for(const n of t)if(n.length){const t=e.maxRandomnessOffset||0,o=n.length;if(o>2){s.push({op:\"move\",data:[n[0][0]+G(t,e),n[0][1]+G(t,e)]});for(let a=1;a<o;a++)s.push({op:\"lineTo\",data:[n[a][0]+G(t,e),n[a][1]+G(t,e)]})}}return{type:\"fillPath\",ops:s}}function C(t,e){return function(t,e){let s=t.fillStyle||\"hachure\";if(!u[s])switch(s){case\"zigzag\":u[s]||(u[s]=new h(e));break;case\"cross-hatch\":u[s]||(u[s]=new r(e));break;case\"dots\":u[s]||(u[s]=new i(e));break;case\"dashed\":u[s]||(u[s]=new c(e));break;case\"zigzag-line\":u[s]||(u[s]=new l(e));break;default:s=\"hachure\",u[s]||(u[s]=new o(e))}return u[s]}(e,P).fillPolygons(t,e)}function z(t){const e=Object.assign({},t);return e.randomizer=void 0,t.seed&&(e.seed=t.seed+1),e}function W(t){return t.randomizer||(t.randomizer=new p(t.seed||0)),t.randomizer.next()}function E(t,e,s,n=1){return s.roughness*n*(W(s)*(e-t)+t)}function G(t,e,s=1){return E(-t,t,e,s)}function $(t,e,s,n,o,a=!1){const h=a?o.disableMultiStrokeFill:o.disableMultiStroke,r=R(t,e,s,n,o,!0,!1);if(h)return r;const i=R(t,e,s,n,o,!0,!0);return r.concat(i)}function R(t,e,s,n,o,a,h){const r=Math.pow(t-s,2)+Math.pow(e-n,2),i=Math.sqrt(r);let c=1;c=i<200?1:i>500?.4:-.0016668*i+1.233334;let l=o.maxRandomnessOffset||0;l*l*100>r&&(l=i/10);const u=l/2,p=.2+.2*W(o);let f=o.bowing*o.maxRandomnessOffset*(n-e)/200,d=o.bowing*o.maxRandomnessOffset*(t-s)/200;f=G(f,o,c),d=G(d,o,c);const g=[],M=()=>G(u,o,c),k=()=>G(l,o,c),b=o.preserveVertices;return a&&(h?g.push({op:\"move\",data:[t+(b?0:M()),e+(b?0:M())]}):g.push({op:\"move\",data:[t+(b?0:G(l,o,c)),e+(b?0:G(l,o,c))]})),h?g.push({op:\"bcurveTo\",data:[f+t+(s-t)*p+M(),d+e+(n-e)*p+M(),f+t+2*(s-t)*p+M(),d+e+2*(n-e)*p+M(),s+(b?0:M()),n+(b?0:M())]}):g.push({op:\"bcurveTo\",data:[f+t+(s-t)*p+k(),d+e+(n-e)*p+k(),f+t+2*(s-t)*p+k(),d+e+2*(n-e)*p+k(),s+(b?0:k()),n+(b?0:k())]}),g}function j(t,e,s){if(!t.length)return[];const n=[];n.push([t[0][0]+G(e,s),t[0][1]+G(e,s)]),n.push([t[0][0]+G(e,s),t[0][1]+G(e,s)]);for(let o=1;o<t.length;o++)n.push([t[o][0]+G(e,s),t[o][1]+G(e,s)]),o===t.length-1&&n.push([t[o][0]+G(e,s),t[o][1]+G(e,s)]);return q(n,null,s)}function q(t,e,s){const n=t.length,o=[];if(n>3){const a=[],h=1-s.curveTightness;o.push({op:\"move\",data:[t[1][0],t[1][1]]});for(let e=1;e+2<n;e++){const s=t[e];a[0]=[s[0],s[1]],a[1]=[s[0]+(h*t[e+1][0]-h*t[e-1][0])/6,s[1]+(h*t[e+1][1]-h*t[e-1][1])/6],a[2]=[t[e+1][0]+(h*t[e][0]-h*t[e+2][0])/6,t[e+1][1]+(h*t[e][1]-h*t[e+2][1])/6],a[3]=[t[e+1][0],t[e+1][1]],o.push({op:\"bcurveTo\",data:[a[1][0],a[1][1],a[2][0],a[2][1],a[3][0],a[3][1]]})}if(e&&2===e.length){const t=s.maxRandomnessOffset;o.push({op:\"lineTo\",data:[e[0]+G(t,s),e[1]+G(t,s)]})}}else 3===n?(o.push({op:\"move\",data:[t[1][0],t[1][1]]}),o.push({op:\"bcurveTo\",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===n&&o.push(...R(t[0][0],t[0][1],t[1][0],t[1][1],s,!0,!0));return o}function F(t,e,s,n,o,a,h,r){const i=[],c=[];if(0===r.roughness){t/=4,c.push([e+n*Math.cos(-t),s+o*Math.sin(-t)]);for(let a=0;a<=2*Math.PI;a+=t){const t=[e+n*Math.cos(a),s+o*Math.sin(a)];i.push(t),c.push(t)}c.push([e+n*Math.cos(0),s+o*Math.sin(0)]),c.push([e+n*Math.cos(t),s+o*Math.sin(t)])}else{const l=G(.5,r)-Math.PI/2;c.push([G(a,r)+e+.9*n*Math.cos(l-t),G(a,r)+s+.9*o*Math.sin(l-t)]);const u=2*Math.PI+l-.01;for(let h=l;h<u;h+=t){const t=[G(a,r)+e+n*Math.cos(h),G(a,r)+s+o*Math.sin(h)];i.push(t),c.push(t)}c.push([G(a,r)+e+n*Math.cos(l+2*Math.PI+.5*h),G(a,r)+s+o*Math.sin(l+2*Math.PI+.5*h)]),c.push([G(a,r)+e+.98*n*Math.cos(l+h),G(a,r)+s+.98*o*Math.sin(l+h)]),c.push([G(a,r)+e+.9*n*Math.cos(l+.5*h),G(a,r)+s+.9*o*Math.sin(l+.5*h)])}return[c,i]}function V(t,e,s,n,o,a,h,r,i){const c=a+G(.1,i),l=[];l.push([G(r,i)+e+.9*n*Math.cos(c-t),G(r,i)+s+.9*o*Math.sin(c-t)]);for(let a=c;a<=h;a+=t)l.push([G(r,i)+e+n*Math.cos(a),G(r,i)+s+o*Math.sin(a)]);return l.push([e+n*Math.cos(h),s+o*Math.sin(h)]),l.push([e+n*Math.cos(h),s+o*Math.sin(h)]),q(l,null,i)}function Z(t,e,s,n,o,a,h,r){const i=[],c=[r.maxRandomnessOffset||1,(r.maxRandomnessOffset||1)+.3];let l=[0,0];const u=r.disableMultiStroke?1:2,p=r.preserveVertices;for(let f=0;f<u;f++)0===f?i.push({op:\"move\",data:[h[0],h[1]]}):i.push({op:\"move\",data:[h[0]+(p?0:G(c[0],r)),h[1]+(p?0:G(c[0],r))]}),l=p?[o,a]:[o+G(c[f],r),a+G(c[f],r)],i.push({op:\"bcurveTo\",data:[t+G(c[f],r),e+G(c[f],r),s+G(c[f],r),n+G(c[f],r),l[0],l[1]]});return i}function Q(t){return[...t]}function H(t,e=0){const s=t.length;if(s<3)throw new Error(\"A curve must have at least three points.\");const n=[];if(3===s)n.push(Q(t[0]),Q(t[1]),Q(t[2]),Q(t[2]));else{const s=[];s.push(t[0],t[0]);for(let e=1;e<t.length;e++)s.push(t[e]),e===t.length-1&&s.push(t[e]);const o=[],a=1-e;n.push(Q(s[0]));for(let t=1;t+2<s.length;t++){const e=s[t];o[0]=[e[0],e[1]],o[1]=[e[0]+(a*s[t+1][0]-a*s[t-1][0])/6,e[1]+(a*s[t+1][1]-a*s[t-1][1])/6],o[2]=[s[t+1][0]+(a*s[t][0]-a*s[t+2][0])/6,s[t+1][1]+(a*s[t][1]-a*s[t+2][1])/6],o[3]=[s[t+1][0],s[t+1][1]],n.push(o[1],o[2],o[3])}}return n}function N(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function B(t,e,s){const n=N(e,s);if(0===n)return N(t,e);let o=((t[0]-e[0])*(s[0]-e[0])+(t[1]-e[1])*(s[1]-e[1]))/n;return o=Math.max(0,Math.min(1,o)),N(t,J(e,s,o))}function J(t,e,s){return[t[0]+(e[0]-t[0])*s,t[1]+(e[1]-t[1])*s]}function K(t,e,s,n){const o=n||[];if(function(t,e){const s=t[e+0],n=t[e+1],o=t[e+2],a=t[e+3];let h=3*n[0]-2*s[0]-a[0];h*=h;let r=3*n[1]-2*s[1]-a[1];r*=r;let i=3*o[0]-2*a[0]-s[0];i*=i;let c=3*o[1]-2*a[1]-s[1];return c*=c,h<i&&(h=i),r<c&&(r=c),h+r}(t,e)<s){const s=t[e+0];if(o.length){(a=o[o.length-1],h=s,Math.sqrt(N(a,h)))>1&&o.push(s)}else o.push(s);o.push(t[e+3])}else{const n=.5,a=t[e+0],h=t[e+1],r=t[e+2],i=t[e+3],c=J(a,h,n),l=J(h,r,n),u=J(r,i,n),p=J(c,l,n),f=J(l,u,n),d=J(p,f,n);K([a,c,p,d],0,s,o),K([d,f,u,i],0,s,o)}var a,h;return o}function U(t,e){return X(t,0,t.length,e)}function X(t,e,s,n,o){const a=o||[],h=t[e],r=t[s-1];let i=0,c=1;for(let n=e+1;n<s-1;++n){const e=B(t[n],h,r);e>i&&(i=e,c=n)}return Math.sqrt(i)>n?(X(t,e,c+1,n,a),X(t,c,s,n,a)):(a.length||a.push(h),a.push(r)),a}function Y(t,e=.15,s){const n=[],o=(t.length-1)/3;for(let s=0;s<o;s++){K(t,3*s,e,n)}return s&&s>0?X(n,0,n.length,s):n}const tt=\"none\";class et{constructor(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:\"#000\",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:\"hachure\",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,disableMultiStroke:!1,disableMultiStrokeFill:!1,preserveVertices:!1,fillShapeRoughnessGain:.8},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options))}static newSeed(){return Math.floor(Math.random()*2**31)}_o(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions}_d(t,e,s){return{shape:t,sets:e||[],options:s||this.defaultOptions}}line(t,e,s,n,o){const a=this._o(o);return this._d(\"line\",[v(t,e,s,n,a)],a)}rectangle(t,e,s,n,o){const a=this._o(o),h=[],r=O(t,e,s,n,a);if(a.fill){const o=[[t,e],[t+s,e],[t+s,e+n],[t,e+n]];\"solid\"===a.fillStyle?h.push(I([o],a)):h.push(C([o],a))}return a.stroke!==tt&&h.push(r),this._d(\"rectangle\",h,a)}ellipse(t,e,s,n,o){const a=this._o(o),h=[],r=T(s,n,a),i=D(t,e,a,r);if(a.fill)if(\"solid\"===a.fillStyle){const s=D(t,e,a,r).opset;s.type=\"fillPath\",h.push(s)}else h.push(C([i.estimatedPoints],a));return a.stroke!==tt&&h.push(i.opset),this._d(\"ellipse\",h,a)}circle(t,e,s,n){const o=this.ellipse(t,e,s,s,n);return o.shape=\"circle\",o}linearPath(t,e){const s=this._o(e);return this._d(\"linearPath\",[S(t,!1,s)],s)}arc(t,e,s,n,o,a,h=!1,r){const i=this._o(r),c=[],l=A(t,e,s,n,o,a,h,!0,i);if(h&&i.fill)if(\"solid\"===i.fillStyle){const h=Object.assign({},i);h.disableMultiStroke=!0;const r=A(t,e,s,n,o,a,!0,!1,h);r.type=\"fillPath\",c.push(r)}else c.push(function(t,e,s,n,o,a,h){const r=t,i=e;let c=Math.abs(s/2),l=Math.abs(n/2);c+=G(.01*c,h),l+=G(.01*l,h);let u=o,p=a;for(;u<0;)u+=2*Math.PI,p+=2*Math.PI;p-u>2*Math.PI&&(u=0,p=2*Math.PI);const f=(p-u)/h.curveStepCount,d=[];for(let t=u;t<=p;t+=f)d.push([r+c*Math.cos(t),i+l*Math.sin(t)]);return d.push([r+c*Math.cos(p),i+l*Math.sin(p)]),d.push([r,i]),C([d],h)}(t,e,s,n,o,a,i));return i.stroke!==tt&&c.push(l),this._d(\"arc\",c,i)}curve(t,e){const s=this._o(e),n=[],o=L(t,s);if(s.fill&&s.fill!==tt)if(\"solid\"===s.fillStyle){const e=L(t,Object.assign(Object.assign({},s),{disableMultiStroke:!0,roughness:s.roughness?s.roughness+s.fillShapeRoughnessGain:0}));n.push({type:\"fillPath\",ops:this._mergedShape(e.ops)})}else{const e=[],o=t;if(o.length){const t=\"number\"==typeof o[0][0]?[o]:o;for(const n of t)n.length<3?e.push(...n):3===n.length?e.push(...Y(H([n[0],n[0],n[1],n[2]]),10,(1+s.roughness)/2)):e.push(...Y(H(n),10,(1+s.roughness)/2))}e.length&&n.push(C([e],s))}return s.stroke!==tt&&n.push(o),this._d(\"curve\",n,s)}polygon(t,e){const s=this._o(e),n=[],o=S(t,!0,s);return s.fill&&(\"solid\"===s.fillStyle?n.push(I([t],s)):n.push(C([t],s))),s.stroke!==tt&&n.push(o),this._d(\"polygon\",n,s)}path(t,e){const s=this._o(e),n=[];if(!t)return this._d(\"path\",n,s);t=(t||\"\").replace(/\\n/g,\" \").replace(/(-\\s)/g,\"-\").replace(\"/(ss)/g\",\" \");const o=s.fill&&\"transparent\"!==s.fill&&s.fill!==tt,a=s.stroke!==tt,h=!!(s.simplification&&s.simplification<1),r=function(t,e,s){const n=m(y(b(t))),o=[];let a=[],h=[0,0],r=[];const i=()=>{r.length>=4&&a.push(...Y(r,e)),r=[]},c=()=>{i(),a.length&&(o.push(a),a=[])};for(const{key:t,data:e}of n)switch(t){case\"M\":c(),h=[e[0],e[1]],a.push(h);break;case\"L\":i(),a.push([e[0],e[1]]);break;case\"C\":if(!r.length){const t=a.length?a[a.length-1]:h;r.push([t[0],t[1]])}r.push([e[0],e[1]]),r.push([e[2],e[3]]),r.push([e[4],e[5]]);break;case\"Z\":i(),a.push([h[0],h[1]])}if(c(),!s)return o;const l=[];for(const t of o){const e=U(t,s);e.length&&l.push(e)}return l}(t,1,h?4-4*(s.simplification||1):(1+s.roughness)/2),i=_(t,s);if(o)if(\"solid\"===s.fillStyle)if(1===r.length){const e=_(t,Object.assign(Object.assign({},s),{disableMultiStroke:!0,roughness:s.roughness?s.roughness+s.fillShapeRoughnessGain:0}));n.push({type:\"fillPath\",ops:this._mergedShape(e.ops)})}else n.push(I(r,s));else n.push(C(r,s));return a&&(h?r.forEach((t=>{n.push(S(t,!1,s))})):n.push(i)),this._d(\"path\",n,s)}opsToPath(t,e){let s=\"\";for(const n of t.ops){const t=\"number\"==typeof e&&e>=0?n.data.map((t=>+t.toFixed(e))):n.data;switch(n.op){case\"move\":s+=`M${t[0]} ${t[1]} `;break;case\"bcurveTo\":s+=`C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;break;case\"lineTo\":s+=`L${t[0]} ${t[1]} `}}return s.trim()}toPaths(t){const e=t.sets||[],s=t.options||this.defaultOptions,n=[];for(const t of e){let e=null;switch(t.type){case\"path\":e={d:this.opsToPath(t),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:tt};break;case\"fillPath\":e={d:this.opsToPath(t),stroke:tt,strokeWidth:0,fill:s.fill||tt};break;case\"fillSketch\":e=this.fillSketch(t,s)}e&&n.push(e)}return n}fillSketch(t,e){let s=e.fillWeight;return s<0&&(s=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||tt,strokeWidth:s,fill:tt}}_mergedShape(t){return t.filter(((t,e)=>0===e||\"move\"!==t.op))}}class st{constructor(t,e){this.canvas=t,this.ctx=this.canvas.getContext(\"2d\"),this.gen=new et(e)}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.ctx,o=t.options.fixedDecimalPlaceDigits;for(const a of e)switch(a.type){case\"path\":n.save(),n.strokeStyle=\"none\"===s.stroke?\"transparent\":s.stroke,n.lineWidth=s.strokeWidth,s.strokeLineDash&&n.setLineDash(s.strokeLineDash),s.strokeLineDashOffset&&(n.lineDashOffset=s.strokeLineDashOffset),this._drawToContext(n,a,o),n.restore();break;case\"fillPath\":{n.save(),n.fillStyle=s.fill||\"\";const e=\"curve\"===t.shape||\"polygon\"===t.shape||\"path\"===t.shape?\"evenodd\":\"nonzero\";this._drawToContext(n,a,o,e),n.restore();break}case\"fillSketch\":this.fillSketch(n,a,s)}}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2),t.save(),s.fillLineDash&&t.setLineDash(s.fillLineDash),s.fillLineDashOffset&&(t.lineDashOffset=s.fillLineDashOffset),t.strokeStyle=s.fill||\"\",t.lineWidth=n,this._drawToContext(t,e,s.fixedDecimalPlaceDigits),t.restore()}_drawToContext(t,e,s,n=\"nonzero\"){t.beginPath();for(const n of e.ops){const e=\"number\"==typeof s&&s>=0?n.data.map((t=>+t.toFixed(s))):n.data;switch(n.op){case\"move\":t.moveTo(e[0],e[1]);break;case\"bcurveTo\":t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5]);break;case\"lineTo\":t.lineTo(e[0],e[1])}}\"fillPath\"===e.type?t.fill(n):t.stroke()}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a),a}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a),a}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a),a}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o),o}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s),s}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s),s}arc(t,e,s,n,o,a,h=!1,r){const i=this.gen.arc(t,e,s,n,o,a,h,r);return this.draw(i),i}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s),s}path(t,e){const s=this.gen.path(t,e);return this.draw(s),s}}const nt=\"http://www.w3.org/2000/svg\";class ot{constructor(t,e){this.svg=t,this.gen=new et(e)}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.svg.ownerDocument||window.document,o=n.createElementNS(nt,\"g\"),a=t.options.fixedDecimalPlaceDigits;for(const h of e){let e=null;switch(h.type){case\"path\":e=n.createElementNS(nt,\"path\"),e.setAttribute(\"d\",this.opsToPath(h,a)),e.setAttribute(\"stroke\",s.stroke),e.setAttribute(\"stroke-width\",s.strokeWidth+\"\"),e.setAttribute(\"fill\",\"none\"),s.strokeLineDash&&e.setAttribute(\"stroke-dasharray\",s.strokeLineDash.join(\" \").trim()),s.strokeLineDashOffset&&e.setAttribute(\"stroke-dashoffset\",`${s.strokeLineDashOffset}`);break;case\"fillPath\":e=n.createElementNS(nt,\"path\"),e.setAttribute(\"d\",this.opsToPath(h,a)),e.setAttribute(\"stroke\",\"none\"),e.setAttribute(\"stroke-width\",\"0\"),e.setAttribute(\"fill\",s.fill||\"\"),\"curve\"!==t.shape&&\"polygon\"!==t.shape||e.setAttribute(\"fill-rule\",\"evenodd\");break;case\"fillSketch\":e=this.fillSketch(n,h,s)}e&&o.appendChild(e)}return o}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2);const o=t.createElementNS(nt,\"path\");return o.setAttribute(\"d\",this.opsToPath(e,s.fixedDecimalPlaceDigits)),o.setAttribute(\"stroke\",s.fill||\"\"),o.setAttribute(\"stroke-width\",n+\"\"),o.setAttribute(\"fill\",\"none\"),s.fillLineDash&&o.setAttribute(\"stroke-dasharray\",s.fillLineDash.join(\" \").trim()),s.fillLineDashOffset&&o.setAttribute(\"stroke-dashoffset\",`${s.fillLineDashOffset}`),o}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}opsToPath(t,e){return this.gen.opsToPath(t,e)}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a)}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a)}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a)}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o)}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s)}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s)}arc(t,e,s,n,o,a,h=!1,r){const i=this.gen.arc(t,e,s,n,o,a,h,r);return this.draw(i)}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s)}path(t,e){const s=this.gen.path(t,e);return this.draw(s)}}var at={canvas:(t,e)=>new st(t,e),svg:(t,e)=>new ot(t,e),generator:t=>new et(t),newSeed:()=>et.newSeed()};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9idW5kbGVkL3JvdWdoLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsa0JBQWtCLGdCQUFnQix5REFBeUQsa0JBQWtCLGFBQWEsZ0RBQWdELGdCQUFnQixnQ0FBZ0Msc0JBQXNCLG1GQUFtRiwrQkFBK0Isd0JBQXdCLFdBQVcsa0JBQWtCLGVBQWUsdUVBQXVFLFdBQVcsaUJBQWlCLFdBQVcsNkJBQTZCLGFBQWEsS0FBSyxzQkFBc0IsZ0JBQWdCLDRCQUE0QixRQUFRLG9GQUFvRixHQUFHLHVKQUF1Six5QkFBeUIsS0FBSyxtQkFBbUIsRUFBRSxhQUFhLFNBQVMsWUFBWSwyQkFBMkIsUUFBUSw2QkFBNkIsUUFBUSxXQUFXLEVBQUUsR0FBRyxxS0FBcUssV0FBVyxNQUFNLFlBQVkscUJBQXFCLDhCQUE4QixrREFBa0Qsb0JBQW9CLGtDQUFrQyxPQUFPLFNBQVMsUUFBUSxNQUFNLDJCQUEyQixpQkFBaUIsV0FBVyxzQ0FBc0MsU0FBUyxTQUFTLGdCQUFnQixNQUFNLDBCQUEwQixtQkFBbUIsc0RBQXNELFFBQVEsc0hBQXNILFFBQVEsZUFBZSxjQUFjLGtCQUFrQiwrQkFBK0IsbUJBQW1CLGVBQWUsT0FBTyw2Q0FBNkMsaUJBQWlCLFdBQVcseUZBQXlGLFVBQVUsY0FBYyxvQkFBb0IsOERBQThELGtCQUFrQixrQkFBa0IsbUJBQW1CLDBDQUEwQyw0QkFBNEIsSUFBSSxhQUFhLDJFQUEyRSx1RkFBdUYsT0FBTyw4Q0FBOEMsa0JBQWtCLGtCQUFrQixrREFBa0QsSUFBSSwrQkFBK0IsNEJBQTRCLG9DQUFvQyxRQUFRLGVBQWUsY0FBYyxrQkFBa0IsOEJBQThCLElBQUksZUFBZSxHQUFHLDZCQUE2QixpQkFBaUIsV0FBVyxtQkFBbUIsMENBQTBDLG1CQUFtQix5QkFBeUIsWUFBWSxrQkFBa0Isa0dBQWtHLFlBQVksSUFBSSxLQUFLLGlHQUFpRyxrQkFBa0IsT0FBTywwQkFBMEIsUUFBUSxlQUFlLGNBQWMsa0JBQWtC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cUJBQXFCLFFBQVEsa0dBQXdIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaWRlYWZsb3cvLi9ub2RlX21vZHVsZXMvcm91Z2hqcy9idW5kbGVkL3JvdWdoLmVzbS5qcz9hMTdhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHQodCxlLHMpe2lmKHQmJnQubGVuZ3RoKXtjb25zdFtuLG9dPWUsYT1NYXRoLlBJLzE4MCpzLGg9TWF0aC5jb3MoYSkscj1NYXRoLnNpbihhKTtmb3IoY29uc3QgZSBvZiB0KXtjb25zdFt0LHNdPWU7ZVswXT0odC1uKSpoLShzLW8pKnIrbixlWzFdPSh0LW4pKnIrKHMtbykqaCtvfX19ZnVuY3Rpb24gZSh0LGUpe3JldHVybiB0WzBdPT09ZVswXSYmdFsxXT09PWVbMV19ZnVuY3Rpb24gcyhzLG4sbyxhPTEpe2NvbnN0IGg9byxyPU1hdGgubWF4KG4sLjEpLGk9c1swXSYmc1swXVswXSYmXCJudW1iZXJcIj09dHlwZW9mIHNbMF1bMF0/W3NdOnMsYz1bMCwwXTtpZihoKWZvcihjb25zdCBlIG9mIGkpdChlLGMsaCk7Y29uc3QgbD1mdW5jdGlvbih0LHMsbil7Y29uc3Qgbz1bXTtmb3IoY29uc3QgcyBvZiB0KXtjb25zdCB0PVsuLi5zXTtlKHRbMF0sdFt0Lmxlbmd0aC0xXSl8fHQucHVzaChbdFswXVswXSx0WzBdWzFdXSksdC5sZW5ndGg+MiYmby5wdXNoKHQpfWNvbnN0IGE9W107cz1NYXRoLm1heChzLC4xKTtjb25zdCBoPVtdO2Zvcihjb25zdCB0IG9mIG8pZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7Y29uc3Qgcz10W2VdLG49dFtlKzFdO2lmKHNbMV0hPT1uWzFdKXtjb25zdCB0PU1hdGgubWluKHNbMV0sblsxXSk7aC5wdXNoKHt5bWluOnQseW1heDpNYXRoLm1heChzWzFdLG5bMV0pLHg6dD09PXNbMV0/c1swXTpuWzBdLGlzbG9wZTooblswXS1zWzBdKS8oblsxXS1zWzFdKX0pfX1pZihoLnNvcnQoKCh0LGUpPT50LnltaW48ZS55bWluPy0xOnQueW1pbj5lLnltaW4/MTp0Lng8ZS54Py0xOnQueD5lLng/MTp0LnltYXg9PT1lLnltYXg/MDoodC55bWF4LWUueW1heCkvTWF0aC5hYnModC55bWF4LWUueW1heCkpKSwhaC5sZW5ndGgpcmV0dXJuIGE7bGV0IHI9W10saT1oWzBdLnltaW4sYz0wO2Zvcig7ci5sZW5ndGh8fGgubGVuZ3RoOyl7aWYoaC5sZW5ndGgpe2xldCB0PS0xO2ZvcihsZXQgZT0wO2U8aC5sZW5ndGgmJiEoaFtlXS55bWluPmkpO2UrKyl0PWU7aC5zcGxpY2UoMCx0KzEpLmZvckVhY2goKHQ9PntyLnB1c2goe3M6aSxlZGdlOnR9KX0pKX1pZihyPXIuZmlsdGVyKCh0PT4hKHQuZWRnZS55bWF4PD1pKSkpLHIuc29ydCgoKHQsZSk9PnQuZWRnZS54PT09ZS5lZGdlLng/MDoodC5lZGdlLngtZS5lZGdlLngpL01hdGguYWJzKHQuZWRnZS54LWUuZWRnZS54KSkpLCgxIT09bnx8YyVzPT0wKSYmci5sZW5ndGg+MSlmb3IobGV0IHQ9MDt0PHIubGVuZ3RoO3QrPTIpe2NvbnN0IGU9dCsxO2lmKGU+PXIubGVuZ3RoKWJyZWFrO2NvbnN0IHM9clt0XS5lZGdlLG49cltlXS5lZGdlO2EucHVzaChbW01hdGgucm91bmQocy54KSxpXSxbTWF0aC5yb3VuZChuLngpLGldXSl9aSs9bixyLmZvckVhY2goKHQ9Pnt0LmVkZ2UueD10LmVkZ2UueCtuKnQuZWRnZS5pc2xvcGV9KSksYysrfXJldHVybiBhfShpLHIsYSk7aWYoaCl7Zm9yKGNvbnN0IGUgb2YgaSl0KGUsYywtaCk7IWZ1bmN0aW9uKGUscyxuKXtjb25zdCBvPVtdO2UuZm9yRWFjaCgodD0+by5wdXNoKC4uLnQpKSksdChvLHMsbil9KGwsYywtaCl9cmV0dXJuIGx9ZnVuY3Rpb24gbih0LGUpe3ZhciBuO2NvbnN0IG89ZS5oYWNodXJlQW5nbGUrOTA7bGV0IGE9ZS5oYWNodXJlR2FwO2E8MCYmKGE9NCplLnN0cm9rZVdpZHRoKSxhPU1hdGgucm91bmQoTWF0aC5tYXgoYSwuMSkpO2xldCBoPTE7cmV0dXJuIGUucm91Z2huZXNzPj0xJiYoKG51bGw9PT0obj1lLnJhbmRvbWl6ZXIpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLm5leHQoKSl8fE1hdGgucmFuZG9tKCkpPi43JiYoaD1hKSxzKHQsYSxvLGh8fDEpfWNsYXNzIG97Y29uc3RydWN0b3IodCl7dGhpcy5oZWxwZXI9dH1maWxsUG9seWdvbnModCxlKXtyZXR1cm4gdGhpcy5fZmlsbFBvbHlnb25zKHQsZSl9X2ZpbGxQb2x5Z29ucyh0LGUpe2NvbnN0IHM9bih0LGUpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLnJlbmRlckxpbmVzKHMsZSl9fXJlbmRlckxpbmVzKHQsZSl7Y29uc3Qgcz1bXTtmb3IoY29uc3QgbiBvZiB0KXMucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKG5bMF1bMF0sblswXVsxXSxuWzFdWzBdLG5bMV1bMV0sZSkpO3JldHVybiBzfX1mdW5jdGlvbiBhKHQpe2NvbnN0IGU9dFswXSxzPXRbMV07cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlWzBdLXNbMF0sMikrTWF0aC5wb3coZVsxXS1zWzFdLDIpKX1jbGFzcyBoIGV4dGVuZHMgb3tmaWxsUG9seWdvbnModCxlKXtsZXQgcz1lLmhhY2h1cmVHYXA7czwwJiYocz00KmUuc3Ryb2tlV2lkdGgpLHM9TWF0aC5tYXgocywuMSk7Y29uc3Qgbz1uKHQsT2JqZWN0LmFzc2lnbih7fSxlLHtoYWNodXJlR2FwOnN9KSksaD1NYXRoLlBJLzE4MCplLmhhY2h1cmVBbmdsZSxyPVtdLGk9LjUqcypNYXRoLmNvcyhoKSxjPS41KnMqTWF0aC5zaW4oaCk7Zm9yKGNvbnN0W3QsZV1vZiBvKWEoW3QsZV0pJiZyLnB1c2goW1t0WzBdLWksdFsxXStjXSxbLi4uZV1dLFtbdFswXStpLHRbMV0tY10sWy4uLmVdXSk7cmV0dXJue3R5cGU6XCJmaWxsU2tldGNoXCIsb3BzOnRoaXMucmVuZGVyTGluZXMocixlKX19fWNsYXNzIHIgZXh0ZW5kcyBve2ZpbGxQb2x5Z29ucyh0LGUpe2NvbnN0IHM9dGhpcy5fZmlsbFBvbHlnb25zKHQsZSksbj1PYmplY3QuYXNzaWduKHt9LGUse2hhY2h1cmVBbmdsZTplLmhhY2h1cmVBbmdsZSs5MH0pLG89dGhpcy5fZmlsbFBvbHlnb25zKHQsbik7cmV0dXJuIHMub3BzPXMub3BzLmNvbmNhdChvLm9wcyksc319Y2xhc3MgaXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhlbHBlcj10fWZpbGxQb2x5Z29ucyh0LGUpe2NvbnN0IHM9bih0LGU9T2JqZWN0LmFzc2lnbih7fSxlLHtoYWNodXJlQW5nbGU6MH0pKTtyZXR1cm4gdGhpcy5kb3RzT25MaW5lcyhzLGUpfWRvdHNPbkxpbmVzKHQsZSl7Y29uc3Qgcz1bXTtsZXQgbj1lLmhhY2h1cmVHYXA7bjwwJiYobj00KmUuc3Ryb2tlV2lkdGgpLG49TWF0aC5tYXgobiwuMSk7bGV0IG89ZS5maWxsV2VpZ2h0O288MCYmKG89ZS5zdHJva2VXaWR0aC8yKTtjb25zdCBoPW4vNDtmb3IoY29uc3QgciBvZiB0KXtjb25zdCB0PWEociksaT10L24sYz1NYXRoLmNlaWwoaSktMSxsPXQtYypuLHU9KHJbMF1bMF0rclsxXVswXSkvMi1uLzQscD1NYXRoLm1pbihyWzBdWzFdLHJbMV1bMV0pO2ZvcihsZXQgdD0wO3Q8Yzt0Kyspe2NvbnN0IGE9cCtsK3QqbixyPXUtaCsyKk1hdGgucmFuZG9tKCkqaCxpPWEtaCsyKk1hdGgucmFuZG9tKCkqaCxjPXRoaXMuaGVscGVyLmVsbGlwc2UocixpLG8sbyxlKTtzLnB1c2goLi4uYy5vcHMpfX1yZXR1cm57dHlwZTpcImZpbGxTa2V0Y2hcIixvcHM6c319fWNsYXNzIGN7Y29uc3RydWN0b3IodCl7dGhpcy5oZWxwZXI9dH1maWxsUG9seWdvbnModCxlKXtjb25zdCBzPW4odCxlKTtyZXR1cm57dHlwZTpcImZpbGxTa2V0Y2hcIixvcHM6dGhpcy5kYXNoZWRMaW5lKHMsZSl9fWRhc2hlZExpbmUodCxlKXtjb25zdCBzPWUuZGFzaE9mZnNldDwwP2UuaGFjaHVyZUdhcDwwPzQqZS5zdHJva2VXaWR0aDplLmhhY2h1cmVHYXA6ZS5kYXNoT2Zmc2V0LG49ZS5kYXNoR2FwPDA/ZS5oYWNodXJlR2FwPDA/NCplLnN0cm9rZVdpZHRoOmUuaGFjaHVyZUdhcDplLmRhc2hHYXAsbz1bXTtyZXR1cm4gdC5mb3JFYWNoKCh0PT57Y29uc3QgaD1hKHQpLHI9TWF0aC5mbG9vcihoLyhzK24pKSxpPShoK24tcioocytuKSkvMjtsZXQgYz10WzBdLGw9dFsxXTtjWzBdPmxbMF0mJihjPXRbMV0sbD10WzBdKTtjb25zdCB1PU1hdGguYXRhbigobFsxXS1jWzFdKS8obFswXS1jWzBdKSk7Zm9yKGxldCB0PTA7dDxyO3QrKyl7Y29uc3QgYT10KihzK24pLGg9YStzLHI9W2NbMF0rYSpNYXRoLmNvcyh1KStpKk1hdGguY29zKHUpLGNbMV0rYSpNYXRoLnNpbih1KStpKk1hdGguc2luKHUpXSxsPVtjWzBdK2gqTWF0aC5jb3ModSkraSpNYXRoLmNvcyh1KSxjWzFdK2gqTWF0aC5zaW4odSkraSpNYXRoLnNpbih1KV07by5wdXNoKC4uLnRoaXMuaGVscGVyLmRvdWJsZUxpbmVPcHMoclswXSxyWzFdLGxbMF0sbFsxXSxlKSl9fSkpLG99fWNsYXNzIGx7Y29uc3RydWN0b3IodCl7dGhpcy5oZWxwZXI9dH1maWxsUG9seWdvbnModCxlKXtjb25zdCBzPWUuaGFjaHVyZUdhcDwwPzQqZS5zdHJva2VXaWR0aDplLmhhY2h1cmVHYXAsbz1lLnppZ3phZ09mZnNldDwwP3M6ZS56aWd6YWdPZmZzZXQsYT1uKHQsZT1PYmplY3QuYXNzaWduKHt9LGUse2hhY2h1cmVHYXA6cytvfSkpO3JldHVybnt0eXBlOlwiZmlsbFNrZXRjaFwiLG9wczp0aGlzLnppZ3phZ0xpbmVzKGEsbyxlKX19emlnemFnTGluZXModCxlLHMpe2NvbnN0IG49W107cmV0dXJuIHQuZm9yRWFjaCgodD0+e2NvbnN0IG89YSh0KSxoPU1hdGgucm91bmQoby8oMiplKSk7bGV0IHI9dFswXSxpPXRbMV07clswXT5pWzBdJiYocj10WzFdLGk9dFswXSk7Y29uc3QgYz1NYXRoLmF0YW4oKGlbMV0tclsxXSkvKGlbMF0tclswXSkpO2ZvcihsZXQgdD0wO3Q8aDt0Kyspe2NvbnN0IG89Mip0KmUsYT0yKih0KzEpKmUsaD1NYXRoLnNxcnQoMipNYXRoLnBvdyhlLDIpKSxpPVtyWzBdK28qTWF0aC5jb3MoYyksclsxXStvKk1hdGguc2luKGMpXSxsPVtyWzBdK2EqTWF0aC5jb3MoYyksclsxXSthKk1hdGguc2luKGMpXSx1PVtpWzBdK2gqTWF0aC5jb3MoYytNYXRoLlBJLzQpLGlbMV0raCpNYXRoLnNpbihjK01hdGguUEkvNCldO24ucHVzaCguLi50aGlzLmhlbHBlci5kb3VibGVMaW5lT3BzKGlbMF0saVsxXSx1WzBdLHVbMV0scyksLi4udGhpcy5oZWxwZXIuZG91YmxlTGluZU9wcyh1WzBdLHVbMV0sbFswXSxsWzFdLHMpKX19KSksbn19Y29uc3QgdT17fTtjbGFzcyBwe2NvbnN0cnVjdG9yKHQpe3RoaXMuc2VlZD10fW5leHQoKXtyZXR1cm4gdGhpcy5zZWVkPygyKiozMS0xJih0aGlzLnNlZWQ9TWF0aC5pbXVsKDQ4MjcxLHRoaXMuc2VlZCkpKS8yKiozMTpNYXRoLnJhbmRvbSgpfX1jb25zdCBmPTAsZD0xLGc9MixNPXtBOjcsYTo3LEM6NixjOjYsSDoxLGg6MSxMOjIsbDoyLE06MixtOjIsUTo0LHE6NCxTOjQsczo0LFQ6Mix0OjIsVjoxLHY6MSxaOjAsejowfTtmdW5jdGlvbiBrKHQsZSl7cmV0dXJuIHQudHlwZT09PWV9ZnVuY3Rpb24gYih0KXtjb25zdCBlPVtdLHM9ZnVuY3Rpb24odCl7Y29uc3QgZT1uZXcgQXJyYXk7Zm9yKDtcIlwiIT09dDspaWYodC5tYXRjaCgvXihbIFxcdFxcclxcbixdKykvKSl0PXQuc3Vic3RyKFJlZ0V4cC4kMS5sZW5ndGgpO2Vsc2UgaWYodC5tYXRjaCgvXihbYUFjQ2hIbExtTXFRc1N0VHZWelpdKS8pKWVbZS5sZW5ndGhdPXt0eXBlOmYsdGV4dDpSZWdFeHAuJDF9LHQ9dC5zdWJzdHIoUmVnRXhwLiQxLmxlbmd0aCk7ZWxzZXtpZighdC5tYXRjaCgvXigoWy0rXT9bMC05XSsoXFwuWzAtOV0qKT98Wy0rXT9cXC5bMC05XSspKFtlRV1bLStdP1swLTldKyk/KS8pKXJldHVybltdO2VbZS5sZW5ndGhdPXt0eXBlOmQsdGV4dDpgJHtwYXJzZUZsb2F0KFJlZ0V4cC4kMSl9YH0sdD10LnN1YnN0cihSZWdFeHAuJDEubGVuZ3RoKX1yZXR1cm4gZVtlLmxlbmd0aF09e3R5cGU6Zyx0ZXh0OlwiXCJ9LGV9KHQpO2xldCBuPVwiQk9EXCIsbz0wLGE9c1tvXTtmb3IoOyFrKGEsZyk7KXtsZXQgaD0wO2NvbnN0IHI9W107aWYoXCJCT0RcIj09PW4pe2lmKFwiTVwiIT09YS50ZXh0JiZcIm1cIiE9PWEudGV4dClyZXR1cm4gYihcIk0wLDBcIit0KTtvKyssaD1NW2EudGV4dF0sbj1hLnRleHR9ZWxzZSBrKGEsZCk/aD1NW25dOihvKyssaD1NW2EudGV4dF0sbj1hLnRleHQpO2lmKCEobytoPHMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGRhdGEgZW5kZWQgc2hvcnRcIik7Zm9yKGxldCB0PW87dDxvK2g7dCsrKXtjb25zdCBlPXNbdF07aWYoIWsoZSxkKSl0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbSBub3QgYSBudW1iZXI6IFwiK24rXCIsXCIrZS50ZXh0KTtyW3IubGVuZ3RoXT0rZS50ZXh0fWlmKFwibnVtYmVyXCIhPXR5cGVvZiBNW25dKXRocm93IG5ldyBFcnJvcihcIkJhZCBzZWdtZW50OiBcIituKTt7Y29uc3QgdD17a2V5Om4sZGF0YTpyfTtlLnB1c2godCksbys9aCxhPXNbb10sXCJNXCI9PT1uJiYobj1cIkxcIiksXCJtXCI9PT1uJiYobj1cImxcIil9fXJldHVybiBlfWZ1bmN0aW9uIHkodCl7bGV0IGU9MCxzPTAsbj0wLG89MDtjb25zdCBhPVtdO2Zvcihjb25zdHtrZXk6aCxkYXRhOnJ9b2YgdClzd2l0Y2goaCl7Y2FzZVwiTVwiOmEucHVzaCh7a2V5OlwiTVwiLGRhdGE6Wy4uLnJdfSksW2Usc109cixbbixvXT1yO2JyZWFrO2Nhc2VcIm1cIjplKz1yWzBdLHMrPXJbMV0sYS5wdXNoKHtrZXk6XCJNXCIsZGF0YTpbZSxzXX0pLG49ZSxvPXM7YnJlYWs7Y2FzZVwiTFwiOmEucHVzaCh7a2V5OlwiTFwiLGRhdGE6Wy4uLnJdfSksW2Usc109cjticmVhaztjYXNlXCJsXCI6ZSs9clswXSxzKz1yWzFdLGEucHVzaCh7a2V5OlwiTFwiLGRhdGE6W2Usc119KTticmVhaztjYXNlXCJDXCI6YS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbLi4ucl19KSxlPXJbNF0scz1yWzVdO2JyZWFrO2Nhc2VcImNcIjp7Y29uc3QgdD1yLm1hcCgoKHQsbik9Pm4lMj90K3M6dCtlKSk7YS5wdXNoKHtrZXk6XCJDXCIsZGF0YTp0fSksZT10WzRdLHM9dFs1XTticmVha31jYXNlXCJRXCI6YS5wdXNoKHtrZXk6XCJRXCIsZGF0YTpbLi4ucl19KSxlPXJbMl0scz1yWzNdO2JyZWFrO2Nhc2VcInFcIjp7Y29uc3QgdD1yLm1hcCgoKHQsbik9Pm4lMj90K3M6dCtlKSk7YS5wdXNoKHtrZXk6XCJRXCIsZGF0YTp0fSksZT10WzJdLHM9dFszXTticmVha31jYXNlXCJBXCI6YS5wdXNoKHtrZXk6XCJBXCIsZGF0YTpbLi4ucl19KSxlPXJbNV0scz1yWzZdO2JyZWFrO2Nhc2VcImFcIjplKz1yWzVdLHMrPXJbNl0sYS5wdXNoKHtrZXk6XCJBXCIsZGF0YTpbclswXSxyWzFdLHJbMl0sclszXSxyWzRdLGUsc119KTticmVhaztjYXNlXCJIXCI6YS5wdXNoKHtrZXk6XCJIXCIsZGF0YTpbLi4ucl19KSxlPXJbMF07YnJlYWs7Y2FzZVwiaFwiOmUrPXJbMF0sYS5wdXNoKHtrZXk6XCJIXCIsZGF0YTpbZV19KTticmVhaztjYXNlXCJWXCI6YS5wdXNoKHtrZXk6XCJWXCIsZGF0YTpbLi4ucl19KSxzPXJbMF07YnJlYWs7Y2FzZVwidlwiOnMrPXJbMF0sYS5wdXNoKHtrZXk6XCJWXCIsZGF0YTpbc119KTticmVhaztjYXNlXCJTXCI6YS5wdXNoKHtrZXk6XCJTXCIsZGF0YTpbLi4ucl19KSxlPXJbMl0scz1yWzNdO2JyZWFrO2Nhc2VcInNcIjp7Y29uc3QgdD1yLm1hcCgoKHQsbik9Pm4lMj90K3M6dCtlKSk7YS5wdXNoKHtrZXk6XCJTXCIsZGF0YTp0fSksZT10WzJdLHM9dFszXTticmVha31jYXNlXCJUXCI6YS5wdXNoKHtrZXk6XCJUXCIsZGF0YTpbLi4ucl19KSxlPXJbMF0scz1yWzFdO2JyZWFrO2Nhc2VcInRcIjplKz1yWzBdLHMrPXJbMV0sYS5wdXNoKHtrZXk6XCJUXCIsZGF0YTpbZSxzXX0pO2JyZWFrO2Nhc2VcIlpcIjpjYXNlXCJ6XCI6YS5wdXNoKHtrZXk6XCJaXCIsZGF0YTpbXX0pLGU9bixzPW99cmV0dXJuIGF9ZnVuY3Rpb24gbSh0KXtjb25zdCBlPVtdO2xldCBzPVwiXCIsbj0wLG89MCxhPTAsaD0wLHI9MCxpPTA7Zm9yKGNvbnN0e2tleTpjLGRhdGE6bH1vZiB0KXtzd2l0Y2goYyl7Y2FzZVwiTVwiOmUucHVzaCh7a2V5OlwiTVwiLGRhdGE6Wy4uLmxdfSksW24sb109bCxbYSxoXT1sO2JyZWFrO2Nhc2VcIkNcIjplLnB1c2goe2tleTpcIkNcIixkYXRhOlsuLi5sXX0pLG49bFs0XSxvPWxbNV0scj1sWzJdLGk9bFszXTticmVhaztjYXNlXCJMXCI6ZS5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbLi4ubF19KSxbbixvXT1sO2JyZWFrO2Nhc2VcIkhcIjpuPWxbMF0sZS5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbbixvXX0pO2JyZWFrO2Nhc2VcIlZcIjpvPWxbMF0sZS5wdXNoKHtrZXk6XCJMXCIsZGF0YTpbbixvXX0pO2JyZWFrO2Nhc2VcIlNcIjp7bGV0IHQ9MCxhPTA7XCJDXCI9PT1zfHxcIlNcIj09PXM/KHQ9bisobi1yKSxhPW8rKG8taSkpOih0PW4sYT1vKSxlLnB1c2goe2tleTpcIkNcIixkYXRhOlt0LGEsLi4ubF19KSxyPWxbMF0saT1sWzFdLG49bFsyXSxvPWxbM107YnJlYWt9Y2FzZVwiVFwiOntjb25zdFt0LGFdPWw7bGV0IGg9MCxjPTA7XCJRXCI9PT1zfHxcIlRcIj09PXM/KGg9bisobi1yKSxjPW8rKG8taSkpOihoPW4sYz1vKTtjb25zdCB1PW4rMiooaC1uKS8zLHA9bysyKihjLW8pLzMsZj10KzIqKGgtdCkvMyxkPWErMiooYy1hKS8zO2UucHVzaCh7a2V5OlwiQ1wiLGRhdGE6W3UscCxmLGQsdCxhXX0pLHI9aCxpPWMsbj10LG89YTticmVha31jYXNlXCJRXCI6e2NvbnN0W3QscyxhLGhdPWwsYz1uKzIqKHQtbikvMyx1PW8rMioocy1vKS8zLHA9YSsyKih0LWEpLzMsZj1oKzIqKHMtaCkvMztlLnB1c2goe2tleTpcIkNcIixkYXRhOltjLHUscCxmLGEsaF19KSxyPXQsaT1zLG49YSxvPWg7YnJlYWt9Y2FzZVwiQVwiOntjb25zdCB0PU1hdGguYWJzKGxbMF0pLHM9TWF0aC5hYnMobFsxXSksYT1sWzJdLGg9bFszXSxyPWxbNF0saT1sWzVdLGM9bFs2XTtpZigwPT09dHx8MD09PXMpZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTpbbixvLGksYyxpLGNdfSksbj1pLG89YztlbHNlIGlmKG4hPT1pfHxvIT09Yyl7eChuLG8saSxjLHQscyxhLGgscikuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZS5wdXNoKHtrZXk6XCJDXCIsZGF0YTp0fSl9KSksbj1pLG89Y31icmVha31jYXNlXCJaXCI6ZS5wdXNoKHtrZXk6XCJaXCIsZGF0YTpbXX0pLG49YSxvPWh9cz1jfXJldHVybiBlfWZ1bmN0aW9uIHcodCxlLHMpe3JldHVyblt0Kk1hdGguY29zKHMpLWUqTWF0aC5zaW4ocyksdCpNYXRoLnNpbihzKStlKk1hdGguY29zKHMpXX1mdW5jdGlvbiB4KHQsZSxzLG4sbyxhLGgscixpLGMpe2NvbnN0IGw9KHU9aCxNYXRoLlBJKnUvMTgwKTt2YXIgdTtsZXQgcD1bXSxmPTAsZD0wLGc9MCxNPTA7aWYoYylbZixkLGcsTV09YztlbHNle1t0LGVdPXcodCxlLC1sKSxbcyxuXT13KHMsbiwtbCk7Y29uc3QgaD0odC1zKS8yLGM9KGUtbikvMjtsZXQgdT1oKmgvKG8qbykrYypjLyhhKmEpO3U+MSYmKHU9TWF0aC5zcXJ0KHUpLG8qPXUsYSo9dSk7Y29uc3QgcD1vKm8saz1hKmEsYj1wKmstcCpjKmMtaypoKmgseT1wKmMqYytrKmgqaCxtPShyPT09aT8tMToxKSpNYXRoLnNxcnQoTWF0aC5hYnMoYi95KSk7Zz1tKm8qYy9hKyh0K3MpLzIsTT1tKi1hKmgvbysoZStuKS8yLGY9TWF0aC5hc2luKHBhcnNlRmxvYXQoKChlLU0pL2EpLnRvRml4ZWQoOSkpKSxkPU1hdGguYXNpbihwYXJzZUZsb2F0KCgobi1NKS9hKS50b0ZpeGVkKDkpKSksdDxnJiYoZj1NYXRoLlBJLWYpLHM8ZyYmKGQ9TWF0aC5QSS1kKSxmPDAmJihmPTIqTWF0aC5QSStmKSxkPDAmJihkPTIqTWF0aC5QSStkKSxpJiZmPmQmJihmLT0yKk1hdGguUEkpLCFpJiZkPmYmJihkLT0yKk1hdGguUEkpfWxldCBrPWQtZjtpZihNYXRoLmFicyhrKT4xMjAqTWF0aC5QSS8xODApe2NvbnN0IHQ9ZCxlPXMscj1uO2Q9aSYmZD5mP2YrMTIwKk1hdGguUEkvMTgwKjE6ZisxMjAqTWF0aC5QSS8xODAqLTEscD14KHM9ZytvKk1hdGguY29zKGQpLG49TSthKk1hdGguc2luKGQpLGUscixvLGEsaCwwLGksW2QsdCxnLE1dKX1rPWQtZjtjb25zdCBiPU1hdGguY29zKGYpLHk9TWF0aC5zaW4oZiksbT1NYXRoLmNvcyhkKSxQPU1hdGguc2luKGQpLHY9TWF0aC50YW4oay80KSxTPTQvMypvKnYsTz00LzMqYSp2LEw9W3QsZV0sVD1bdCtTKnksZS1PKmJdLEQ9W3MrUypQLG4tTyptXSxBPVtzLG5dO2lmKFRbMF09MipMWzBdLVRbMF0sVFsxXT0yKkxbMV0tVFsxXSxjKXJldHVybltULEQsQV0uY29uY2F0KHApO3twPVtULEQsQV0uY29uY2F0KHApO2NvbnN0IHQ9W107Zm9yKGxldCBlPTA7ZTxwLmxlbmd0aDtlKz0zKXtjb25zdCBzPXcocFtlXVswXSxwW2VdWzFdLGwpLG49dyhwW2UrMV1bMF0scFtlKzFdWzFdLGwpLG89dyhwW2UrMl1bMF0scFtlKzJdWzFdLGwpO3QucHVzaChbc1swXSxzWzFdLG5bMF0sblsxXSxvWzBdLG9bMV1dKX1yZXR1cm4gdH19Y29uc3QgUD17cmFuZE9mZnNldDpmdW5jdGlvbih0LGUpe3JldHVybiBHKHQsZSl9LHJhbmRPZmZzZXRXaXRoUmFuZ2U6ZnVuY3Rpb24odCxlLHMpe3JldHVybiBFKHQsZSxzKX0sZWxsaXBzZTpmdW5jdGlvbih0LGUscyxuLG8pe2NvbnN0IGE9VChzLG4sbyk7cmV0dXJuIEQodCxlLG8sYSkub3BzZXR9LGRvdWJsZUxpbmVPcHM6ZnVuY3Rpb24odCxlLHMsbixvKXtyZXR1cm4gJCh0LGUscyxuLG8sITApfX07ZnVuY3Rpb24gdih0LGUscyxuLG8pe3JldHVybnt0eXBlOlwicGF0aFwiLG9wczokKHQsZSxzLG4sbyl9fWZ1bmN0aW9uIFModCxlLHMpe2NvbnN0IG49KHR8fFtdKS5sZW5ndGg7aWYobj4yKXtjb25zdCBvPVtdO2ZvcihsZXQgZT0wO2U8bi0xO2UrKylvLnB1c2goLi4uJCh0W2VdWzBdLHRbZV1bMV0sdFtlKzFdWzBdLHRbZSsxXVsxXSxzKSk7cmV0dXJuIGUmJm8ucHVzaCguLi4kKHRbbi0xXVswXSx0W24tMV1bMV0sdFswXVswXSx0WzBdWzFdLHMpKSx7dHlwZTpcInBhdGhcIixvcHM6b319cmV0dXJuIDI9PT1uP3YodFswXVswXSx0WzBdWzFdLHRbMV1bMF0sdFsxXVsxXSxzKTp7dHlwZTpcInBhdGhcIixvcHM6W119fWZ1bmN0aW9uIE8odCxlLHMsbixvKXtyZXR1cm4gZnVuY3Rpb24odCxlKXtyZXR1cm4gUyh0LCEwLGUpfShbW3QsZV0sW3QrcyxlXSxbdCtzLGUrbl0sW3QsZStuXV0sbyl9ZnVuY3Rpb24gTCh0LGUpe2lmKHQubGVuZ3RoKXtjb25zdCBzPVwibnVtYmVyXCI9PXR5cGVvZiB0WzBdWzBdP1t0XTp0LG49aihzWzBdLDEqKDErLjIqZS5yb3VnaG5lc3MpLGUpLG89ZS5kaXNhYmxlTXVsdGlTdHJva2U/W106aihzWzBdLDEuNSooMSsuMjIqZS5yb3VnaG5lc3MpLHooZSkpO2ZvcihsZXQgdD0xO3Q8cy5sZW5ndGg7dCsrKXtjb25zdCBhPXNbdF07aWYoYS5sZW5ndGgpe2NvbnN0IHQ9aihhLDEqKDErLjIqZS5yb3VnaG5lc3MpLGUpLHM9ZS5kaXNhYmxlTXVsdGlTdHJva2U/W106aihhLDEuNSooMSsuMjIqZS5yb3VnaG5lc3MpLHooZSkpO2Zvcihjb25zdCBlIG9mIHQpXCJtb3ZlXCIhPT1lLm9wJiZuLnB1c2goZSk7Zm9yKGNvbnN0IHQgb2YgcylcIm1vdmVcIiE9PXQub3AmJm8ucHVzaCh0KX19cmV0dXJue3R5cGU6XCJwYXRoXCIsb3BzOm4uY29uY2F0KG8pfX1yZXR1cm57dHlwZTpcInBhdGhcIixvcHM6W119fWZ1bmN0aW9uIFQodCxlLHMpe2NvbnN0IG49TWF0aC5zcXJ0KDIqTWF0aC5QSSpNYXRoLnNxcnQoKE1hdGgucG93KHQvMiwyKStNYXRoLnBvdyhlLzIsMikpLzIpKSxvPU1hdGguY2VpbChNYXRoLm1heChzLmN1cnZlU3RlcENvdW50LHMuY3VydmVTdGVwQ291bnQvTWF0aC5zcXJ0KDIwMCkqbikpLGE9MipNYXRoLlBJL287bGV0IGg9TWF0aC5hYnModC8yKSxyPU1hdGguYWJzKGUvMik7Y29uc3QgaT0xLXMuY3VydmVGaXR0aW5nO3JldHVybiBoKz1HKGgqaSxzKSxyKz1HKHIqaSxzKSx7aW5jcmVtZW50OmEscng6aCxyeTpyfX1mdW5jdGlvbiBEKHQsZSxzLG4pe2NvbnN0W28sYV09RihuLmluY3JlbWVudCx0LGUsbi5yeCxuLnJ5LDEsbi5pbmNyZW1lbnQqRSguMSxFKC40LDEscykscykscyk7bGV0IGg9cShvLG51bGwscyk7aWYoIXMuZGlzYWJsZU11bHRpU3Ryb2tlJiYwIT09cy5yb3VnaG5lc3Mpe2NvbnN0W29dPUYobi5pbmNyZW1lbnQsdCxlLG4ucngsbi5yeSwxLjUsMCxzKSxhPXEobyxudWxsLHMpO2g9aC5jb25jYXQoYSl9cmV0dXJue2VzdGltYXRlZFBvaW50czphLG9wc2V0Ont0eXBlOlwicGF0aFwiLG9wczpofX19ZnVuY3Rpb24gQSh0LGUscyxuLG8sYSxoLHIsaSl7Y29uc3QgYz10LGw9ZTtsZXQgdT1NYXRoLmFicyhzLzIpLHA9TWF0aC5hYnMobi8yKTt1Kz1HKC4wMSp1LGkpLHArPUcoLjAxKnAsaSk7bGV0IGY9byxkPWE7Zm9yKDtmPDA7KWYrPTIqTWF0aC5QSSxkKz0yKk1hdGguUEk7ZC1mPjIqTWF0aC5QSSYmKGY9MCxkPTIqTWF0aC5QSSk7Y29uc3QgZz0yKk1hdGguUEkvaS5jdXJ2ZVN0ZXBDb3VudCxNPU1hdGgubWluKGcvMiwoZC1mKS8yKSxrPVYoTSxjLGwsdSxwLGYsZCwxLGkpO2lmKCFpLmRpc2FibGVNdWx0aVN0cm9rZSl7Y29uc3QgdD1WKE0sYyxsLHUscCxmLGQsMS41LGkpO2sucHVzaCguLi50KX1yZXR1cm4gaCYmKHI/ay5wdXNoKC4uLiQoYyxsLGMrdSpNYXRoLmNvcyhmKSxsK3AqTWF0aC5zaW4oZiksaSksLi4uJChjLGwsYyt1Kk1hdGguY29zKGQpLGwrcCpNYXRoLnNpbihkKSxpKSk6ay5wdXNoKHtvcDpcImxpbmVUb1wiLGRhdGE6W2MsbF19LHtvcDpcImxpbmVUb1wiLGRhdGE6W2MrdSpNYXRoLmNvcyhmKSxsK3AqTWF0aC5zaW4oZildfSkpLHt0eXBlOlwicGF0aFwiLG9wczprfX1mdW5jdGlvbiBfKHQsZSl7Y29uc3Qgcz1tKHkoYih0KSkpLG49W107bGV0IG89WzAsMF0sYT1bMCwwXTtmb3IoY29uc3R7a2V5OnQsZGF0YTpofW9mIHMpc3dpdGNoKHQpe2Nhc2VcIk1cIjphPVtoWzBdLGhbMV1dLG89W2hbMF0saFsxXV07YnJlYWs7Y2FzZVwiTFwiOm4ucHVzaCguLi4kKGFbMF0sYVsxXSxoWzBdLGhbMV0sZSkpLGE9W2hbMF0saFsxXV07YnJlYWs7Y2FzZVwiQ1wiOntjb25zdFt0LHMsbyxyLGksY109aDtuLnB1c2goLi4uWih0LHMsbyxyLGksYyxhLGUpKSxhPVtpLGNdO2JyZWFrfWNhc2VcIlpcIjpuLnB1c2goLi4uJChhWzBdLGFbMV0sb1swXSxvWzFdLGUpKSxhPVtvWzBdLG9bMV1dfXJldHVybnt0eXBlOlwicGF0aFwiLG9wczpufX1mdW5jdGlvbiBJKHQsZSl7Y29uc3Qgcz1bXTtmb3IoY29uc3QgbiBvZiB0KWlmKG4ubGVuZ3RoKXtjb25zdCB0PWUubWF4UmFuZG9tbmVzc09mZnNldHx8MCxvPW4ubGVuZ3RoO2lmKG8+Mil7cy5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOltuWzBdWzBdK0codCxlKSxuWzBdWzFdK0codCxlKV19KTtmb3IobGV0IGE9MTthPG87YSsrKXMucHVzaCh7b3A6XCJsaW5lVG9cIixkYXRhOltuW2FdWzBdK0codCxlKSxuW2FdWzFdK0codCxlKV19KX19cmV0dXJue3R5cGU6XCJmaWxsUGF0aFwiLG9wczpzfX1mdW5jdGlvbiBDKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7bGV0IHM9dC5maWxsU3R5bGV8fFwiaGFjaHVyZVwiO2lmKCF1W3NdKXN3aXRjaChzKXtjYXNlXCJ6aWd6YWdcIjp1W3NdfHwodVtzXT1uZXcgaChlKSk7YnJlYWs7Y2FzZVwiY3Jvc3MtaGF0Y2hcIjp1W3NdfHwodVtzXT1uZXcgcihlKSk7YnJlYWs7Y2FzZVwiZG90c1wiOnVbc118fCh1W3NdPW5ldyBpKGUpKTticmVhaztjYXNlXCJkYXNoZWRcIjp1W3NdfHwodVtzXT1uZXcgYyhlKSk7YnJlYWs7Y2FzZVwiemlnemFnLWxpbmVcIjp1W3NdfHwodVtzXT1uZXcgbChlKSk7YnJlYWs7ZGVmYXVsdDpzPVwiaGFjaHVyZVwiLHVbc118fCh1W3NdPW5ldyBvKGUpKX1yZXR1cm4gdVtzXX0oZSxQKS5maWxsUG9seWdvbnModCxlKX1mdW5jdGlvbiB6KHQpe2NvbnN0IGU9T2JqZWN0LmFzc2lnbih7fSx0KTtyZXR1cm4gZS5yYW5kb21pemVyPXZvaWQgMCx0LnNlZWQmJihlLnNlZWQ9dC5zZWVkKzEpLGV9ZnVuY3Rpb24gVyh0KXtyZXR1cm4gdC5yYW5kb21pemVyfHwodC5yYW5kb21pemVyPW5ldyBwKHQuc2VlZHx8MCkpLHQucmFuZG9taXplci5uZXh0KCl9ZnVuY3Rpb24gRSh0LGUscyxuPTEpe3JldHVybiBzLnJvdWdobmVzcypuKihXKHMpKihlLXQpK3QpfWZ1bmN0aW9uIEcodCxlLHM9MSl7cmV0dXJuIEUoLXQsdCxlLHMpfWZ1bmN0aW9uICQodCxlLHMsbixvLGE9ITEpe2NvbnN0IGg9YT9vLmRpc2FibGVNdWx0aVN0cm9rZUZpbGw6by5kaXNhYmxlTXVsdGlTdHJva2Uscj1SKHQsZSxzLG4sbywhMCwhMSk7aWYoaClyZXR1cm4gcjtjb25zdCBpPVIodCxlLHMsbixvLCEwLCEwKTtyZXR1cm4gci5jb25jYXQoaSl9ZnVuY3Rpb24gUih0LGUscyxuLG8sYSxoKXtjb25zdCByPU1hdGgucG93KHQtcywyKStNYXRoLnBvdyhlLW4sMiksaT1NYXRoLnNxcnQocik7bGV0IGM9MTtjPWk8MjAwPzE6aT41MDA/LjQ6LS4wMDE2NjY4KmkrMS4yMzMzMzQ7bGV0IGw9by5tYXhSYW5kb21uZXNzT2Zmc2V0fHwwO2wqbCoxMDA+ciYmKGw9aS8xMCk7Y29uc3QgdT1sLzIscD0uMisuMipXKG8pO2xldCBmPW8uYm93aW5nKm8ubWF4UmFuZG9tbmVzc09mZnNldCoobi1lKS8yMDAsZD1vLmJvd2luZypvLm1heFJhbmRvbW5lc3NPZmZzZXQqKHQtcykvMjAwO2Y9RyhmLG8sYyksZD1HKGQsbyxjKTtjb25zdCBnPVtdLE09KCk9PkcodSxvLGMpLGs9KCk9PkcobCxvLGMpLGI9by5wcmVzZXJ2ZVZlcnRpY2VzO3JldHVybiBhJiYoaD9nLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3QrKGI/MDpNKCkpLGUrKGI/MDpNKCkpXX0pOmcucHVzaCh7b3A6XCJtb3ZlXCIsZGF0YTpbdCsoYj8wOkcobCxvLGMpKSxlKyhiPzA6RyhsLG8sYykpXX0pKSxoP2cucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W2YrdCsocy10KSpwK00oKSxkK2UrKG4tZSkqcCtNKCksZit0KzIqKHMtdCkqcCtNKCksZCtlKzIqKG4tZSkqcCtNKCkscysoYj8wOk0oKSksbisoYj8wOk0oKSldfSk6Zy5wdXNoKHtvcDpcImJjdXJ2ZVRvXCIsZGF0YTpbZit0KyhzLXQpKnAraygpLGQrZSsobi1lKSpwK2soKSxmK3QrMioocy10KSpwK2soKSxkK2UrMioobi1lKSpwK2soKSxzKyhiPzA6aygpKSxuKyhiPzA6aygpKV19KSxnfWZ1bmN0aW9uIGoodCxlLHMpe2lmKCF0Lmxlbmd0aClyZXR1cm5bXTtjb25zdCBuPVtdO24ucHVzaChbdFswXVswXStHKGUscyksdFswXVsxXStHKGUscyldKSxuLnB1c2goW3RbMF1bMF0rRyhlLHMpLHRbMF1bMV0rRyhlLHMpXSk7Zm9yKGxldCBvPTE7bzx0Lmxlbmd0aDtvKyspbi5wdXNoKFt0W29dWzBdK0coZSxzKSx0W29dWzFdK0coZSxzKV0pLG89PT10Lmxlbmd0aC0xJiZuLnB1c2goW3Rbb11bMF0rRyhlLHMpLHRbb11bMV0rRyhlLHMpXSk7cmV0dXJuIHEobixudWxsLHMpfWZ1bmN0aW9uIHEodCxlLHMpe2NvbnN0IG49dC5sZW5ndGgsbz1bXTtpZihuPjMpe2NvbnN0IGE9W10saD0xLXMuY3VydmVUaWdodG5lc3M7by5wdXNoKHtvcDpcIm1vdmVcIixkYXRhOlt0WzFdWzBdLHRbMV1bMV1dfSk7Zm9yKGxldCBlPTE7ZSsyPG47ZSsrKXtjb25zdCBzPXRbZV07YVswXT1bc1swXSxzWzFdXSxhWzFdPVtzWzBdKyhoKnRbZSsxXVswXS1oKnRbZS0xXVswXSkvNixzWzFdKyhoKnRbZSsxXVsxXS1oKnRbZS0xXVsxXSkvNl0sYVsyXT1bdFtlKzFdWzBdKyhoKnRbZV1bMF0taCp0W2UrMl1bMF0pLzYsdFtlKzFdWzFdKyhoKnRbZV1bMV0taCp0W2UrMl1bMV0pLzZdLGFbM109W3RbZSsxXVswXSx0W2UrMV1bMV1dLG8ucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W2FbMV1bMF0sYVsxXVsxXSxhWzJdWzBdLGFbMl1bMV0sYVszXVswXSxhWzNdWzFdXX0pfWlmKGUmJjI9PT1lLmxlbmd0aCl7Y29uc3QgdD1zLm1heFJhbmRvbW5lc3NPZmZzZXQ7by5wdXNoKHtvcDpcImxpbmVUb1wiLGRhdGE6W2VbMF0rRyh0LHMpLGVbMV0rRyh0LHMpXX0pfX1lbHNlIDM9PT1uPyhvLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W3RbMV1bMF0sdFsxXVsxXV19KSxvLnB1c2goe29wOlwiYmN1cnZlVG9cIixkYXRhOlt0WzFdWzBdLHRbMV1bMV0sdFsyXVswXSx0WzJdWzFdLHRbMl1bMF0sdFsyXVsxXV19KSk6Mj09PW4mJm8ucHVzaCguLi5SKHRbMF1bMF0sdFswXVsxXSx0WzFdWzBdLHRbMV1bMV0scywhMCwhMCkpO3JldHVybiBvfWZ1bmN0aW9uIEYodCxlLHMsbixvLGEsaCxyKXtjb25zdCBpPVtdLGM9W107aWYoMD09PXIucm91Z2huZXNzKXt0Lz00LGMucHVzaChbZStuKk1hdGguY29zKC10KSxzK28qTWF0aC5zaW4oLXQpXSk7Zm9yKGxldCBhPTA7YTw9MipNYXRoLlBJO2ErPXQpe2NvbnN0IHQ9W2UrbipNYXRoLmNvcyhhKSxzK28qTWF0aC5zaW4oYSldO2kucHVzaCh0KSxjLnB1c2godCl9Yy5wdXNoKFtlK24qTWF0aC5jb3MoMCkscytvKk1hdGguc2luKDApXSksYy5wdXNoKFtlK24qTWF0aC5jb3ModCkscytvKk1hdGguc2luKHQpXSl9ZWxzZXtjb25zdCBsPUcoLjUsciktTWF0aC5QSS8yO2MucHVzaChbRyhhLHIpK2UrLjkqbipNYXRoLmNvcyhsLXQpLEcoYSxyKStzKy45Km8qTWF0aC5zaW4obC10KV0pO2NvbnN0IHU9MipNYXRoLlBJK2wtLjAxO2ZvcihsZXQgaD1sO2g8dTtoKz10KXtjb25zdCB0PVtHKGEscikrZStuKk1hdGguY29zKGgpLEcoYSxyKStzK28qTWF0aC5zaW4oaCldO2kucHVzaCh0KSxjLnB1c2godCl9Yy5wdXNoKFtHKGEscikrZStuKk1hdGguY29zKGwrMipNYXRoLlBJKy41KmgpLEcoYSxyKStzK28qTWF0aC5zaW4obCsyKk1hdGguUEkrLjUqaCldKSxjLnB1c2goW0coYSxyKStlKy45OCpuKk1hdGguY29zKGwraCksRyhhLHIpK3MrLjk4Km8qTWF0aC5zaW4obCtoKV0pLGMucHVzaChbRyhhLHIpK2UrLjkqbipNYXRoLmNvcyhsKy41KmgpLEcoYSxyKStzKy45Km8qTWF0aC5zaW4obCsuNSpoKV0pfXJldHVybltjLGldfWZ1bmN0aW9uIFYodCxlLHMsbixvLGEsaCxyLGkpe2NvbnN0IGM9YStHKC4xLGkpLGw9W107bC5wdXNoKFtHKHIsaSkrZSsuOSpuKk1hdGguY29zKGMtdCksRyhyLGkpK3MrLjkqbypNYXRoLnNpbihjLXQpXSk7Zm9yKGxldCBhPWM7YTw9aDthKz10KWwucHVzaChbRyhyLGkpK2UrbipNYXRoLmNvcyhhKSxHKHIsaSkrcytvKk1hdGguc2luKGEpXSk7cmV0dXJuIGwucHVzaChbZStuKk1hdGguY29zKGgpLHMrbypNYXRoLnNpbihoKV0pLGwucHVzaChbZStuKk1hdGguY29zKGgpLHMrbypNYXRoLnNpbihoKV0pLHEobCxudWxsLGkpfWZ1bmN0aW9uIFoodCxlLHMsbixvLGEsaCxyKXtjb25zdCBpPVtdLGM9W3IubWF4UmFuZG9tbmVzc09mZnNldHx8MSwoci5tYXhSYW5kb21uZXNzT2Zmc2V0fHwxKSsuM107bGV0IGw9WzAsMF07Y29uc3QgdT1yLmRpc2FibGVNdWx0aVN0cm9rZT8xOjIscD1yLnByZXNlcnZlVmVydGljZXM7Zm9yKGxldCBmPTA7Zjx1O2YrKykwPT09Zj9pLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W2hbMF0saFsxXV19KTppLnB1c2goe29wOlwibW92ZVwiLGRhdGE6W2hbMF0rKHA/MDpHKGNbMF0scikpLGhbMV0rKHA/MDpHKGNbMF0scikpXX0pLGw9cD9bbyxhXTpbbytHKGNbZl0sciksYStHKGNbZl0scildLGkucHVzaCh7b3A6XCJiY3VydmVUb1wiLGRhdGE6W3QrRyhjW2ZdLHIpLGUrRyhjW2ZdLHIpLHMrRyhjW2ZdLHIpLG4rRyhjW2ZdLHIpLGxbMF0sbFsxXV19KTtyZXR1cm4gaX1mdW5jdGlvbiBRKHQpe3JldHVyblsuLi50XX1mdW5jdGlvbiBIKHQsZT0wKXtjb25zdCBzPXQubGVuZ3RoO2lmKHM8Myl0aHJvdyBuZXcgRXJyb3IoXCJBIGN1cnZlIG11c3QgaGF2ZSBhdCBsZWFzdCB0aHJlZSBwb2ludHMuXCIpO2NvbnN0IG49W107aWYoMz09PXMpbi5wdXNoKFEodFswXSksUSh0WzFdKSxRKHRbMl0pLFEodFsyXSkpO2Vsc2V7Y29uc3Qgcz1bXTtzLnB1c2godFswXSx0WzBdKTtmb3IobGV0IGU9MTtlPHQubGVuZ3RoO2UrKylzLnB1c2godFtlXSksZT09PXQubGVuZ3RoLTEmJnMucHVzaCh0W2VdKTtjb25zdCBvPVtdLGE9MS1lO24ucHVzaChRKHNbMF0pKTtmb3IobGV0IHQ9MTt0KzI8cy5sZW5ndGg7dCsrKXtjb25zdCBlPXNbdF07b1swXT1bZVswXSxlWzFdXSxvWzFdPVtlWzBdKyhhKnNbdCsxXVswXS1hKnNbdC0xXVswXSkvNixlWzFdKyhhKnNbdCsxXVsxXS1hKnNbdC0xXVsxXSkvNl0sb1syXT1bc1t0KzFdWzBdKyhhKnNbdF1bMF0tYSpzW3QrMl1bMF0pLzYsc1t0KzFdWzFdKyhhKnNbdF1bMV0tYSpzW3QrMl1bMV0pLzZdLG9bM109W3NbdCsxXVswXSxzW3QrMV1bMV1dLG4ucHVzaChvWzFdLG9bMl0sb1szXSl9fXJldHVybiBufWZ1bmN0aW9uIE4odCxlKXtyZXR1cm4gTWF0aC5wb3codFswXS1lWzBdLDIpK01hdGgucG93KHRbMV0tZVsxXSwyKX1mdW5jdGlvbiBCKHQsZSxzKXtjb25zdCBuPU4oZSxzKTtpZigwPT09bilyZXR1cm4gTih0LGUpO2xldCBvPSgodFswXS1lWzBdKSooc1swXS1lWzBdKSsodFsxXS1lWzFdKSooc1sxXS1lWzFdKSkvbjtyZXR1cm4gbz1NYXRoLm1heCgwLE1hdGgubWluKDEsbykpLE4odCxKKGUscyxvKSl9ZnVuY3Rpb24gSih0LGUscyl7cmV0dXJuW3RbMF0rKGVbMF0tdFswXSkqcyx0WzFdKyhlWzFdLXRbMV0pKnNdfWZ1bmN0aW9uIEsodCxlLHMsbil7Y29uc3Qgbz1ufHxbXTtpZihmdW5jdGlvbih0LGUpe2NvbnN0IHM9dFtlKzBdLG49dFtlKzFdLG89dFtlKzJdLGE9dFtlKzNdO2xldCBoPTMqblswXS0yKnNbMF0tYVswXTtoKj1oO2xldCByPTMqblsxXS0yKnNbMV0tYVsxXTtyKj1yO2xldCBpPTMqb1swXS0yKmFbMF0tc1swXTtpKj1pO2xldCBjPTMqb1sxXS0yKmFbMV0tc1sxXTtyZXR1cm4gYyo9YyxoPGkmJihoPWkpLHI8YyYmKHI9YyksaCtyfSh0LGUpPHMpe2NvbnN0IHM9dFtlKzBdO2lmKG8ubGVuZ3RoKXsoYT1vW28ubGVuZ3RoLTFdLGg9cyxNYXRoLnNxcnQoTihhLGgpKSk+MSYmby5wdXNoKHMpfWVsc2Ugby5wdXNoKHMpO28ucHVzaCh0W2UrM10pfWVsc2V7Y29uc3Qgbj0uNSxhPXRbZSswXSxoPXRbZSsxXSxyPXRbZSsyXSxpPXRbZSszXSxjPUooYSxoLG4pLGw9SihoLHIsbiksdT1KKHIsaSxuKSxwPUooYyxsLG4pLGY9SihsLHUsbiksZD1KKHAsZixuKTtLKFthLGMscCxkXSwwLHMsbyksSyhbZCxmLHUsaV0sMCxzLG8pfXZhciBhLGg7cmV0dXJuIG99ZnVuY3Rpb24gVSh0LGUpe3JldHVybiBYKHQsMCx0Lmxlbmd0aCxlKX1mdW5jdGlvbiBYKHQsZSxzLG4sbyl7Y29uc3QgYT1vfHxbXSxoPXRbZV0scj10W3MtMV07bGV0IGk9MCxjPTE7Zm9yKGxldCBuPWUrMTtuPHMtMTsrK24pe2NvbnN0IGU9Qih0W25dLGgscik7ZT5pJiYoaT1lLGM9bil9cmV0dXJuIE1hdGguc3FydChpKT5uPyhYKHQsZSxjKzEsbixhKSxYKHQsYyxzLG4sYSkpOihhLmxlbmd0aHx8YS5wdXNoKGgpLGEucHVzaChyKSksYX1mdW5jdGlvbiBZKHQsZT0uMTUscyl7Y29uc3Qgbj1bXSxvPSh0Lmxlbmd0aC0xKS8zO2ZvcihsZXQgcz0wO3M8bztzKyspe0sodCwzKnMsZSxuKX1yZXR1cm4gcyYmcz4wP1gobiwwLG4ubGVuZ3RoLHMpOm59Y29uc3QgdHQ9XCJub25lXCI7Y2xhc3MgZXR7Y29uc3RydWN0b3IodCl7dGhpcy5kZWZhdWx0T3B0aW9ucz17bWF4UmFuZG9tbmVzc09mZnNldDoyLHJvdWdobmVzczoxLGJvd2luZzoxLHN0cm9rZTpcIiMwMDBcIixzdHJva2VXaWR0aDoxLGN1cnZlVGlnaHRuZXNzOjAsY3VydmVGaXR0aW5nOi45NSxjdXJ2ZVN0ZXBDb3VudDo5LGZpbGxTdHlsZTpcImhhY2h1cmVcIixmaWxsV2VpZ2h0Oi0xLGhhY2h1cmVBbmdsZTotNDEsaGFjaHVyZUdhcDotMSxkYXNoT2Zmc2V0Oi0xLGRhc2hHYXA6LTEsemlnemFnT2Zmc2V0Oi0xLHNlZWQ6MCxkaXNhYmxlTXVsdGlTdHJva2U6ITEsZGlzYWJsZU11bHRpU3Ryb2tlRmlsbDohMSxwcmVzZXJ2ZVZlcnRpY2VzOiExLGZpbGxTaGFwZVJvdWdobmVzc0dhaW46Ljh9LHRoaXMuY29uZmlnPXR8fHt9LHRoaXMuY29uZmlnLm9wdGlvbnMmJih0aGlzLmRlZmF1bHRPcHRpb25zPXRoaXMuX28odGhpcy5jb25maWcub3B0aW9ucykpfXN0YXRpYyBuZXdTZWVkKCl7cmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoyKiozMSl9X28odCl7cmV0dXJuIHQ/T2JqZWN0LmFzc2lnbih7fSx0aGlzLmRlZmF1bHRPcHRpb25zLHQpOnRoaXMuZGVmYXVsdE9wdGlvbnN9X2QodCxlLHMpe3JldHVybntzaGFwZTp0LHNldHM6ZXx8W10sb3B0aW9uczpzfHx0aGlzLmRlZmF1bHRPcHRpb25zfX1saW5lKHQsZSxzLG4sbyl7Y29uc3QgYT10aGlzLl9vKG8pO3JldHVybiB0aGlzLl9kKFwibGluZVwiLFt2KHQsZSxzLG4sYSldLGEpfXJlY3RhbmdsZSh0LGUscyxuLG8pe2NvbnN0IGE9dGhpcy5fbyhvKSxoPVtdLHI9Tyh0LGUscyxuLGEpO2lmKGEuZmlsbCl7Y29uc3Qgbz1bW3QsZV0sW3QrcyxlXSxbdCtzLGUrbl0sW3QsZStuXV07XCJzb2xpZFwiPT09YS5maWxsU3R5bGU/aC5wdXNoKEkoW29dLGEpKTpoLnB1c2goQyhbb10sYSkpfXJldHVybiBhLnN0cm9rZSE9PXR0JiZoLnB1c2gociksdGhpcy5fZChcInJlY3RhbmdsZVwiLGgsYSl9ZWxsaXBzZSh0LGUscyxuLG8pe2NvbnN0IGE9dGhpcy5fbyhvKSxoPVtdLHI9VChzLG4sYSksaT1EKHQsZSxhLHIpO2lmKGEuZmlsbClpZihcInNvbGlkXCI9PT1hLmZpbGxTdHlsZSl7Y29uc3Qgcz1EKHQsZSxhLHIpLm9wc2V0O3MudHlwZT1cImZpbGxQYXRoXCIsaC5wdXNoKHMpfWVsc2UgaC5wdXNoKEMoW2kuZXN0aW1hdGVkUG9pbnRzXSxhKSk7cmV0dXJuIGEuc3Ryb2tlIT09dHQmJmgucHVzaChpLm9wc2V0KSx0aGlzLl9kKFwiZWxsaXBzZVwiLGgsYSl9Y2lyY2xlKHQsZSxzLG4pe2NvbnN0IG89dGhpcy5lbGxpcHNlKHQsZSxzLHMsbik7cmV0dXJuIG8uc2hhcGU9XCJjaXJjbGVcIixvfWxpbmVhclBhdGgodCxlKXtjb25zdCBzPXRoaXMuX28oZSk7cmV0dXJuIHRoaXMuX2QoXCJsaW5lYXJQYXRoXCIsW1ModCwhMSxzKV0scyl9YXJjKHQsZSxzLG4sbyxhLGg9ITEscil7Y29uc3QgaT10aGlzLl9vKHIpLGM9W10sbD1BKHQsZSxzLG4sbyxhLGgsITAsaSk7aWYoaCYmaS5maWxsKWlmKFwic29saWRcIj09PWkuZmlsbFN0eWxlKXtjb25zdCBoPU9iamVjdC5hc3NpZ24oe30saSk7aC5kaXNhYmxlTXVsdGlTdHJva2U9ITA7Y29uc3Qgcj1BKHQsZSxzLG4sbyxhLCEwLCExLGgpO3IudHlwZT1cImZpbGxQYXRoXCIsYy5wdXNoKHIpfWVsc2UgYy5wdXNoKGZ1bmN0aW9uKHQsZSxzLG4sbyxhLGgpe2NvbnN0IHI9dCxpPWU7bGV0IGM9TWF0aC5hYnMocy8yKSxsPU1hdGguYWJzKG4vMik7Yys9RyguMDEqYyxoKSxsKz1HKC4wMSpsLGgpO2xldCB1PW8scD1hO2Zvcig7dTwwOyl1Kz0yKk1hdGguUEkscCs9MipNYXRoLlBJO3AtdT4yKk1hdGguUEkmJih1PTAscD0yKk1hdGguUEkpO2NvbnN0IGY9KHAtdSkvaC5jdXJ2ZVN0ZXBDb3VudCxkPVtdO2ZvcihsZXQgdD11O3Q8PXA7dCs9ZilkLnB1c2goW3IrYypNYXRoLmNvcyh0KSxpK2wqTWF0aC5zaW4odCldKTtyZXR1cm4gZC5wdXNoKFtyK2MqTWF0aC5jb3MocCksaStsKk1hdGguc2luKHApXSksZC5wdXNoKFtyLGldKSxDKFtkXSxoKX0odCxlLHMsbixvLGEsaSkpO3JldHVybiBpLnN0cm9rZSE9PXR0JiZjLnB1c2gobCksdGhpcy5fZChcImFyY1wiLGMsaSl9Y3VydmUodCxlKXtjb25zdCBzPXRoaXMuX28oZSksbj1bXSxvPUwodCxzKTtpZihzLmZpbGwmJnMuZmlsbCE9PXR0KWlmKFwic29saWRcIj09PXMuZmlsbFN0eWxlKXtjb25zdCBlPUwodCxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2Rpc2FibGVNdWx0aVN0cm9rZTohMCxyb3VnaG5lc3M6cy5yb3VnaG5lc3M/cy5yb3VnaG5lc3Mrcy5maWxsU2hhcGVSb3VnaG5lc3NHYWluOjB9KSk7bi5wdXNoKHt0eXBlOlwiZmlsbFBhdGhcIixvcHM6dGhpcy5fbWVyZ2VkU2hhcGUoZS5vcHMpfSl9ZWxzZXtjb25zdCBlPVtdLG89dDtpZihvLmxlbmd0aCl7Y29uc3QgdD1cIm51bWJlclwiPT10eXBlb2Ygb1swXVswXT9bb106bztmb3IoY29uc3QgbiBvZiB0KW4ubGVuZ3RoPDM/ZS5wdXNoKC4uLm4pOjM9PT1uLmxlbmd0aD9lLnB1c2goLi4uWShIKFtuWzBdLG5bMF0sblsxXSxuWzJdXSksMTAsKDErcy5yb3VnaG5lc3MpLzIpKTplLnB1c2goLi4uWShIKG4pLDEwLCgxK3Mucm91Z2huZXNzKS8yKSl9ZS5sZW5ndGgmJm4ucHVzaChDKFtlXSxzKSl9cmV0dXJuIHMuc3Ryb2tlIT09dHQmJm4ucHVzaChvKSx0aGlzLl9kKFwiY3VydmVcIixuLHMpfXBvbHlnb24odCxlKXtjb25zdCBzPXRoaXMuX28oZSksbj1bXSxvPVModCwhMCxzKTtyZXR1cm4gcy5maWxsJiYoXCJzb2xpZFwiPT09cy5maWxsU3R5bGU/bi5wdXNoKEkoW3RdLHMpKTpuLnB1c2goQyhbdF0scykpKSxzLnN0cm9rZSE9PXR0JiZuLnB1c2gobyksdGhpcy5fZChcInBvbHlnb25cIixuLHMpfXBhdGgodCxlKXtjb25zdCBzPXRoaXMuX28oZSksbj1bXTtpZighdClyZXR1cm4gdGhpcy5fZChcInBhdGhcIixuLHMpO3Q9KHR8fFwiXCIpLnJlcGxhY2UoL1xcbi9nLFwiIFwiKS5yZXBsYWNlKC8oLVxccykvZyxcIi1cIikucmVwbGFjZShcIi8oc3MpL2dcIixcIiBcIik7Y29uc3Qgbz1zLmZpbGwmJlwidHJhbnNwYXJlbnRcIiE9PXMuZmlsbCYmcy5maWxsIT09dHQsYT1zLnN0cm9rZSE9PXR0LGg9ISEocy5zaW1wbGlmaWNhdGlvbiYmcy5zaW1wbGlmaWNhdGlvbjwxKSxyPWZ1bmN0aW9uKHQsZSxzKXtjb25zdCBuPW0oeShiKHQpKSksbz1bXTtsZXQgYT1bXSxoPVswLDBdLHI9W107Y29uc3QgaT0oKT0+e3IubGVuZ3RoPj00JiZhLnB1c2goLi4uWShyLGUpKSxyPVtdfSxjPSgpPT57aSgpLGEubGVuZ3RoJiYoby5wdXNoKGEpLGE9W10pfTtmb3IoY29uc3R7a2V5OnQsZGF0YTplfW9mIG4pc3dpdGNoKHQpe2Nhc2VcIk1cIjpjKCksaD1bZVswXSxlWzFdXSxhLnB1c2goaCk7YnJlYWs7Y2FzZVwiTFwiOmkoKSxhLnB1c2goW2VbMF0sZVsxXV0pO2JyZWFrO2Nhc2VcIkNcIjppZighci5sZW5ndGgpe2NvbnN0IHQ9YS5sZW5ndGg/YVthLmxlbmd0aC0xXTpoO3IucHVzaChbdFswXSx0WzFdXSl9ci5wdXNoKFtlWzBdLGVbMV1dKSxyLnB1c2goW2VbMl0sZVszXV0pLHIucHVzaChbZVs0XSxlWzVdXSk7YnJlYWs7Y2FzZVwiWlwiOmkoKSxhLnB1c2goW2hbMF0saFsxXV0pfWlmKGMoKSwhcylyZXR1cm4gbztjb25zdCBsPVtdO2Zvcihjb25zdCB0IG9mIG8pe2NvbnN0IGU9VSh0LHMpO2UubGVuZ3RoJiZsLnB1c2goZSl9cmV0dXJuIGx9KHQsMSxoPzQtNCoocy5zaW1wbGlmaWNhdGlvbnx8MSk6KDErcy5yb3VnaG5lc3MpLzIpLGk9Xyh0LHMpO2lmKG8paWYoXCJzb2xpZFwiPT09cy5maWxsU3R5bGUpaWYoMT09PXIubGVuZ3RoKXtjb25zdCBlPV8odCxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scykse2Rpc2FibGVNdWx0aVN0cm9rZTohMCxyb3VnaG5lc3M6cy5yb3VnaG5lc3M/cy5yb3VnaG5lc3Mrcy5maWxsU2hhcGVSb3VnaG5lc3NHYWluOjB9KSk7bi5wdXNoKHt0eXBlOlwiZmlsbFBhdGhcIixvcHM6dGhpcy5fbWVyZ2VkU2hhcGUoZS5vcHMpfSl9ZWxzZSBuLnB1c2goSShyLHMpKTtlbHNlIG4ucHVzaChDKHIscykpO3JldHVybiBhJiYoaD9yLmZvckVhY2goKHQ9PntuLnB1c2goUyh0LCExLHMpKX0pKTpuLnB1c2goaSkpLHRoaXMuX2QoXCJwYXRoXCIsbixzKX1vcHNUb1BhdGgodCxlKXtsZXQgcz1cIlwiO2Zvcihjb25zdCBuIG9mIHQub3BzKXtjb25zdCB0PVwibnVtYmVyXCI9PXR5cGVvZiBlJiZlPj0wP24uZGF0YS5tYXAoKHQ9Pit0LnRvRml4ZWQoZSkpKTpuLmRhdGE7c3dpdGNoKG4ub3Ape2Nhc2VcIm1vdmVcIjpzKz1gTSR7dFswXX0gJHt0WzFdfSBgO2JyZWFrO2Nhc2VcImJjdXJ2ZVRvXCI6cys9YEMke3RbMF19ICR7dFsxXX0sICR7dFsyXX0gJHt0WzNdfSwgJHt0WzRdfSAke3RbNV19IGA7YnJlYWs7Y2FzZVwibGluZVRvXCI6cys9YEwke3RbMF19ICR7dFsxXX0gYH19cmV0dXJuIHMudHJpbSgpfXRvUGF0aHModCl7Y29uc3QgZT10LnNldHN8fFtdLHM9dC5vcHRpb25zfHx0aGlzLmRlZmF1bHRPcHRpb25zLG49W107Zm9yKGNvbnN0IHQgb2YgZSl7bGV0IGU9bnVsbDtzd2l0Y2godC50eXBlKXtjYXNlXCJwYXRoXCI6ZT17ZDp0aGlzLm9wc1RvUGF0aCh0KSxzdHJva2U6cy5zdHJva2Usc3Ryb2tlV2lkdGg6cy5zdHJva2VXaWR0aCxmaWxsOnR0fTticmVhaztjYXNlXCJmaWxsUGF0aFwiOmU9e2Q6dGhpcy5vcHNUb1BhdGgodCksc3Ryb2tlOnR0LHN0cm9rZVdpZHRoOjAsZmlsbDpzLmZpbGx8fHR0fTticmVhaztjYXNlXCJmaWxsU2tldGNoXCI6ZT10aGlzLmZpbGxTa2V0Y2godCxzKX1lJiZuLnB1c2goZSl9cmV0dXJuIG59ZmlsbFNrZXRjaCh0LGUpe2xldCBzPWUuZmlsbFdlaWdodDtyZXR1cm4gczwwJiYocz1lLnN0cm9rZVdpZHRoLzIpLHtkOnRoaXMub3BzVG9QYXRoKHQpLHN0cm9rZTplLmZpbGx8fHR0LHN0cm9rZVdpZHRoOnMsZmlsbDp0dH19X21lcmdlZFNoYXBlKHQpe3JldHVybiB0LmZpbHRlcigoKHQsZSk9PjA9PT1lfHxcIm1vdmVcIiE9PXQub3ApKX19Y2xhc3Mgc3R7Y29uc3RydWN0b3IodCxlKXt0aGlzLmNhbnZhcz10LHRoaXMuY3R4PXRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSx0aGlzLmdlbj1uZXcgZXQoZSl9ZHJhdyh0KXtjb25zdCBlPXQuc2V0c3x8W10scz10Lm9wdGlvbnN8fHRoaXMuZ2V0RGVmYXVsdE9wdGlvbnMoKSxuPXRoaXMuY3R4LG89dC5vcHRpb25zLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzO2Zvcihjb25zdCBhIG9mIGUpc3dpdGNoKGEudHlwZSl7Y2FzZVwicGF0aFwiOm4uc2F2ZSgpLG4uc3Ryb2tlU3R5bGU9XCJub25lXCI9PT1zLnN0cm9rZT9cInRyYW5zcGFyZW50XCI6cy5zdHJva2Usbi5saW5lV2lkdGg9cy5zdHJva2VXaWR0aCxzLnN0cm9rZUxpbmVEYXNoJiZuLnNldExpbmVEYXNoKHMuc3Ryb2tlTGluZURhc2gpLHMuc3Ryb2tlTGluZURhc2hPZmZzZXQmJihuLmxpbmVEYXNoT2Zmc2V0PXMuc3Ryb2tlTGluZURhc2hPZmZzZXQpLHRoaXMuX2RyYXdUb0NvbnRleHQobixhLG8pLG4ucmVzdG9yZSgpO2JyZWFrO2Nhc2VcImZpbGxQYXRoXCI6e24uc2F2ZSgpLG4uZmlsbFN0eWxlPXMuZmlsbHx8XCJcIjtjb25zdCBlPVwiY3VydmVcIj09PXQuc2hhcGV8fFwicG9seWdvblwiPT09dC5zaGFwZXx8XCJwYXRoXCI9PT10LnNoYXBlP1wiZXZlbm9kZFwiOlwibm9uemVyb1wiO3RoaXMuX2RyYXdUb0NvbnRleHQobixhLG8sZSksbi5yZXN0b3JlKCk7YnJlYWt9Y2FzZVwiZmlsbFNrZXRjaFwiOnRoaXMuZmlsbFNrZXRjaChuLGEscyl9fWZpbGxTa2V0Y2godCxlLHMpe2xldCBuPXMuZmlsbFdlaWdodDtuPDAmJihuPXMuc3Ryb2tlV2lkdGgvMiksdC5zYXZlKCkscy5maWxsTGluZURhc2gmJnQuc2V0TGluZURhc2gocy5maWxsTGluZURhc2gpLHMuZmlsbExpbmVEYXNoT2Zmc2V0JiYodC5saW5lRGFzaE9mZnNldD1zLmZpbGxMaW5lRGFzaE9mZnNldCksdC5zdHJva2VTdHlsZT1zLmZpbGx8fFwiXCIsdC5saW5lV2lkdGg9bix0aGlzLl9kcmF3VG9Db250ZXh0KHQsZSxzLmZpeGVkRGVjaW1hbFBsYWNlRGlnaXRzKSx0LnJlc3RvcmUoKX1fZHJhd1RvQ29udGV4dCh0LGUscyxuPVwibm9uemVyb1wiKXt0LmJlZ2luUGF0aCgpO2Zvcihjb25zdCBuIG9mIGUub3BzKXtjb25zdCBlPVwibnVtYmVyXCI9PXR5cGVvZiBzJiZzPj0wP24uZGF0YS5tYXAoKHQ9Pit0LnRvRml4ZWQocykpKTpuLmRhdGE7c3dpdGNoKG4ub3Ape2Nhc2VcIm1vdmVcIjp0Lm1vdmVUbyhlWzBdLGVbMV0pO2JyZWFrO2Nhc2VcImJjdXJ2ZVRvXCI6dC5iZXppZXJDdXJ2ZVRvKGVbMF0sZVsxXSxlWzJdLGVbM10sZVs0XSxlWzVdKTticmVhaztjYXNlXCJsaW5lVG9cIjp0LmxpbmVUbyhlWzBdLGVbMV0pfX1cImZpbGxQYXRoXCI9PT1lLnR5cGU/dC5maWxsKG4pOnQuc3Ryb2tlKCl9Z2V0IGdlbmVyYXRvcigpe3JldHVybiB0aGlzLmdlbn1nZXREZWZhdWx0T3B0aW9ucygpe3JldHVybiB0aGlzLmdlbi5kZWZhdWx0T3B0aW9uc31saW5lKHQsZSxzLG4sbyl7Y29uc3QgYT10aGlzLmdlbi5saW5lKHQsZSxzLG4sbyk7cmV0dXJuIHRoaXMuZHJhdyhhKSxhfXJlY3RhbmdsZSh0LGUscyxuLG8pe2NvbnN0IGE9dGhpcy5nZW4ucmVjdGFuZ2xlKHQsZSxzLG4sbyk7cmV0dXJuIHRoaXMuZHJhdyhhKSxhfWVsbGlwc2UodCxlLHMsbixvKXtjb25zdCBhPXRoaXMuZ2VuLmVsbGlwc2UodCxlLHMsbixvKTtyZXR1cm4gdGhpcy5kcmF3KGEpLGF9Y2lyY2xlKHQsZSxzLG4pe2NvbnN0IG89dGhpcy5nZW4uY2lyY2xlKHQsZSxzLG4pO3JldHVybiB0aGlzLmRyYXcobyksb31saW5lYXJQYXRoKHQsZSl7Y29uc3Qgcz10aGlzLmdlbi5saW5lYXJQYXRoKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKSxzfXBvbHlnb24odCxlKXtjb25zdCBzPXRoaXMuZ2VuLnBvbHlnb24odCxlKTtyZXR1cm4gdGhpcy5kcmF3KHMpLHN9YXJjKHQsZSxzLG4sbyxhLGg9ITEscil7Y29uc3QgaT10aGlzLmdlbi5hcmModCxlLHMsbixvLGEsaCxyKTtyZXR1cm4gdGhpcy5kcmF3KGkpLGl9Y3VydmUodCxlKXtjb25zdCBzPXRoaXMuZ2VuLmN1cnZlKHQsZSk7cmV0dXJuIHRoaXMuZHJhdyhzKSxzfXBhdGgodCxlKXtjb25zdCBzPXRoaXMuZ2VuLnBhdGgodCxlKTtyZXR1cm4gdGhpcy5kcmF3KHMpLHN9fWNvbnN0IG50PVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtjbGFzcyBvdHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuc3ZnPXQsdGhpcy5nZW49bmV3IGV0KGUpfWRyYXcodCl7Y29uc3QgZT10LnNldHN8fFtdLHM9dC5vcHRpb25zfHx0aGlzLmdldERlZmF1bHRPcHRpb25zKCksbj10aGlzLnN2Zy5vd25lckRvY3VtZW50fHx3aW5kb3cuZG9jdW1lbnQsbz1uLmNyZWF0ZUVsZW1lbnROUyhudCxcImdcIiksYT10Lm9wdGlvbnMuZml4ZWREZWNpbWFsUGxhY2VEaWdpdHM7Zm9yKGNvbnN0IGggb2YgZSl7bGV0IGU9bnVsbDtzd2l0Y2goaC50eXBlKXtjYXNlXCJwYXRoXCI6ZT1uLmNyZWF0ZUVsZW1lbnROUyhudCxcInBhdGhcIiksZS5zZXRBdHRyaWJ1dGUoXCJkXCIsdGhpcy5vcHNUb1BhdGgoaCxhKSksZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIixzLnN0cm9rZSksZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIixzLnN0cm9rZVdpZHRoK1wiXCIpLGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLFwibm9uZVwiKSxzLnN0cm9rZUxpbmVEYXNoJiZlLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIixzLnN0cm9rZUxpbmVEYXNoLmpvaW4oXCIgXCIpLnRyaW0oKSkscy5zdHJva2VMaW5lRGFzaE9mZnNldCYmZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2UtZGFzaG9mZnNldFwiLGAke3Muc3Ryb2tlTGluZURhc2hPZmZzZXR9YCk7YnJlYWs7Y2FzZVwiZmlsbFBhdGhcIjplPW4uY3JlYXRlRWxlbWVudE5TKG50LFwicGF0aFwiKSxlLnNldEF0dHJpYnV0ZShcImRcIix0aGlzLm9wc1RvUGF0aChoLGEpKSxlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLFwibm9uZVwiKSxlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLFwiMFwiKSxlLnNldEF0dHJpYnV0ZShcImZpbGxcIixzLmZpbGx8fFwiXCIpLFwiY3VydmVcIiE9PXQuc2hhcGUmJlwicG9seWdvblwiIT09dC5zaGFwZXx8ZS5zZXRBdHRyaWJ1dGUoXCJmaWxsLXJ1bGVcIixcImV2ZW5vZGRcIik7YnJlYWs7Y2FzZVwiZmlsbFNrZXRjaFwiOmU9dGhpcy5maWxsU2tldGNoKG4saCxzKX1lJiZvLmFwcGVuZENoaWxkKGUpfXJldHVybiBvfWZpbGxTa2V0Y2godCxlLHMpe2xldCBuPXMuZmlsbFdlaWdodDtuPDAmJihuPXMuc3Ryb2tlV2lkdGgvMik7Y29uc3Qgbz10LmNyZWF0ZUVsZW1lbnROUyhudCxcInBhdGhcIik7cmV0dXJuIG8uc2V0QXR0cmlidXRlKFwiZFwiLHRoaXMub3BzVG9QYXRoKGUscy5maXhlZERlY2ltYWxQbGFjZURpZ2l0cykpLG8uc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIscy5maWxsfHxcIlwiKSxvLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLG4rXCJcIiksby5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsXCJub25lXCIpLHMuZmlsbExpbmVEYXNoJiZvLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIixzLmZpbGxMaW5lRGFzaC5qb2luKFwiIFwiKS50cmltKCkpLHMuZmlsbExpbmVEYXNoT2Zmc2V0JiZvLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNob2Zmc2V0XCIsYCR7cy5maWxsTGluZURhc2hPZmZzZXR9YCksb31nZXQgZ2VuZXJhdG9yKCl7cmV0dXJuIHRoaXMuZ2VufWdldERlZmF1bHRPcHRpb25zKCl7cmV0dXJuIHRoaXMuZ2VuLmRlZmF1bHRPcHRpb25zfW9wc1RvUGF0aCh0LGUpe3JldHVybiB0aGlzLmdlbi5vcHNUb1BhdGgodCxlKX1saW5lKHQsZSxzLG4sbyl7Y29uc3QgYT10aGlzLmdlbi5saW5lKHQsZSxzLG4sbyk7cmV0dXJuIHRoaXMuZHJhdyhhKX1yZWN0YW5nbGUodCxlLHMsbixvKXtjb25zdCBhPXRoaXMuZ2VuLnJlY3RhbmdsZSh0LGUscyxuLG8pO3JldHVybiB0aGlzLmRyYXcoYSl9ZWxsaXBzZSh0LGUscyxuLG8pe2NvbnN0IGE9dGhpcy5nZW4uZWxsaXBzZSh0LGUscyxuLG8pO3JldHVybiB0aGlzLmRyYXcoYSl9Y2lyY2xlKHQsZSxzLG4pe2NvbnN0IG89dGhpcy5nZW4uY2lyY2xlKHQsZSxzLG4pO3JldHVybiB0aGlzLmRyYXcobyl9bGluZWFyUGF0aCh0LGUpe2NvbnN0IHM9dGhpcy5nZW4ubGluZWFyUGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcocyl9cG9seWdvbih0LGUpe2NvbnN0IHM9dGhpcy5nZW4ucG9seWdvbih0LGUpO3JldHVybiB0aGlzLmRyYXcocyl9YXJjKHQsZSxzLG4sbyxhLGg9ITEscil7Y29uc3QgaT10aGlzLmdlbi5hcmModCxlLHMsbixvLGEsaCxyKTtyZXR1cm4gdGhpcy5kcmF3KGkpfWN1cnZlKHQsZSl7Y29uc3Qgcz10aGlzLmdlbi5jdXJ2ZSh0LGUpO3JldHVybiB0aGlzLmRyYXcocyl9cGF0aCh0LGUpe2NvbnN0IHM9dGhpcy5nZW4ucGF0aCh0LGUpO3JldHVybiB0aGlzLmRyYXcocyl9fXZhciBhdD17Y2FudmFzOih0LGUpPT5uZXcgc3QodCxlKSxzdmc6KHQsZSk9Pm5ldyBvdCh0LGUpLGdlbmVyYXRvcjp0PT5uZXcgZXQodCksbmV3U2VlZDooKT0+ZXQubmV3U2VlZCgpfTtleHBvcnR7YXQgYXMgZGVmYXVsdH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/roughjs/bundled/rough.esm.js\n");

/***/ })

};
;
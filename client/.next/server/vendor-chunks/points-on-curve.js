"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/points-on-curve";
exports.ids = ["vendor-chunks/points-on-curve"];
exports.modules = {

/***/ "(ssr)/./node_modules/points-on-curve/lib/curve-to-bezier.js":
/*!*************************************************************!*\
  !*** ./node_modules/points-on-curve/lib/curve-to-bezier.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   curveToBezier: () => (/* binding */ curveToBezier)\n/* harmony export */ });\nfunction clone(p) {\n    return [...p];\n}\nfunction curveToBezier(pointsIn, curveTightness = 0) {\n    const len = pointsIn.length;\n    if (len < 3) {\n        throw new Error('A curve must have at least three points.');\n    }\n    const out = [];\n    if (len === 3) {\n        out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));\n    }\n    else {\n        const points = [];\n        points.push(pointsIn[0], pointsIn[0]);\n        for (let i = 1; i < pointsIn.length; i++) {\n            points.push(pointsIn[i]);\n            if (i === (pointsIn.length - 1)) {\n                points.push(pointsIn[i]);\n            }\n        }\n        const b = [];\n        const s = 1 - curveTightness;\n        out.push(clone(points[0]));\n        for (let i = 1; (i + 2) < points.length; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            out.push(b[1], b[2], b[3]);\n        }\n    }\n    return out;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLWN1cnZlL2xpYi9jdXJ2ZS10by1iZXppZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9wb2ludHMtb24tY3VydmUvbGliL2N1cnZlLXRvLWJlemllci5qcz81YjAzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNsb25lKHApIHtcbiAgICByZXR1cm4gWy4uLnBdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1cnZlVG9CZXppZXIocG9pbnRzSW4sIGN1cnZlVGlnaHRuZXNzID0gMCkge1xuICAgIGNvbnN0IGxlbiA9IHBvaW50c0luLmxlbmd0aDtcbiAgICBpZiAobGVuIDwgMykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VydmUgbXVzdCBoYXZlIGF0IGxlYXN0IHRocmVlIHBvaW50cy4nKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgaWYgKGxlbiA9PT0gMykge1xuICAgICAgICBvdXQucHVzaChjbG9uZShwb2ludHNJblswXSksIGNsb25lKHBvaW50c0luWzFdKSwgY2xvbmUocG9pbnRzSW5bMl0pLCBjbG9uZShwb2ludHNJblsyXSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50c0luWzBdLCBwb2ludHNJblswXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzSW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50c0luW2ldKTtcbiAgICAgICAgICAgIGlmIChpID09PSAocG9pbnRzSW4ubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChwb2ludHNJbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYiA9IFtdO1xuICAgICAgICBjb25zdCBzID0gMSAtIGN1cnZlVGlnaHRuZXNzO1xuICAgICAgICBvdXQucHVzaChjbG9uZShwb2ludHNbMF0pKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IChpICsgMikgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFZlcnRBcnJheSA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGJbMF0gPSBbY2FjaGVkVmVydEFycmF5WzBdLCBjYWNoZWRWZXJ0QXJyYXlbMV1dO1xuICAgICAgICAgICAgYlsxXSA9IFtjYWNoZWRWZXJ0QXJyYXlbMF0gKyAocyAqIHBvaW50c1tpICsgMV1bMF0gLSBzICogcG9pbnRzW2kgLSAxXVswXSkgLyA2LCBjYWNoZWRWZXJ0QXJyYXlbMV0gKyAocyAqIHBvaW50c1tpICsgMV1bMV0gLSBzICogcG9pbnRzW2kgLSAxXVsxXSkgLyA2XTtcbiAgICAgICAgICAgIGJbMl0gPSBbcG9pbnRzW2kgKyAxXVswXSArIChzICogcG9pbnRzW2ldWzBdIC0gcyAqIHBvaW50c1tpICsgMl1bMF0pIC8gNiwgcG9pbnRzW2kgKyAxXVsxXSArIChzICogcG9pbnRzW2ldWzFdIC0gcyAqIHBvaW50c1tpICsgMl1bMV0pIC8gNl07XG4gICAgICAgICAgICBiWzNdID0gW3BvaW50c1tpICsgMV1bMF0sIHBvaW50c1tpICsgMV1bMV1dO1xuICAgICAgICAgICAgb3V0LnB1c2goYlsxXSwgYlsyXSwgYlszXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/points-on-curve/lib/curve-to-bezier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/points-on-curve/lib/index.js":
/*!***************************************************!*\
  !*** ./node_modules/points-on-curve/lib/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pointsOnBezierCurves: () => (/* binding */ pointsOnBezierCurves),\n/* harmony export */   simplify: () => (/* binding */ simplify)\n/* harmony export */ });\n// distance between 2 points\nfunction distance(p1, p2) {\n    return Math.sqrt(distanceSq(p1, p2));\n}\n// distance between 2 points squared\nfunction distanceSq(p1, p2) {\n    return Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2);\n}\n// Sistance squared from a point p to the line segment vw\nfunction distanceToSegmentSq(p, v, w) {\n    const l2 = distanceSq(v, w);\n    if (l2 === 0) {\n        return distanceSq(p, v);\n    }\n    let t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n    t = Math.max(0, Math.min(1, t));\n    return distanceSq(p, lerp(v, w, t));\n}\nfunction lerp(a, b, t) {\n    return [\n        a[0] + (b[0] - a[0]) * t,\n        a[1] + (b[1] - a[1]) * t,\n    ];\n}\n// Adapted from https://seant23.wordpress.com/2010/11/12/offset-bezier-curves/\nfunction flatness(points, offset) {\n    const p1 = points[offset + 0];\n    const p2 = points[offset + 1];\n    const p3 = points[offset + 2];\n    const p4 = points[offset + 3];\n    let ux = 3 * p2[0] - 2 * p1[0] - p4[0];\n    ux *= ux;\n    let uy = 3 * p2[1] - 2 * p1[1] - p4[1];\n    uy *= uy;\n    let vx = 3 * p3[0] - 2 * p4[0] - p1[0];\n    vx *= vx;\n    let vy = 3 * p3[1] - 2 * p4[1] - p1[1];\n    vy *= vy;\n    if (ux < vx) {\n        ux = vx;\n    }\n    if (uy < vy) {\n        uy = vy;\n    }\n    return ux + uy;\n}\nfunction getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {\n    const outPoints = newPoints || [];\n    if (flatness(points, offset) < tolerance) {\n        const p0 = points[offset + 0];\n        if (outPoints.length) {\n            const d = distance(outPoints[outPoints.length - 1], p0);\n            if (d > 1) {\n                outPoints.push(p0);\n            }\n        }\n        else {\n            outPoints.push(p0);\n        }\n        outPoints.push(points[offset + 3]);\n    }\n    else {\n        // subdivide\n        const t = .5;\n        const p1 = points[offset + 0];\n        const p2 = points[offset + 1];\n        const p3 = points[offset + 2];\n        const p4 = points[offset + 3];\n        const q1 = lerp(p1, p2, t);\n        const q2 = lerp(p2, p3, t);\n        const q3 = lerp(p3, p4, t);\n        const r1 = lerp(q1, q2, t);\n        const r2 = lerp(q2, q3, t);\n        const red = lerp(r1, r2, t);\n        getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);\n        getPointsOnBezierCurveWithSplitting([red, r2, q3, p4], 0, tolerance, outPoints);\n    }\n    return outPoints;\n}\nfunction simplify(points, distance) {\n    return simplifyPoints(points, 0, points.length, distance);\n}\n// Ramer–Douglas–Peucker algorithm\n// https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm\nfunction simplifyPoints(points, start, end, epsilon, newPoints) {\n    const outPoints = newPoints || [];\n    // find the most distance point from the endpoints\n    const s = points[start];\n    const e = points[end - 1];\n    let maxDistSq = 0;\n    let maxNdx = 1;\n    for (let i = start + 1; i < end - 1; ++i) {\n        const distSq = distanceToSegmentSq(points[i], s, e);\n        if (distSq > maxDistSq) {\n            maxDistSq = distSq;\n            maxNdx = i;\n        }\n    }\n    // if that point is too far, split\n    if (Math.sqrt(maxDistSq) > epsilon) {\n        simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);\n        simplifyPoints(points, maxNdx, end, epsilon, outPoints);\n    }\n    else {\n        if (!outPoints.length) {\n            outPoints.push(s);\n        }\n        outPoints.push(e);\n    }\n    return outPoints;\n}\nfunction pointsOnBezierCurves(points, tolerance = 0.15, distance) {\n    const newPoints = [];\n    const numSegments = (points.length - 1) / 3;\n    for (let i = 0; i < numSegments; i++) {\n        const offset = i * 3;\n        getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);\n    }\n    if (distance && distance > 0) {\n        return simplifyPoints(newPoints, 0, newPoints.length, distance);\n    }\n    return newPoints;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9pbnRzLW9uLWN1cnZlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pZGVhZmxvdy8uL25vZGVfbW9kdWxlcy9wb2ludHMtb24tY3VydmUvbGliL2luZGV4LmpzP2NiMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChkaXN0YW5jZVNxKHAxLCBwMikpO1xufVxuLy8gZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50cyBzcXVhcmVkXG5mdW5jdGlvbiBkaXN0YW5jZVNxKHAxLCBwMikge1xuICAgIHJldHVybiBNYXRoLnBvdyhwMVswXSAtIHAyWzBdLCAyKSArIE1hdGgucG93KHAxWzFdIC0gcDJbMV0sIDIpO1xufVxuLy8gU2lzdGFuY2Ugc3F1YXJlZCBmcm9tIGEgcG9pbnQgcCB0byB0aGUgbGluZSBzZWdtZW50IHZ3XG5mdW5jdGlvbiBkaXN0YW5jZVRvU2VnbWVudFNxKHAsIHYsIHcpIHtcbiAgICBjb25zdCBsMiA9IGRpc3RhbmNlU3Eodiwgdyk7XG4gICAgaWYgKGwyID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZVNxKHAsIHYpO1xuICAgIH1cbiAgICBsZXQgdCA9ICgocFswXSAtIHZbMF0pICogKHdbMF0gLSB2WzBdKSArIChwWzFdIC0gdlsxXSkgKiAod1sxXSAtIHZbMV0pKSAvIGwyO1xuICAgIHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0KSk7XG4gICAgcmV0dXJuIGRpc3RhbmNlU3EocCwgbGVycCh2LCB3LCB0KSk7XG59XG5mdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBhWzBdICsgKGJbMF0gLSBhWzBdKSAqIHQsXG4gICAgICAgIGFbMV0gKyAoYlsxXSAtIGFbMV0pICogdCxcbiAgICBdO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc2VhbnQyMy53b3JkcHJlc3MuY29tLzIwMTAvMTEvMTIvb2Zmc2V0LWJlemllci1jdXJ2ZXMvXG5mdW5jdGlvbiBmbGF0bmVzcyhwb2ludHMsIG9mZnNldCkge1xuICAgIGNvbnN0IHAxID0gcG9pbnRzW29mZnNldCArIDBdO1xuICAgIGNvbnN0IHAyID0gcG9pbnRzW29mZnNldCArIDFdO1xuICAgIGNvbnN0IHAzID0gcG9pbnRzW29mZnNldCArIDJdO1xuICAgIGNvbnN0IHA0ID0gcG9pbnRzW29mZnNldCArIDNdO1xuICAgIGxldCB1eCA9IDMgKiBwMlswXSAtIDIgKiBwMVswXSAtIHA0WzBdO1xuICAgIHV4ICo9IHV4O1xuICAgIGxldCB1eSA9IDMgKiBwMlsxXSAtIDIgKiBwMVsxXSAtIHA0WzFdO1xuICAgIHV5ICo9IHV5O1xuICAgIGxldCB2eCA9IDMgKiBwM1swXSAtIDIgKiBwNFswXSAtIHAxWzBdO1xuICAgIHZ4ICo9IHZ4O1xuICAgIGxldCB2eSA9IDMgKiBwM1sxXSAtIDIgKiBwNFsxXSAtIHAxWzFdO1xuICAgIHZ5ICo9IHZ5O1xuICAgIGlmICh1eCA8IHZ4KSB7XG4gICAgICAgIHV4ID0gdng7XG4gICAgfVxuICAgIGlmICh1eSA8IHZ5KSB7XG4gICAgICAgIHV5ID0gdnk7XG4gICAgfVxuICAgIHJldHVybiB1eCArIHV5O1xufVxuZnVuY3Rpb24gZ2V0UG9pbnRzT25CZXppZXJDdXJ2ZVdpdGhTcGxpdHRpbmcocG9pbnRzLCBvZmZzZXQsIHRvbGVyYW5jZSwgbmV3UG9pbnRzKSB7XG4gICAgY29uc3Qgb3V0UG9pbnRzID0gbmV3UG9pbnRzIHx8IFtdO1xuICAgIGlmIChmbGF0bmVzcyhwb2ludHMsIG9mZnNldCkgPCB0b2xlcmFuY2UpIHtcbiAgICAgICAgY29uc3QgcDAgPSBwb2ludHNbb2Zmc2V0ICsgMF07XG4gICAgICAgIGlmIChvdXRQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gZGlzdGFuY2Uob3V0UG9pbnRzW291dFBvaW50cy5sZW5ndGggLSAxXSwgcDApO1xuICAgICAgICAgICAgaWYgKGQgPiAxKSB7XG4gICAgICAgICAgICAgICAgb3V0UG9pbnRzLnB1c2gocDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0UG9pbnRzLnB1c2gocDApO1xuICAgICAgICB9XG4gICAgICAgIG91dFBvaW50cy5wdXNoKHBvaW50c1tvZmZzZXQgKyAzXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBzdWJkaXZpZGVcbiAgICAgICAgY29uc3QgdCA9IC41O1xuICAgICAgICBjb25zdCBwMSA9IHBvaW50c1tvZmZzZXQgKyAwXTtcbiAgICAgICAgY29uc3QgcDIgPSBwb2ludHNbb2Zmc2V0ICsgMV07XG4gICAgICAgIGNvbnN0IHAzID0gcG9pbnRzW29mZnNldCArIDJdO1xuICAgICAgICBjb25zdCBwNCA9IHBvaW50c1tvZmZzZXQgKyAzXTtcbiAgICAgICAgY29uc3QgcTEgPSBsZXJwKHAxLCBwMiwgdCk7XG4gICAgICAgIGNvbnN0IHEyID0gbGVycChwMiwgcDMsIHQpO1xuICAgICAgICBjb25zdCBxMyA9IGxlcnAocDMsIHA0LCB0KTtcbiAgICAgICAgY29uc3QgcjEgPSBsZXJwKHExLCBxMiwgdCk7XG4gICAgICAgIGNvbnN0IHIyID0gbGVycChxMiwgcTMsIHQpO1xuICAgICAgICBjb25zdCByZWQgPSBsZXJwKHIxLCByMiwgdCk7XG4gICAgICAgIGdldFBvaW50c09uQmV6aWVyQ3VydmVXaXRoU3BsaXR0aW5nKFtwMSwgcTEsIHIxLCByZWRdLCAwLCB0b2xlcmFuY2UsIG91dFBvaW50cyk7XG4gICAgICAgIGdldFBvaW50c09uQmV6aWVyQ3VydmVXaXRoU3BsaXR0aW5nKFtyZWQsIHIyLCBxMywgcDRdLCAwLCB0b2xlcmFuY2UsIG91dFBvaW50cyk7XG4gICAgfVxuICAgIHJldHVybiBvdXRQb2ludHM7XG59XG5leHBvcnQgZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCBkaXN0YW5jZSkge1xuICAgIHJldHVybiBzaW1wbGlmeVBvaW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIGRpc3RhbmNlKTtcbn1cbi8vIFJhbWVy4oCTRG91Z2xhc+KAk1BldWNrZXIgYWxnb3JpdGhtXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9SYW1lciVFMiU4MCU5M0RvdWdsYXMlRTIlODAlOTNQZXVja2VyX2FsZ29yaXRobVxuZnVuY3Rpb24gc2ltcGxpZnlQb2ludHMocG9pbnRzLCBzdGFydCwgZW5kLCBlcHNpbG9uLCBuZXdQb2ludHMpIHtcbiAgICBjb25zdCBvdXRQb2ludHMgPSBuZXdQb2ludHMgfHwgW107XG4gICAgLy8gZmluZCB0aGUgbW9zdCBkaXN0YW5jZSBwb2ludCBmcm9tIHRoZSBlbmRwb2ludHNcbiAgICBjb25zdCBzID0gcG9pbnRzW3N0YXJ0XTtcbiAgICBjb25zdCBlID0gcG9pbnRzW2VuZCAtIDFdO1xuICAgIGxldCBtYXhEaXN0U3EgPSAwO1xuICAgIGxldCBtYXhOZHggPSAxO1xuICAgIGZvciAobGV0IGkgPSBzdGFydCArIDE7IGkgPCBlbmQgLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgZGlzdFNxID0gZGlzdGFuY2VUb1NlZ21lbnRTcShwb2ludHNbaV0sIHMsIGUpO1xuICAgICAgICBpZiAoZGlzdFNxID4gbWF4RGlzdFNxKSB7XG4gICAgICAgICAgICBtYXhEaXN0U3EgPSBkaXN0U3E7XG4gICAgICAgICAgICBtYXhOZHggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHRoYXQgcG9pbnQgaXMgdG9vIGZhciwgc3BsaXRcbiAgICBpZiAoTWF0aC5zcXJ0KG1heERpc3RTcSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgc3RhcnQsIG1heE5keCArIDEsIGVwc2lsb24sIG91dFBvaW50cyk7XG4gICAgICAgIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgbWF4TmR4LCBlbmQsIGVwc2lsb24sIG91dFBvaW50cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW91dFBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dFBvaW50cy5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICAgIG91dFBvaW50cy5wdXNoKGUpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0UG9pbnRzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvaW50c09uQmV6aWVyQ3VydmVzKHBvaW50cywgdG9sZXJhbmNlID0gMC4xNSwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBuZXdQb2ludHMgPSBbXTtcbiAgICBjb25zdCBudW1TZWdtZW50cyA9IChwb2ludHMubGVuZ3RoIC0gMSkgLyAzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBpICogMztcbiAgICAgICAgZ2V0UG9pbnRzT25CZXppZXJDdXJ2ZVdpdGhTcGxpdHRpbmcocG9pbnRzLCBvZmZzZXQsIHRvbGVyYW5jZSwgbmV3UG9pbnRzKTtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlICYmIGRpc3RhbmNlID4gMCkge1xuICAgICAgICByZXR1cm4gc2ltcGxpZnlQb2ludHMobmV3UG9pbnRzLCAwLCBuZXdQb2ludHMubGVuZ3RoLCBkaXN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/points-on-curve/lib/index.js\n");

/***/ })

};
;